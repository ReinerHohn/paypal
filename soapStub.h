/* soapStub.h
   Generated by gSOAP 2.8.54 for paypal.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"urn:ebay:api:PayPalAPI"
#define SOAP_NAMESPACE_OF_ns2	"urn:ebay:apis:CoreComponentTypes"
#define SOAP_NAMESPACE_OF_ns3	"urn:ebay:apis:eBLBaseComponents"
#define SOAP_NAMESPACE_OF_ns4	"urn:ebay:apis:EnhancedDataTypes"
#include <chrono>

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20854
# error "GSOAP VERSION 20854 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* paypal.h:1387 */
#ifndef SOAP_TYPE_ns3__AccountStateCodeType
#define SOAP_TYPE_ns3__AccountStateCodeType (397)
/* ns3:AccountStateCodeType */
enum ns3__AccountStateCodeType {
	ns3__AccountStateCodeType__Active = 0,
	ns3__AccountStateCodeType__Pending = 1,
	ns3__AccountStateCodeType__Inactive = 2,
	ns3__AccountStateCodeType__CustomCode = 3
};
#endif

/* paypal.h:1414 */
#ifndef SOAP_TYPE_ns3__AckCodeType
#define SOAP_TYPE_ns3__AckCodeType (398)
/* ns3:AckCodeType */
enum ns3__AckCodeType {
	ns3__AckCodeType__Success = 0,
	ns3__AckCodeType__Failure = 1,
	ns3__AckCodeType__Warning = 2,
	ns3__AckCodeType__SuccessWithWarning = 3,
	ns3__AckCodeType__FailureWithWarning = 4,
	ns3__AckCodeType__PartialSuccess = 5,
	ns3__AckCodeType__CustomCode = 6
};
#endif

/* paypal.h:1459 */
#ifndef SOAP_TYPE_ns3__AddressOwnerCodeType
#define SOAP_TYPE_ns3__AddressOwnerCodeType (399)
/* ns3:AddressOwnerCodeType */
enum ns3__AddressOwnerCodeType {
	ns3__AddressOwnerCodeType__PayPal = 0,
	ns3__AddressOwnerCodeType__eBay = 1,
	ns3__AddressOwnerCodeType__CustomCode = 2
};
#endif

/* paypal.h:1482 */
#ifndef SOAP_TYPE_ns3__AuctionTypeCodeType
#define SOAP_TYPE_ns3__AuctionTypeCodeType (400)
/* ns3:AuctionTypeCodeType */
enum ns3__AuctionTypeCodeType {
	ns3__AuctionTypeCodeType__Unknown = 0,
	ns3__AuctionTypeCodeType__Chinese = 1,
	ns3__AuctionTypeCodeType__Dutch = 2,
	ns3__AuctionTypeCodeType__Live = 3,
	ns3__AuctionTypeCodeType__Ad_x0020type = 4,
	ns3__AuctionTypeCodeType__Stores_x0020Fixed_price = 5,
	ns3__AuctionTypeCodeType__Personal_x0020Offer = 6,
	ns3__AuctionTypeCodeType__Fixed_x0020Price_x0020Item = 7,
	ns3__AuctionTypeCodeType__CustomCode = 8
};
#endif

/* paypal.h:1529 */
#ifndef SOAP_TYPE_ns3__BalanceCodeType
#define SOAP_TYPE_ns3__BalanceCodeType (401)
/* ns3:BalanceCodeType */
enum ns3__BalanceCodeType {
	ns3__BalanceCodeType__Other = 0,
	ns3__BalanceCodeType__CustomCode = 1
};
#endif

/* paypal.h:1547 */
#ifndef SOAP_TYPE_ns3__BuyerPaymentMethodCodeType
#define SOAP_TYPE_ns3__BuyerPaymentMethodCodeType (402)
/* ns3:BuyerPaymentMethodCodeType */
enum ns3__BuyerPaymentMethodCodeType {
	ns3__BuyerPaymentMethodCodeType__None = 0,
	ns3__BuyerPaymentMethodCodeType__MOCC = 1,
	ns3__BuyerPaymentMethodCodeType__AmEx = 2,
	ns3__BuyerPaymentMethodCodeType__PaymentSeeDescription = 3,
	ns3__BuyerPaymentMethodCodeType__CCAccepted = 4,
	ns3__BuyerPaymentMethodCodeType__PersonalCheck = 5,
	ns3__BuyerPaymentMethodCodeType__COD = 6,
	ns3__BuyerPaymentMethodCodeType__VisaMC = 7,
	ns3__BuyerPaymentMethodCodeType__Other = 8,
	ns3__BuyerPaymentMethodCodeType__PayPal = 9,
	ns3__BuyerPaymentMethodCodeType__Discover = 10,
	ns3__BuyerPaymentMethodCodeType__CashOnPickup = 11,
	ns3__BuyerPaymentMethodCodeType__MoneyXferAccepted = 12,
	ns3__BuyerPaymentMethodCodeType__MoneyXferAcceptedinCheckout = 13,
	ns3__BuyerPaymentMethodCodeType__OtherOnlinePayments = 14,
	ns3__BuyerPaymentMethodCodeType__CustomCode = 15
};
#endif

/* paypal.h:1622 */
#ifndef SOAP_TYPE_ns3__BuyerProtectionCodeType
#define SOAP_TYPE_ns3__BuyerProtectionCodeType (403)
/* ns3:BuyerProtectionCodeType */
enum ns3__BuyerProtectionCodeType {
	ns3__BuyerProtectionCodeType__ItemIneligible = 0,
	ns3__BuyerProtectionCodeType__ItemEligible = 1,
	ns3__BuyerProtectionCodeType__ItemMarkedIneligible = 2,
	ns3__BuyerProtectionCodeType__ItemMarkedEligible = 3,
	ns3__BuyerProtectionCodeType__CustomCode = 4
};
#endif

/* paypal.h:1652 */
#ifndef SOAP_TYPE_ns3__CheckoutStatusCodeType
#define SOAP_TYPE_ns3__CheckoutStatusCodeType (404)
/* ns3:CheckoutStatusCodeType */
enum ns3__CheckoutStatusCodeType {
	ns3__CheckoutStatusCodeType__CheckoutComplete = 0,
	ns3__CheckoutStatusCodeType__CheckoutIncomplete = 1,
	ns3__CheckoutStatusCodeType__BuyerRequestsTotal = 2,
	ns3__CheckoutStatusCodeType__SellerResponded = 3,
	ns3__CheckoutStatusCodeType__CustomCode = 4
};
#endif

/* paypal.h:1686 */
#ifndef SOAP_TYPE_ns3__CountryCodeType
#define SOAP_TYPE_ns3__CountryCodeType (405)
/* ns3:CountryCodeType */
enum ns3__CountryCodeType {
	ns3__CountryCodeType__AF = 0,
	ns3__CountryCodeType__AL = 1,
	ns3__CountryCodeType__DZ = 2,
	ns3__CountryCodeType__AS = 3,
	ns3__CountryCodeType__AD = 4,
	ns3__CountryCodeType__AO = 5,
	ns3__CountryCodeType__AI = 6,
	ns3__CountryCodeType__AQ = 7,
	ns3__CountryCodeType__AG = 8,
	ns3__CountryCodeType__AR = 9,
	ns3__CountryCodeType__AM = 10,
	ns3__CountryCodeType__AW = 11,
	ns3__CountryCodeType__AU = 12,
	ns3__CountryCodeType__AT = 13,
	ns3__CountryCodeType__AZ = 14,
	ns3__CountryCodeType__BS = 15,
	ns3__CountryCodeType__BH = 16,
	ns3__CountryCodeType__BD = 17,
	ns3__CountryCodeType__BB = 18,
	ns3__CountryCodeType__BY = 19,
	ns3__CountryCodeType__BE = 20,
	ns3__CountryCodeType__BZ = 21,
	ns3__CountryCodeType__BJ = 22,
	ns3__CountryCodeType__BM = 23,
	ns3__CountryCodeType__BT = 24,
	ns3__CountryCodeType__BO = 25,
	ns3__CountryCodeType__BA = 26,
	ns3__CountryCodeType__BW = 27,
	ns3__CountryCodeType__BV = 28,
	ns3__CountryCodeType__BR = 29,
	ns3__CountryCodeType__IO = 30,
	ns3__CountryCodeType__BN = 31,
	ns3__CountryCodeType__BG = 32,
	ns3__CountryCodeType__BF = 33,
	ns3__CountryCodeType__BI = 34,
	ns3__CountryCodeType__KH = 35,
	ns3__CountryCodeType__CM = 36,
	ns3__CountryCodeType__CA = 37,
	ns3__CountryCodeType__CV = 38,
	ns3__CountryCodeType__KY = 39,
	ns3__CountryCodeType__CF = 40,
	ns3__CountryCodeType__TD = 41,
	ns3__CountryCodeType__CL = 42,
	ns3__CountryCodeType__C2 = 43,
	ns3__CountryCodeType__CN = 44,
	ns3__CountryCodeType__CX = 45,
	ns3__CountryCodeType__CC = 46,
	ns3__CountryCodeType__CO = 47,
	ns3__CountryCodeType__KM = 48,
	ns3__CountryCodeType__CG = 49,
	ns3__CountryCodeType__CD = 50,
	ns3__CountryCodeType__CK = 51,
	ns3__CountryCodeType__CR = 52,
	ns3__CountryCodeType__CI = 53,
	ns3__CountryCodeType__HR = 54,
	ns3__CountryCodeType__CU = 55,
	ns3__CountryCodeType__CY = 56,
	ns3__CountryCodeType__CZ = 57,
	ns3__CountryCodeType__DK = 58,
	ns3__CountryCodeType__DJ = 59,
	ns3__CountryCodeType__DM = 60,
	ns3__CountryCodeType__DO = 61,
	ns3__CountryCodeType__TP = 62,
	ns3__CountryCodeType__EC = 63,
	ns3__CountryCodeType__EG = 64,
	ns3__CountryCodeType__SV = 'A',
	ns3__CountryCodeType__GQ = 'B',
	ns3__CountryCodeType__ER = 'C',
	ns3__CountryCodeType__EE = 'D',
	ns3__CountryCodeType__ET = 'E',
	ns3__CountryCodeType__FK = 'F',
	ns3__CountryCodeType__FO = 'G',
	ns3__CountryCodeType__FJ = 'H',
	ns3__CountryCodeType__FI = 'I',
	ns3__CountryCodeType__FR = 'J',
	ns3__CountryCodeType__GF = 'K',
	ns3__CountryCodeType__PF = 'L',
	ns3__CountryCodeType__TF = 'M',
	ns3__CountryCodeType__GA = 'N',
	ns3__CountryCodeType__GM = 'O',
	ns3__CountryCodeType__GE = 'P',
	ns3__CountryCodeType__DE = 'Q',
	ns3__CountryCodeType__GH = 'R',
	ns3__CountryCodeType__GI = 'S',
	ns3__CountryCodeType__GR = 'T',
	ns3__CountryCodeType__GL = 'U',
	ns3__CountryCodeType__GD = 'V',
	ns3__CountryCodeType__GP = 'W',
	ns3__CountryCodeType__GU = 'X',
	ns3__CountryCodeType__GT = 'Y',
	ns3__CountryCodeType__GN = 'Z',
	ns3__CountryCodeType__GW = 91,
	ns3__CountryCodeType__GY = 92,
	ns3__CountryCodeType__HT = 93,
	ns3__CountryCodeType__HM = 94,
	ns3__CountryCodeType__VA = 95,
	ns3__CountryCodeType__HN = 96,
	ns3__CountryCodeType__HK = 'a',
	ns3__CountryCodeType__HU = 'b',
	ns3__CountryCodeType__IS = 'c',
	ns3__CountryCodeType__IN = 'd',
	ns3__CountryCodeType__ID = 'e',
	ns3__CountryCodeType__IR = 'f',
	ns3__CountryCodeType__IQ = 'g',
	ns3__CountryCodeType__IE = 'h',
	ns3__CountryCodeType__IL = 'i',
	ns3__CountryCodeType__IT = 'j',
	ns3__CountryCodeType__JM = 'k',
	ns3__CountryCodeType__JP = 'l',
	ns3__CountryCodeType__JO = 'm',
	ns3__CountryCodeType__KZ = 'n',
	ns3__CountryCodeType__KE = 'o',
	ns3__CountryCodeType__KI = 'p',
	ns3__CountryCodeType__KP = 'q',
	ns3__CountryCodeType__KR = 'r',
	ns3__CountryCodeType__KW = 's',
	ns3__CountryCodeType__KG = 't',
	ns3__CountryCodeType__LA = 'u',
	ns3__CountryCodeType__LV = 'v',
	ns3__CountryCodeType__LB = 'w',
	ns3__CountryCodeType__LS = 'x',
	ns3__CountryCodeType__LR = 'y',
	ns3__CountryCodeType__LY = 'z',
	ns3__CountryCodeType__LI = 123,
	ns3__CountryCodeType__LT = 124,
	ns3__CountryCodeType__LU = 125,
	ns3__CountryCodeType__MO = 126,
	ns3__CountryCodeType__MK = 127,
	ns3__CountryCodeType__MG = 128,
	ns3__CountryCodeType__MW = 129,
	ns3__CountryCodeType__MY = 130,
	ns3__CountryCodeType__MV = 131,
	ns3__CountryCodeType__ML = 132,
	ns3__CountryCodeType__MT = 133,
	ns3__CountryCodeType__MH = 134,
	ns3__CountryCodeType__MQ = 135,
	ns3__CountryCodeType__MR = 136,
	ns3__CountryCodeType__MU = 137,
	ns3__CountryCodeType__YT = 138,
	ns3__CountryCodeType__MX = 139,
	ns3__CountryCodeType__FM = 140,
	ns3__CountryCodeType__MD = 141,
	ns3__CountryCodeType__MC = 142,
	ns3__CountryCodeType__MN = 143,
	ns3__CountryCodeType__MS = 144,
	ns3__CountryCodeType__MA = 145,
	ns3__CountryCodeType__MZ = 146,
	ns3__CountryCodeType__MM = 147,
	ns3__CountryCodeType__NA = 148,
	ns3__CountryCodeType__NR = 149,
	ns3__CountryCodeType__NP = 150,
	ns3__CountryCodeType__NL = 151,
	ns3__CountryCodeType__AN = 152,
	ns3__CountryCodeType__NC = 153,
	ns3__CountryCodeType__NZ = 154,
	ns3__CountryCodeType__NI = 155,
	ns3__CountryCodeType__NE = 156,
	ns3__CountryCodeType__NG = 157,
	ns3__CountryCodeType__NU = 158,
	ns3__CountryCodeType__NF = 159,
	ns3__CountryCodeType__MP = 160,
	ns3__CountryCodeType__NO = 161,
	ns3__CountryCodeType__OM = 162,
	ns3__CountryCodeType__PK = 163,
	ns3__CountryCodeType__PW = 164,
	ns3__CountryCodeType__PS = 165,
	ns3__CountryCodeType__PA = 166,
	ns3__CountryCodeType__PG = 167,
	ns3__CountryCodeType__PY = 168,
	ns3__CountryCodeType__PE = 169,
	ns3__CountryCodeType__PH = 170,
	ns3__CountryCodeType__PN = 171,
	ns3__CountryCodeType__PL = 172,
	ns3__CountryCodeType__PT = 173,
	ns3__CountryCodeType__PR = 174,
	ns3__CountryCodeType__QA = 175,
	ns3__CountryCodeType__RE = 176,
	ns3__CountryCodeType__RO = 177,
	ns3__CountryCodeType__RU = 178,
	ns3__CountryCodeType__RW = 179,
	ns3__CountryCodeType__SH = 180,
	ns3__CountryCodeType__KN = 181,
	ns3__CountryCodeType__LC = 182,
	ns3__CountryCodeType__PM = 183,
	ns3__CountryCodeType__VC = 184,
	ns3__CountryCodeType__WS = 185,
	ns3__CountryCodeType__SM = 186,
	ns3__CountryCodeType__ST = 187,
	ns3__CountryCodeType__SA = 188,
	ns3__CountryCodeType__SN = 189,
	ns3__CountryCodeType__SC = 190,
	ns3__CountryCodeType__SL = 191,
	ns3__CountryCodeType__SG = 192,
	ns3__CountryCodeType__SK = 193,
	ns3__CountryCodeType__SI = 194,
	ns3__CountryCodeType__SB = 195,
	ns3__CountryCodeType__SO = 196,
	ns3__CountryCodeType__ZA = 197,
	ns3__CountryCodeType__GS = 198,
	ns3__CountryCodeType__ES = 199,
	ns3__CountryCodeType__LK = 200,
	ns3__CountryCodeType__SD = 201,
	ns3__CountryCodeType__SR = 202,
	ns3__CountryCodeType__SJ = 203,
	ns3__CountryCodeType__SZ = 204,
	ns3__CountryCodeType__SE = 205,
	ns3__CountryCodeType__CH = 206,
	ns3__CountryCodeType__SY = 207,
	ns3__CountryCodeType__TW = 208,
	ns3__CountryCodeType__TJ = 209,
	ns3__CountryCodeType__TZ = 210,
	ns3__CountryCodeType__TH = 211,
	ns3__CountryCodeType__TG = 212,
	ns3__CountryCodeType__TK = 213,
	ns3__CountryCodeType__TO = 214,
	ns3__CountryCodeType__TT = 215,
	ns3__CountryCodeType__TN = 216,
	ns3__CountryCodeType__TR = 217,
	ns3__CountryCodeType__TM = 218,
	ns3__CountryCodeType__TC = 219,
	ns3__CountryCodeType__TV = 220,
	ns3__CountryCodeType__UG = 221,
	ns3__CountryCodeType__UA = 222,
	ns3__CountryCodeType__AE = 223,
	ns3__CountryCodeType__GB = 224,
	ns3__CountryCodeType__US = 225,
	ns3__CountryCodeType__UM = 226,
	ns3__CountryCodeType__UY = 227,
	ns3__CountryCodeType__UZ = 228,
	ns3__CountryCodeType__VU = 229,
	ns3__CountryCodeType__VE = 230,
	ns3__CountryCodeType__VN = 231,
	ns3__CountryCodeType__VG = 232,
	ns3__CountryCodeType__VI = 233,
	ns3__CountryCodeType__WF = 234,
	ns3__CountryCodeType__EH = 235,
	ns3__CountryCodeType__YE = 236,
	ns3__CountryCodeType__YU = 237,
	ns3__CountryCodeType__ZM = 238,
	ns3__CountryCodeType__ZW = 239,
	ns3__CountryCodeType__AA = 240,
	ns3__CountryCodeType__QM = 241,
	ns3__CountryCodeType__QN = 242,
	ns3__CountryCodeType__QO = 243,
	ns3__CountryCodeType__QP = 244,
	ns3__CountryCodeType__CS = 245,
	ns3__CountryCodeType__CustomCode = 246,
	ns3__CountryCodeType__GG = 247,
	ns3__CountryCodeType__IM = 248,
	ns3__CountryCodeType__JE = 249,
	ns3__CountryCodeType__TL = 250,
	ns3__CountryCodeType__RS = 251,
	ns3__CountryCodeType__ME = 252
};
#endif

/* paypal.h:2063 */
#ifndef SOAP_TYPE_ns3__CurrencyCodeType
#define SOAP_TYPE_ns3__CurrencyCodeType (406)
/* ns3:CurrencyCodeType */
enum ns3__CurrencyCodeType {
	ns3__CurrencyCodeType__AFA = 0,
	ns3__CurrencyCodeType__ALL = 1,
	ns3__CurrencyCodeType__DZD = 2,
	ns3__CurrencyCodeType__ADP = 3,
	ns3__CurrencyCodeType__AOA = 4,
	ns3__CurrencyCodeType__ARS = 5,
	ns3__CurrencyCodeType__AMD = 6,
	ns3__CurrencyCodeType__AWG = 7,
	ns3__CurrencyCodeType__AZM = 8,
	ns3__CurrencyCodeType__BSD = 9,
	ns3__CurrencyCodeType__BHD = 10,
	ns3__CurrencyCodeType__BDT = 11,
	ns3__CurrencyCodeType__BBD = 12,
	ns3__CurrencyCodeType__BYR = 13,
	ns3__CurrencyCodeType__BZD = 14,
	ns3__CurrencyCodeType__BMD = 15,
	ns3__CurrencyCodeType__BTN = 16,
	ns3__CurrencyCodeType__INR = 17,
	ns3__CurrencyCodeType__BOV = 18,
	ns3__CurrencyCodeType__BOB = 19,
	ns3__CurrencyCodeType__BAM = 20,
	ns3__CurrencyCodeType__BWP = 21,
	ns3__CurrencyCodeType__BRL = 22,
	ns3__CurrencyCodeType__BND = 23,
	ns3__CurrencyCodeType__BGL = 24,
	ns3__CurrencyCodeType__BGN = 25,
	ns3__CurrencyCodeType__BIF = 26,
	ns3__CurrencyCodeType__KHR = 27,
	ns3__CurrencyCodeType__CAD = 28,
	ns3__CurrencyCodeType__CVE = 29,
	ns3__CurrencyCodeType__KYD = 30,
	ns3__CurrencyCodeType__XAF = 31,
	ns3__CurrencyCodeType__CLF = 32,
	ns3__CurrencyCodeType__CLP = 33,
	ns3__CurrencyCodeType__CNY = 34,
	ns3__CurrencyCodeType__COP = 35,
	ns3__CurrencyCodeType__KMF = 36,
	ns3__CurrencyCodeType__CDF = 37,
	ns3__CurrencyCodeType__CRC = 38,
	ns3__CurrencyCodeType__HRK = 39,
	ns3__CurrencyCodeType__CUP = 40,
	ns3__CurrencyCodeType__CYP = 41,
	ns3__CurrencyCodeType__CZK = 42,
	ns3__CurrencyCodeType__DKK = 43,
	ns3__CurrencyCodeType__DJF = 44,
	ns3__CurrencyCodeType__DOP = 45,
	ns3__CurrencyCodeType__TPE = 46,
	ns3__CurrencyCodeType__ECV = 47,
	ns3__CurrencyCodeType__ECS = 48,
	ns3__CurrencyCodeType__EGP = 49,
	ns3__CurrencyCodeType__SVC = 50,
	ns3__CurrencyCodeType__ERN = 51,
	ns3__CurrencyCodeType__EEK = 52,
	ns3__CurrencyCodeType__ETB = 53,
	ns3__CurrencyCodeType__FKP = 54,
	ns3__CurrencyCodeType__FJD = 55,
	ns3__CurrencyCodeType__GMD = 56,
	ns3__CurrencyCodeType__GEL = 57,
	ns3__CurrencyCodeType__GHC = 58,
	ns3__CurrencyCodeType__GIP = 59,
	ns3__CurrencyCodeType__GTQ = 60,
	ns3__CurrencyCodeType__GNF = 61,
	ns3__CurrencyCodeType__GWP = 62,
	ns3__CurrencyCodeType__GYD = 63,
	ns3__CurrencyCodeType__HTG = 64,
	ns3__CurrencyCodeType__HNL = 'A',
	ns3__CurrencyCodeType__HKD = 'B',
	ns3__CurrencyCodeType__HUF = 'C',
	ns3__CurrencyCodeType__ISK = 'D',
	ns3__CurrencyCodeType__IDR = 'E',
	ns3__CurrencyCodeType__IRR = 'F',
	ns3__CurrencyCodeType__IQD = 'G',
	ns3__CurrencyCodeType__ILS = 'H',
	ns3__CurrencyCodeType__JMD = 'I',
	ns3__CurrencyCodeType__JPY = 'J',
	ns3__CurrencyCodeType__JOD = 'K',
	ns3__CurrencyCodeType__KZT = 'L',
	ns3__CurrencyCodeType__KES = 'M',
	ns3__CurrencyCodeType__AUD = 'N',
	ns3__CurrencyCodeType__KPW = 'O',
	ns3__CurrencyCodeType__KRW = 'P',
	ns3__CurrencyCodeType__KWD = 'Q',
	ns3__CurrencyCodeType__KGS = 'R',
	ns3__CurrencyCodeType__LAK = 'S',
	ns3__CurrencyCodeType__LVL = 'T',
	ns3__CurrencyCodeType__LBP = 'U',
	ns3__CurrencyCodeType__LSL = 'V',
	ns3__CurrencyCodeType__LRD = 'W',
	ns3__CurrencyCodeType__LYD = 'X',
	ns3__CurrencyCodeType__CHF = 'Y',
	ns3__CurrencyCodeType__LTL = 'Z',
	ns3__CurrencyCodeType__MOP = 91,
	ns3__CurrencyCodeType__MKD = 92,
	ns3__CurrencyCodeType__MGF = 93,
	ns3__CurrencyCodeType__MWK = 94,
	ns3__CurrencyCodeType__MYR = 95,
	ns3__CurrencyCodeType__MVR = 96,
	ns3__CurrencyCodeType__MTL = 'a',
	ns3__CurrencyCodeType__EUR = 'b',
	ns3__CurrencyCodeType__MRO = 'c',
	ns3__CurrencyCodeType__MUR = 'd',
	ns3__CurrencyCodeType__MXN = 'e',
	ns3__CurrencyCodeType__MXV = 'f',
	ns3__CurrencyCodeType__MDL = 'g',
	ns3__CurrencyCodeType__MNT = 'h',
	ns3__CurrencyCodeType__XCD = 'i',
	ns3__CurrencyCodeType__MZM = 'j',
	ns3__CurrencyCodeType__MMK = 'k',
	ns3__CurrencyCodeType__ZAR = 'l',
	ns3__CurrencyCodeType__NAD = 'm',
	ns3__CurrencyCodeType__NPR = 'n',
	ns3__CurrencyCodeType__ANG = 'o',
	ns3__CurrencyCodeType__XPF = 'p',
	ns3__CurrencyCodeType__NZD = 'q',
	ns3__CurrencyCodeType__NIO = 'r',
	ns3__CurrencyCodeType__NGN = 's',
	ns3__CurrencyCodeType__NOK = 't',
	ns3__CurrencyCodeType__OMR = 'u',
	ns3__CurrencyCodeType__PKR = 'v',
	ns3__CurrencyCodeType__PAB = 'w',
	ns3__CurrencyCodeType__PGK = 'x',
	ns3__CurrencyCodeType__PYG = 'y',
	ns3__CurrencyCodeType__PEN = 'z',
	ns3__CurrencyCodeType__PHP = 123,
	ns3__CurrencyCodeType__PLN = 124,
	ns3__CurrencyCodeType__USD = 125,
	ns3__CurrencyCodeType__QAR = 126,
	ns3__CurrencyCodeType__ROL = 127,
	ns3__CurrencyCodeType__RUB = 128,
	ns3__CurrencyCodeType__RUR = 129,
	ns3__CurrencyCodeType__RWF = 130,
	ns3__CurrencyCodeType__SHP = 131,
	ns3__CurrencyCodeType__WST = 132,
	ns3__CurrencyCodeType__STD = 133,
	ns3__CurrencyCodeType__SAR = 134,
	ns3__CurrencyCodeType__SCR = 135,
	ns3__CurrencyCodeType__SLL = 136,
	ns3__CurrencyCodeType__SGD = 137,
	ns3__CurrencyCodeType__SKK = 138,
	ns3__CurrencyCodeType__SIT = 139,
	ns3__CurrencyCodeType__SBD = 140,
	ns3__CurrencyCodeType__SOS = 141,
	ns3__CurrencyCodeType__LKR = 142,
	ns3__CurrencyCodeType__SDD = 143,
	ns3__CurrencyCodeType__SRG = 144,
	ns3__CurrencyCodeType__SZL = 145,
	ns3__CurrencyCodeType__SEK = 146,
	ns3__CurrencyCodeType__SYP = 147,
	ns3__CurrencyCodeType__TWD = 148,
	ns3__CurrencyCodeType__TJS = 149,
	ns3__CurrencyCodeType__TZS = 150,
	ns3__CurrencyCodeType__THB = 151,
	ns3__CurrencyCodeType__XOF = 152,
	ns3__CurrencyCodeType__TOP = 153,
	ns3__CurrencyCodeType__TTD = 154,
	ns3__CurrencyCodeType__TND = 155,
	ns3__CurrencyCodeType__TRY = 156,
	ns3__CurrencyCodeType__TMM = 157,
	ns3__CurrencyCodeType__UGX = 158,
	ns3__CurrencyCodeType__UAH = 159,
	ns3__CurrencyCodeType__AED = 160,
	ns3__CurrencyCodeType__GBP = 161,
	ns3__CurrencyCodeType__USS = 162,
	ns3__CurrencyCodeType__USN = 163,
	ns3__CurrencyCodeType__UYU = 164,
	ns3__CurrencyCodeType__UZS = 165,
	ns3__CurrencyCodeType__VUV = 166,
	ns3__CurrencyCodeType__VEB = 167,
	ns3__CurrencyCodeType__VND = 168,
	ns3__CurrencyCodeType__MAD = 169,
	ns3__CurrencyCodeType__YER = 170,
	ns3__CurrencyCodeType__YUM = 171,
	ns3__CurrencyCodeType__ZMK = 172,
	ns3__CurrencyCodeType__ZWD = 173,
	ns3__CurrencyCodeType__CustomCode = 174
};
#endif

/* paypal.h:2254 */
#ifndef SOAP_TYPE_ns3__DepositTypeCodeType
#define SOAP_TYPE_ns3__DepositTypeCodeType (407)
/* ns3:DepositTypeCodeType */
enum ns3__DepositTypeCodeType {
	ns3__DepositTypeCodeType__None = 0,
	ns3__DepositTypeCodeType__OtherMethod = 1,
	ns3__DepositTypeCodeType__FastDeposit = 2,
	ns3__DepositTypeCodeType__CustomCode = 3
};
#endif

/* paypal.h:2280 */
#ifndef SOAP_TYPE_ns3__DetailLevelCodeType
#define SOAP_TYPE_ns3__DetailLevelCodeType (408)
/* ns3:DetailLevelCodeType */
enum ns3__DetailLevelCodeType {
	ns3__DetailLevelCodeType__ReturnAll = 0,
	ns3__DetailLevelCodeType__ItemReturnDescription = 1,
	ns3__DetailLevelCodeType__ItemReturnAttributes = 2
};
#endif

/* paypal.h:2302 */
#ifndef SOAP_TYPE_ns3__IncentiveSiteAppliedOnType
#define SOAP_TYPE_ns3__IncentiveSiteAppliedOnType (409)
/* ns3:IncentiveSiteAppliedOnType */
enum ns3__IncentiveSiteAppliedOnType {
	ns3__IncentiveSiteAppliedOnType__INCENTIVE_SITE_APPLIED_ON_UNKNOWN = 0,
	ns3__IncentiveSiteAppliedOnType__INCENTIVE_SITE_APPLIED_ON_MERCHANT = 1,
	ns3__IncentiveSiteAppliedOnType__INCENTIVE_SITE_APPLIED_ON_PAYPAL = 2
};
#endif

/* paypal.h:2315 */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedStatusType
#define SOAP_TYPE_ns3__IncentiveAppliedStatusType (410)
/* ns3:IncentiveAppliedStatusType */
enum ns3__IncentiveAppliedStatusType {
	ns3__IncentiveAppliedStatusType__INCENTIVE_APPLIED_STATUS_SUCCESS = 0,
	ns3__IncentiveAppliedStatusType__INCENTIVE_APPLIED_STATUS_ERROR = 1
};
#endif

/* paypal.h:2336 */
#ifndef SOAP_TYPE_ns3__PaymentReasonType
#define SOAP_TYPE_ns3__PaymentReasonType (412)
/* ns3:PaymentReasonType */
enum ns3__PaymentReasonType {
	ns3__PaymentReasonType__None = 0,
	ns3__PaymentReasonType__Refund = 1,
	ns3__PaymentReasonType__ReturnShipment = 2
};
#endif

/* paypal.h:2358 */
#ifndef SOAP_TYPE_ns3__EscrowCodeType
#define SOAP_TYPE_ns3__EscrowCodeType (414)
/* ns3:EscrowCodeType */
enum ns3__EscrowCodeType {
	ns3__EscrowCodeType__ByBuyer = 0,
	ns3__EscrowCodeType__BySeller = 1,
	ns3__EscrowCodeType__None = 2,
	ns3__EscrowCodeType__CustomCode = 3
};
#endif

/* paypal.h:2384 */
#ifndef SOAP_TYPE_ns3__FeedbackRatingStarCodeType
#define SOAP_TYPE_ns3__FeedbackRatingStarCodeType (415)
/* ns3:FeedbackRatingStarCodeType */
enum ns3__FeedbackRatingStarCodeType {
	ns3__FeedbackRatingStarCodeType__None = 0,
	ns3__FeedbackRatingStarCodeType__Yellow = 1,
	ns3__FeedbackRatingStarCodeType__Turquoise = 2,
	ns3__FeedbackRatingStarCodeType__Purple = 3,
	ns3__FeedbackRatingStarCodeType__Red = 4,
	ns3__FeedbackRatingStarCodeType__Green = 5,
	ns3__FeedbackRatingStarCodeType__YellowShooting = 6,
	ns3__FeedbackRatingStarCodeType__TurquoiseShooting = 7,
	ns3__FeedbackRatingStarCodeType__PurpleShooting = 8,
	ns3__FeedbackRatingStarCodeType__RedShooting = 9,
	ns3__FeedbackRatingStarCodeType__Blue = 10,
	ns3__FeedbackRatingStarCodeType__CustomCode = 11
};
#endif

/* paypal.h:2443 */
#ifndef SOAP_TYPE_ns3__GalleryTypeCodeType
#define SOAP_TYPE_ns3__GalleryTypeCodeType (416)
/* ns3:GalleryTypeCodeType */
enum ns3__GalleryTypeCodeType {
	ns3__GalleryTypeCodeType__Featured = 0,
	ns3__GalleryTypeCodeType__Gallery = 1,
	ns3__GalleryTypeCodeType__CustomCode = 2
};
#endif

/* paypal.h:2465 */
#ifndef SOAP_TYPE_ns3__GeneralPaymentMethodCodeType
#define SOAP_TYPE_ns3__GeneralPaymentMethodCodeType (417)
/* ns3:GeneralPaymentMethodCodeType */
enum ns3__GeneralPaymentMethodCodeType {
	ns3__GeneralPaymentMethodCodeType__Other = 0,
	ns3__GeneralPaymentMethodCodeType__Echeck = 1,
	ns3__GeneralPaymentMethodCodeType__ACH = 2,
	ns3__GeneralPaymentMethodCodeType__Creditcard = 3,
	ns3__GeneralPaymentMethodCodeType__PayPalBalance = 4,
	ns3__GeneralPaymentMethodCodeType__CustomCode = 5
};
#endif

/* paypal.h:2501 */
#ifndef SOAP_TYPE_ns3__GiftServicesCodeType
#define SOAP_TYPE_ns3__GiftServicesCodeType (418)
/* ns3:GiftServicesCodeType */
enum ns3__GiftServicesCodeType {
	ns3__GiftServicesCodeType__GiftExpressShipping = 0,
	ns3__GiftServicesCodeType__GiftShipToRecipient = 1,
	ns3__GiftServicesCodeType__GiftWrap = 2,
	ns3__GiftServicesCodeType__CustomCode = 3
};
#endif

/* paypal.h:2528 */
#ifndef SOAP_TYPE_ns3__HitCounterCodeType
#define SOAP_TYPE_ns3__HitCounterCodeType (419)
/* ns3:HitCounterCodeType */
enum ns3__HitCounterCodeType {
	ns3__HitCounterCodeType__NoHitCounter = 0,
	ns3__HitCounterCodeType__HonestyStyle = 1,
	ns3__HitCounterCodeType__GreenLED = 2,
	ns3__HitCounterCodeType__Hidden = 3,
	ns3__HitCounterCodeType__CustomCode = 4
};
#endif

/* paypal.h:2560 */
#ifndef SOAP_TYPE_ns3__InsuranceOptionCodeType
#define SOAP_TYPE_ns3__InsuranceOptionCodeType (420)
/* ns3:InsuranceOptionCodeType */
enum ns3__InsuranceOptionCodeType {
	ns3__InsuranceOptionCodeType__Optional = 0,
	ns3__InsuranceOptionCodeType__Required = 1,
	ns3__InsuranceOptionCodeType__NotOffered = 2,
	ns3__InsuranceOptionCodeType__IncludedInShippingHandling = 3,
	ns3__InsuranceOptionCodeType__CustomCode = 4
};
#endif

/* paypal.h:2591 */
#ifndef SOAP_TYPE_ns3__ListingDurationCodeType
#define SOAP_TYPE_ns3__ListingDurationCodeType (421)
/* ns3:ListingDurationCodeType */
enum ns3__ListingDurationCodeType {
	ns3__ListingDurationCodeType__Days_USCORE1 = 0,
	ns3__ListingDurationCodeType__Days_USCORE3 = 1,
	ns3__ListingDurationCodeType__Days_USCORE5 = 2,
	ns3__ListingDurationCodeType__Days_USCORE7 = 3,
	ns3__ListingDurationCodeType__Days_USCORE10 = 4,
	ns3__ListingDurationCodeType__Days_USCORE30 = 5,
	ns3__ListingDurationCodeType__Days_USCORE60 = 6,
	ns3__ListingDurationCodeType__Days_USCORE90 = 7,
	ns3__ListingDurationCodeType__Days_USCORE120 = 8,
	ns3__ListingDurationCodeType__GTC = 9,
	ns3__ListingDurationCodeType__CustomCode = 10
};
#endif

/* paypal.h:2646 */
#ifndef SOAP_TYPE_ns3__ListingEnhancementsCodeType
#define SOAP_TYPE_ns3__ListingEnhancementsCodeType (422)
/* ns3:ListingEnhancementsCodeType */
enum ns3__ListingEnhancementsCodeType {
	ns3__ListingEnhancementsCodeType__Border = 0,
	ns3__ListingEnhancementsCodeType__BoldTitle = 1,
	ns3__ListingEnhancementsCodeType__Featured = 2,
	ns3__ListingEnhancementsCodeType__Highlight = 3,
	ns3__ListingEnhancementsCodeType__HomePageFeatured = 4,
	ns3__ListingEnhancementsCodeType__CustomCode = 5
};
#endif

/* paypal.h:2681 */
#ifndef SOAP_TYPE_ns3__ListingTypeCodeType
#define SOAP_TYPE_ns3__ListingTypeCodeType (423)
/* ns3:ListingTypeCodeType */
enum ns3__ListingTypeCodeType {
	ns3__ListingTypeCodeType__Unknown = 0,
	ns3__ListingTypeCodeType__Chinese = 1,
	ns3__ListingTypeCodeType__Dutch = 2,
	ns3__ListingTypeCodeType__Live = 3,
	ns3__ListingTypeCodeType__AdType = 4,
	ns3__ListingTypeCodeType__StoresFixedPrice = 5,
	ns3__ListingTypeCodeType__PersonalOffer = 6,
	ns3__ListingTypeCodeType__FixedPriceItem = 7,
	ns3__ListingTypeCodeType__CustomCode = 8
};
#endif

/* paypal.h:2727 */
#ifndef SOAP_TYPE_ns3__MerchandizingPrefCodeType
#define SOAP_TYPE_ns3__MerchandizingPrefCodeType (424)
/* ns3:MerchandizingPrefCodeType */
enum ns3__MerchandizingPrefCodeType {
	ns3__MerchandizingPrefCodeType__OptIn = 0,
	ns3__MerchandizingPrefCodeType__OptOut = 1,
	ns3__MerchandizingPrefCodeType__CustomCode = 2
};
#endif

/* paypal.h:2751 */
#ifndef SOAP_TYPE_ns3__ModifyCodeType
#define SOAP_TYPE_ns3__ModifyCodeType (425)
/* ns3:ModifyCodeType */
enum ns3__ModifyCodeType {
	ns3__ModifyCodeType__Dropped = 0,
	ns3__ModifyCodeType__Modify = 1,
	ns3__ModifyCodeType__CustomCode = 2
};
#endif

/* paypal.h:2774 */
#ifndef SOAP_TYPE_ns3__PhotoDisplayCodeType
#define SOAP_TYPE_ns3__PhotoDisplayCodeType (426)
/* ns3:PhotoDisplayCodeType */
enum ns3__PhotoDisplayCodeType {
	ns3__PhotoDisplayCodeType__None = 0,
	ns3__PhotoDisplayCodeType__SlideShow = 1,
	ns3__PhotoDisplayCodeType__SuperSize = 2,
	ns3__PhotoDisplayCodeType__PicturePack = 3,
	ns3__PhotoDisplayCodeType__CustomCode = 4
};
#endif

/* paypal.h:2804 */
#ifndef SOAP_TYPE_ns3__PromotionItemPriceTypeCodeType
#define SOAP_TYPE_ns3__PromotionItemPriceTypeCodeType (427)
/* ns3:PromotionItemPriceTypeCodeType */
enum ns3__PromotionItemPriceTypeCodeType {
	ns3__PromotionItemPriceTypeCodeType__AuctionPrice = 0,
	ns3__PromotionItemPriceTypeCodeType__BuyItNowPrice = 1,
	ns3__PromotionItemPriceTypeCodeType__CustomCode = 2
};
#endif

/* paypal.h:2826 */
#ifndef SOAP_TYPE_ns3__PromotionItemSelectionCodeType
#define SOAP_TYPE_ns3__PromotionItemSelectionCodeType (428)
/* ns3:PromotionItemSelectionCodeType */
enum ns3__PromotionItemSelectionCodeType {
	ns3__PromotionItemSelectionCodeType__Manual = 0,
	ns3__PromotionItemSelectionCodeType__Automatic = 1,
	ns3__PromotionItemSelectionCodeType__CustomCode = 2
};
#endif

/* paypal.h:2848 */
#ifndef SOAP_TYPE_ns3__PromotionMethodCodeType
#define SOAP_TYPE_ns3__PromotionMethodCodeType (429)
/* ns3:PromotionMethodCodeType */
enum ns3__PromotionMethodCodeType {
	ns3__PromotionMethodCodeType__CrossSell = 0,
	ns3__PromotionMethodCodeType__UpSell = 1,
	ns3__PromotionMethodCodeType__CustomCode = 2
};
#endif

/* paypal.h:2870 */
#ifndef SOAP_TYPE_ns3__PromotionSchemeCodeType
#define SOAP_TYPE_ns3__PromotionSchemeCodeType (430)
/* ns3:PromotionSchemeCodeType */
enum ns3__PromotionSchemeCodeType {
	ns3__PromotionSchemeCodeType__ItemToItem = 0,
	ns3__PromotionSchemeCodeType__ItemToStoreCat = 1,
	ns3__PromotionSchemeCodeType__StoreToStoreCat = 2,
	ns3__PromotionSchemeCodeType__CustomCode = 3
};
#endif

/* paypal.h:2896 */
#ifndef SOAP_TYPE_ns3__PurchasePurposeTypeCodeType
#define SOAP_TYPE_ns3__PurchasePurposeTypeCodeType (431)
/* ns3:PurchasePurposeTypeCodeType */
enum ns3__PurchasePurposeTypeCodeType {
	ns3__PurchasePurposeTypeCodeType__Other = 0,
	ns3__PurchasePurposeTypeCodeType__BuyNowItem = 1,
	ns3__PurchasePurposeTypeCodeType__ShoppingCart = 2,
	ns3__PurchasePurposeTypeCodeType__AuctionItem = 3,
	ns3__PurchasePurposeTypeCodeType__GiftCertificates = 4,
	ns3__PurchasePurposeTypeCodeType__Subscription = 5,
	ns3__PurchasePurposeTypeCodeType__Donation = 6,
	ns3__PurchasePurposeTypeCodeType__eBayBilling = 7,
	ns3__PurchasePurposeTypeCodeType__CustomCode = 8
};
#endif

/* paypal.h:2935 */
#ifndef SOAP_TYPE_ns3__SellerLevelCodeType
#define SOAP_TYPE_ns3__SellerLevelCodeType (432)
/* ns3:SellerLevelCodeType */
enum ns3__SellerLevelCodeType {
	ns3__SellerLevelCodeType__Bronze = 0,
	ns3__SellerLevelCodeType__Silver = 1,
	ns3__SellerLevelCodeType__Gold = 2,
	ns3__SellerLevelCodeType__Platinum = 3,
	ns3__SellerLevelCodeType__Titanium = 4,
	ns3__SellerLevelCodeType__None = 5,
	ns3__SellerLevelCodeType__CustomCode = 6
};
#endif

/* paypal.h:2974 */
#ifndef SOAP_TYPE_ns3__SellerPaymentMethodCodeType
#define SOAP_TYPE_ns3__SellerPaymentMethodCodeType (433)
/* ns3:SellerPaymentMethodCodeType */
enum ns3__SellerPaymentMethodCodeType {
	ns3__SellerPaymentMethodCodeType__Other = 0,
	ns3__SellerPaymentMethodCodeType__Amex = 1,
	ns3__SellerPaymentMethodCodeType__Visa = 2,
	ns3__SellerPaymentMethodCodeType__Mastercard = 3,
	ns3__SellerPaymentMethodCodeType__Discover = 4,
	ns3__SellerPaymentMethodCodeType__JCB = 5,
	ns3__SellerPaymentMethodCodeType__Diners = 6,
	ns3__SellerPaymentMethodCodeType__CustomCode = 7
};
#endif

/* paypal.h:3019 */
#ifndef SOAP_TYPE_ns3__SeverityCodeType
#define SOAP_TYPE_ns3__SeverityCodeType (434)
/* ns3:SeverityCodeType */
enum ns3__SeverityCodeType {
	ns3__SeverityCodeType__Warning = 0,
	ns3__SeverityCodeType__Error = 1,
	ns3__SeverityCodeType__PartialSuccess = 2,
	ns3__SeverityCodeType__CustomCode = 3
};
#endif

/* paypal.h:3047 */
#ifndef SOAP_TYPE_ns3__ShippingOptionCodeType
#define SOAP_TYPE_ns3__ShippingOptionCodeType (435)
/* ns3:ShippingOptionCodeType */
enum ns3__ShippingOptionCodeType {
	ns3__ShippingOptionCodeType__SiteOnly = 0,
	ns3__ShippingOptionCodeType__WorldWide = 1,
	ns3__ShippingOptionCodeType__SitePlusRegions = 2,
	ns3__ShippingOptionCodeType__WillNotShip = 3,
	ns3__ShippingOptionCodeType__CustomCode = 4
};
#endif

/* paypal.h:3078 */
#ifndef SOAP_TYPE_ns3__ShippingPackageCodeType
#define SOAP_TYPE_ns3__ShippingPackageCodeType (436)
/* ns3:ShippingPackageCodeType */
enum ns3__ShippingPackageCodeType {
	ns3__ShippingPackageCodeType__None = 0,
	ns3__ShippingPackageCodeType__Letter = 1,
	ns3__ShippingPackageCodeType__LargeEnvelope = 2,
	ns3__ShippingPackageCodeType__USPSLargePack = 3,
	ns3__ShippingPackageCodeType__VeryLargePack = 4,
	ns3__ShippingPackageCodeType__UPSLetter = 5,
	ns3__ShippingPackageCodeType__USPSFlatRateEnvelope = 6,
	ns3__ShippingPackageCodeType__PackageThickEnvelope = 7,
	ns3__ShippingPackageCodeType__CustomCode = 8
};
#endif

/* paypal.h:3125 */
#ifndef SOAP_TYPE_ns3__ShippingRatesTypeCodeType
#define SOAP_TYPE_ns3__ShippingRatesTypeCodeType (437)
/* ns3:ShippingRatesTypeCodeType */
enum ns3__ShippingRatesTypeCodeType {
	ns3__ShippingRatesTypeCodeType__Flat = 0,
	ns3__ShippingRatesTypeCodeType__Calculated = 1,
	ns3__ShippingRatesTypeCodeType__CustomCode = 2
};
#endif

/* paypal.h:3148 */
#ifndef SOAP_TYPE_ns3__ShippingRegionCodeType
#define SOAP_TYPE_ns3__ShippingRegionCodeType (438)
/* ns3:ShippingRegionCodeType */
enum ns3__ShippingRegionCodeType {
	ns3__ShippingRegionCodeType__Africa = 0,
	ns3__ShippingRegionCodeType__Asia = 1,
	ns3__ShippingRegionCodeType__Caribbean = 2,
	ns3__ShippingRegionCodeType__Europe = 3,
	ns3__ShippingRegionCodeType__LatinAmerica = 4,
	ns3__ShippingRegionCodeType__MiddleEast = 5,
	ns3__ShippingRegionCodeType__NorthAmerica = 6,
	ns3__ShippingRegionCodeType__Oceania = 7,
	ns3__ShippingRegionCodeType__SouthAmerica = 8,
	ns3__ShippingRegionCodeType__CustomCode = 9
};
#endif

/* paypal.h:3200 */
#ifndef SOAP_TYPE_ns3__ShippingServiceCodeType
#define SOAP_TYPE_ns3__ShippingServiceCodeType (439)
/* ns3:ShippingServiceCodeType */
enum ns3__ShippingServiceCodeType {
	ns3__ShippingServiceCodeType__UPSGround = 0,
	ns3__ShippingServiceCodeType__UPS3rdDay = 1,
	ns3__ShippingServiceCodeType__UPS2ndDay = 2,
	ns3__ShippingServiceCodeType__UPSNextDay = 3,
	ns3__ShippingServiceCodeType__USPSPriority = 4,
	ns3__ShippingServiceCodeType__USPSParcel = 5,
	ns3__ShippingServiceCodeType__USPSMedia = 6,
	ns3__ShippingServiceCodeType__USPSFirstClass = 7,
	ns3__ShippingServiceCodeType__ShippingMethodStandard = 8,
	ns3__ShippingServiceCodeType__ShippingMethodExpress = 9,
	ns3__ShippingServiceCodeType__ShippingMethodNextDay = 10,
	ns3__ShippingServiceCodeType__USPSExpressMail = 11,
	ns3__ShippingServiceCodeType__USPSGround = 12,
	ns3__ShippingServiceCodeType__Download = 13,
	ns3__ShippingServiceCodeType__WillCall_USCOREOr_USCOREPickup = 14,
	ns3__ShippingServiceCodeType__CustomCode = 15
};
#endif

/* paypal.h:3276 */
#ifndef SOAP_TYPE_ns3__ShippingTermsCodeType
#define SOAP_TYPE_ns3__ShippingTermsCodeType (440)
/* ns3:ShippingTermsCodeType */
enum ns3__ShippingTermsCodeType {
	ns3__ShippingTermsCodeType__SellerPays = 0,
	ns3__ShippingTermsCodeType__BuyerPays = 1,
	ns3__ShippingTermsCodeType__CustomCode = 2
};
#endif

/* paypal.h:3299 */
#ifndef SOAP_TYPE_ns3__SiteCodeType
#define SOAP_TYPE_ns3__SiteCodeType (441)
/* ns3:SiteCodeType */
enum ns3__SiteCodeType {
	ns3__SiteCodeType__US = 0,
	ns3__SiteCodeType__Canada = 1,
	ns3__SiteCodeType__UK = 2,
	ns3__SiteCodeType__Australia = 3,
	ns3__SiteCodeType__Austria = 4,
	ns3__SiteCodeType__Belgium_USCOREFrench = 5,
	ns3__SiteCodeType__France = 6,
	ns3__SiteCodeType__Germany = 7,
	ns3__SiteCodeType__Italy = 8,
	ns3__SiteCodeType__Belgium_USCOREDutch = 9,
	ns3__SiteCodeType__Netherlands = 10,
	ns3__SiteCodeType__Spain = 11,
	ns3__SiteCodeType__Switzerland = 12,
	ns3__SiteCodeType__Taiwan = 13,
	ns3__SiteCodeType__eBayMotors = 14,
	ns3__SiteCodeType__HongKong = 15,
	ns3__SiteCodeType__Singapore = 16,
	ns3__SiteCodeType__CustomCode = 17
};
#endif

/* paypal.h:3384 */
#ifndef SOAP_TYPE_ns3__StoreVisibilityStatusType
#define SOAP_TYPE_ns3__StoreVisibilityStatusType (442)
/* ns3:StoreVisibilityStatusType */
enum ns3__StoreVisibilityStatusType {
	ns3__StoreVisibilityStatusType__DISABLE = 0,
	ns3__StoreVisibilityStatusType__ENABLE = 1
};
#endif

/* paypal.h:3396 */
#ifndef SOAP_TYPE_ns3__UnitCodeType
#define SOAP_TYPE_ns3__UnitCodeType (443)
/* ns3:UnitCodeType */
enum ns3__UnitCodeType {
	ns3__UnitCodeType__kg = 0,
	ns3__UnitCodeType__lbs = 1,
	ns3__UnitCodeType__oz = 2,
	ns3__UnitCodeType__cm = 3,
	ns3__UnitCodeType__inches = 4,
	ns3__UnitCodeType__ft = 5,
	ns3__UnitCodeType__CustomCode = 6
};
#endif

/* paypal.h:3434 */
#ifndef SOAP_TYPE_ns3__UserStatusCodeType
#define SOAP_TYPE_ns3__UserStatusCodeType (444)
/* ns3:UserStatusCodeType */
enum ns3__UserStatusCodeType {
	ns3__UserStatusCodeType__Unknown = 0,
	ns3__UserStatusCodeType__Suspended = 1,
	ns3__UserStatusCodeType__Confirmed = 2,
	ns3__UserStatusCodeType__Unconfirmed = 3,
	ns3__UserStatusCodeType__Ghost = 4,
	ns3__UserStatusCodeType__InMaintenance = 5,
	ns3__UserStatusCodeType__Deleted = 6,
	ns3__UserStatusCodeType__CreditCardVerify = 7,
	ns3__UserStatusCodeType__AccountOnHold = 8,
	ns3__UserStatusCodeType__Merged = 9,
	ns3__UserStatusCodeType__RegistrationCodeMailOut = 10,
	ns3__UserStatusCodeType__TermPending = 11,
	ns3__UserStatusCodeType__UnconfirmedHalfOptIn = 12,
	ns3__UserStatusCodeType__CreditCardVerifyHalfOptIn = 13,
	ns3__UserStatusCodeType__UnconfirmedPassport = 14,
	ns3__UserStatusCodeType__CreditCardVerifyPassport = 15,
	ns3__UserStatusCodeType__UnconfirmedExpress = 16,
	ns3__UserStatusCodeType__CustomCode = 17
};
#endif

/* paypal.h:3516 */
#ifndef SOAP_TYPE_ns3__VATStatusCodeType
#define SOAP_TYPE_ns3__VATStatusCodeType (445)
/* ns3:VATStatusCodeType */
enum ns3__VATStatusCodeType {
	ns3__VATStatusCodeType__NoVATTax = 0,
	ns3__VATStatusCodeType__VATTax = 1,
	ns3__VATStatusCodeType__VATExempt = 2,
	ns3__VATStatusCodeType__CustomCode = 3
};
#endif

/* paypal.h:3543 */
#ifndef SOAP_TYPE_ns3__CreditCardTypeType
#define SOAP_TYPE_ns3__CreditCardTypeType (446)
/* ns3:CreditCardTypeType */
enum ns3__CreditCardTypeType {
	ns3__CreditCardTypeType__Visa = 0,
	ns3__CreditCardTypeType__MasterCard = 1,
	ns3__CreditCardTypeType__Discover = 2,
	ns3__CreditCardTypeType__Amex = 3,
	ns3__CreditCardTypeType__Switch = 4,
	ns3__CreditCardTypeType__Solo = 5,
	ns3__CreditCardTypeType__Maestro = 6
};
#endif

/* paypal.h:3609 */
#ifndef SOAP_TYPE_ns3__PaymentNotificationServiceCodeType
#define SOAP_TYPE_ns3__PaymentNotificationServiceCodeType (457)
/* ns3:PaymentNotificationServiceCodeType */
enum ns3__PaymentNotificationServiceCodeType {
	ns3__PaymentNotificationServiceCodeType__eBayCN = 0
};
#endif

/* paypal.h:3624 */
#ifndef SOAP_TYPE_ns3__BankIDCodeType
#define SOAP_TYPE_ns3__BankIDCodeType (459)
/* ns3:BankIDCodeType */
enum ns3__BankIDCodeType {
	ns3__BankIDCodeType__CMB = 0,
	ns3__BankIDCodeType__ICBC = 1,
	ns3__BankIDCodeType__CCB = 2,
	ns3__BankIDCodeType__ChinaPay = 3
};
#endif

/* paypal.h:3650 */
#ifndef SOAP_TYPE_ns3__RefundType
#define SOAP_TYPE_ns3__RefundType (461)
/* ns3:RefundType */
enum ns3__RefundType {
	ns3__RefundType__Other = 0,
	ns3__RefundType__Full = 1,
	ns3__RefundType__Partial = 2,
	ns3__RefundType__ExternalDispute = 3
};
#endif

/* paypal.h:3675 */
#ifndef SOAP_TYPE_ns3__UnitOfMeasure
#define SOAP_TYPE_ns3__UnitOfMeasure (462)
/* ns3:UnitOfMeasure */
enum ns3__UnitOfMeasure {
	ns3__UnitOfMeasure__EA = 0,
	ns3__UnitOfMeasure__Hours = 1,
	ns3__UnitOfMeasure__Days = 2,
	ns3__UnitOfMeasure__Seconds = 3,
	ns3__UnitOfMeasure__CrateOf12 = 4,
	ns3__UnitOfMeasure__6Pack = 5,
	ns3__UnitOfMeasure__GLI = 6,
	ns3__UnitOfMeasure__GLL = 7,
	ns3__UnitOfMeasure__LTR = 8,
	ns3__UnitOfMeasure__INH = 9,
	ns3__UnitOfMeasure__FOT = 10,
	ns3__UnitOfMeasure__MMT = 11,
	ns3__UnitOfMeasure__CMQ = 12,
	ns3__UnitOfMeasure__MTR = 13,
	ns3__UnitOfMeasure__MTK = 14,
	ns3__UnitOfMeasure__MTQ = 15,
	ns3__UnitOfMeasure__GRM = 16,
	ns3__UnitOfMeasure__KGM = 17,
	ns3__UnitOfMeasure__KG = 18,
	ns3__UnitOfMeasure__LBR = 19,
	ns3__UnitOfMeasure__ANN = 20,
	ns3__UnitOfMeasure__CEL = 21,
	ns3__UnitOfMeasure__FAH = 22,
	ns3__UnitOfMeasure__RESERVED = 23
};
#endif

/* paypal.h:3778 */
#ifndef SOAP_TYPE_ns3__RedeemedOfferType
#define SOAP_TYPE_ns3__RedeemedOfferType (463)
/* ns3:RedeemedOfferType */
enum ns3__RedeemedOfferType {
	ns3__RedeemedOfferType__MERCHANT_USCORECOUPON = 0,
	ns3__RedeemedOfferType__LOYALTY_USCORECARD = 1,
	ns3__RedeemedOfferType__MANUFACTURER_USCORECOUPON = 2,
	ns3__RedeemedOfferType__RESERVED = 3
};
#endif

/* paypal.h:3792 */
#ifndef SOAP_TYPE_ns3__APIType
#define SOAP_TYPE_ns3__APIType (464)
/* ns3:APIType */
enum ns3__APIType {
	ns3__APIType__CHECKOUT_USCOREAUTHORIZATION = 0,
	ns3__APIType__CHECKOUT_USCORESALE = 1,
	ns3__APIType__REFUND_USCORETRANSACTION = 2
};
#endif

/* paypal.h:3814 */
#ifndef SOAP_TYPE_ns3__IncentiveRequestCodeType
#define SOAP_TYPE_ns3__IncentiveRequestCodeType (465)
/* ns3:IncentiveRequestCodeType */
enum ns3__IncentiveRequestCodeType {
	ns3__IncentiveRequestCodeType__InCheckout = 0,
	ns3__IncentiveRequestCodeType__PreCheckout = 1
};
#endif

/* paypal.h:3826 */
#ifndef SOAP_TYPE_ns3__IncentiveRequestDetailLevelCodeType
#define SOAP_TYPE_ns3__IncentiveRequestDetailLevelCodeType (466)
/* ns3:IncentiveRequestDetailLevelCodeType */
enum ns3__IncentiveRequestDetailLevelCodeType {
	ns3__IncentiveRequestDetailLevelCodeType__Aggregated = 0,
	ns3__IncentiveRequestDetailLevelCodeType__Detail = 1
};
#endif

/* paypal.h:3838 */
#ifndef SOAP_TYPE_ns3__IncentiveTypeCodeType
#define SOAP_TYPE_ns3__IncentiveTypeCodeType (467)
/* ns3:IncentiveTypeCodeType */
enum ns3__IncentiveTypeCodeType {
	ns3__IncentiveTypeCodeType__Coupon = 0,
	ns3__IncentiveTypeCodeType__eBayGiftCertificate = 1,
	ns3__IncentiveTypeCodeType__eBayGiftCard = 2,
	ns3__IncentiveTypeCodeType__PayPalRewardVoucher = 3,
	ns3__IncentiveTypeCodeType__MerchantGiftCertificate = 4,
	ns3__IncentiveTypeCodeType__eBayRewardVoucher = 5
};
#endif

/* paypal.h:3854 */
#ifndef SOAP_TYPE_ns3__UserChannelCodeType
#define SOAP_TYPE_ns3__UserChannelCodeType (468)
/* ns3:UserChannelCodeType */
enum ns3__UserChannelCodeType {
	ns3__UserChannelCodeType__WEB = 0,
	ns3__UserChannelCodeType__MOBILE = 1,
	ns3__UserChannelCodeType__POS = 2,
	ns3__UserChannelCodeType__KIOSK = 3,
	ns3__UserChannelCodeType__IHSTB = 4,
	ns3__UserChannelCodeType__IVR = 5,
	ns3__UserChannelCodeType__ADMIN = 6,
	ns3__UserChannelCodeType__CSOPS = 7
};
#endif

/* paypal.h:3872 */
#ifndef SOAP_TYPE_ns3__PaymentTransactionCodeType
#define SOAP_TYPE_ns3__PaymentTransactionCodeType (469)
/* ns3:PaymentTransactionCodeType */
enum ns3__PaymentTransactionCodeType {
	ns3__PaymentTransactionCodeType__none = 0,
	ns3__PaymentTransactionCodeType__web_accept = 1,
	ns3__PaymentTransactionCodeType__cart = 2,
	ns3__PaymentTransactionCodeType__send_money = 3,
	ns3__PaymentTransactionCodeType__subscr_failed = 4,
	ns3__PaymentTransactionCodeType__subscr_cancel = 5,
	ns3__PaymentTransactionCodeType__subscr_payment = 6,
	ns3__PaymentTransactionCodeType__subscr_signup = 7,
	ns3__PaymentTransactionCodeType__subscr_eot = 8,
	ns3__PaymentTransactionCodeType__subscr_modify = 9,
	ns3__PaymentTransactionCodeType__mercht_pmt = 10,
	ns3__PaymentTransactionCodeType__mass_pay = 11,
	ns3__PaymentTransactionCodeType__virtual_terminal = 12,
	ns3__PaymentTransactionCodeType__integral_evolution = 13,
	ns3__PaymentTransactionCodeType__express_checkout = 14,
	ns3__PaymentTransactionCodeType__pro_hosted = 15,
	ns3__PaymentTransactionCodeType__pro_api = 16,
	ns3__PaymentTransactionCodeType__credit = 17
};
#endif

/* paypal.h:3900 */
#ifndef SOAP_TYPE_ns3__PaymentStatusCodeType
#define SOAP_TYPE_ns3__PaymentStatusCodeType (470)
/* ns3:PaymentStatusCodeType */
enum ns3__PaymentStatusCodeType {
	ns3__PaymentStatusCodeType__None = 0,
	ns3__PaymentStatusCodeType__Completed = 1,
	ns3__PaymentStatusCodeType__Failed = 2,
	ns3__PaymentStatusCodeType__Pending = 3,
	ns3__PaymentStatusCodeType__Denied = 4,
	ns3__PaymentStatusCodeType__Refunded = 5,
	ns3__PaymentStatusCodeType__Reversed = 6,
	ns3__PaymentStatusCodeType__Canceled_Reversal = 7,
	ns3__PaymentStatusCodeType__Processed = 8,
	ns3__PaymentStatusCodeType__Partially_Refunded = 9,
	ns3__PaymentStatusCodeType__Voided = 10,
	ns3__PaymentStatusCodeType__Expired = 11,
	ns3__PaymentStatusCodeType__In_Progress = 12,
	ns3__PaymentStatusCodeType__Created = 13,
	ns3__PaymentStatusCodeType__Completed_Funds_Held = 14,
	ns3__PaymentStatusCodeType__Instant = 15,
	ns3__PaymentStatusCodeType__Delayed = 16
};
#endif

/* paypal.h:3927 */
#ifndef SOAP_TYPE_ns3__AddressStatusCodeType
#define SOAP_TYPE_ns3__AddressStatusCodeType (471)
/* ns3:AddressStatusCodeType */
enum ns3__AddressStatusCodeType {
	ns3__AddressStatusCodeType__None = 0,
	ns3__AddressStatusCodeType__Confirmed = 1,
	ns3__AddressStatusCodeType__Unconfirmed = 2
};
#endif

/* paypal.h:3940 */
#ifndef SOAP_TYPE_ns3__AddressNormalizationStatusCodeType
#define SOAP_TYPE_ns3__AddressNormalizationStatusCodeType (472)
/* ns3:AddressNormalizationStatusCodeType */
enum ns3__AddressNormalizationStatusCodeType {
	ns3__AddressNormalizationStatusCodeType__None = 0,
	ns3__AddressNormalizationStatusCodeType__Normalized = 1,
	ns3__AddressNormalizationStatusCodeType__Unnormalized = 2,
	ns3__AddressNormalizationStatusCodeType__UserPreferred = 3
};
#endif

/* paypal.h:3954 */
#ifndef SOAP_TYPE_ns3__PaymentActionCodeType
#define SOAP_TYPE_ns3__PaymentActionCodeType (473)
/* ns3:PaymentActionCodeType */
enum ns3__PaymentActionCodeType {
	ns3__PaymentActionCodeType__None = 0,
	ns3__PaymentActionCodeType__Authorization = 1,
	ns3__PaymentActionCodeType__Sale = 2,
	ns3__PaymentActionCodeType__Order = 3
};
#endif

/* paypal.h:3968 */
#ifndef SOAP_TYPE_ns3__FMFPendingTransactionActionType
#define SOAP_TYPE_ns3__FMFPendingTransactionActionType (474)
/* ns3:FMFPendingTransactionActionType */
enum ns3__FMFPendingTransactionActionType {
	ns3__FMFPendingTransactionActionType__Accept = 0,
	ns3__FMFPendingTransactionActionType__Deny = 1
};
#endif

/* paypal.h:3981 */
#ifndef SOAP_TYPE_ns3__ChannelType
#define SOAP_TYPE_ns3__ChannelType (475)
/* ns3:ChannelType */
enum ns3__ChannelType {
	ns3__ChannelType__Merchant = 0,
	ns3__ChannelType__eBayItem = 1
};
#endif

/* paypal.h:3994 */
#ifndef SOAP_TYPE_ns3__TotalType
#define SOAP_TYPE_ns3__TotalType (476)
/* ns3:TotalType */
enum ns3__TotalType {
	ns3__TotalType__Total = 0,
	ns3__TotalType__EstimatedTotal = 1
};
#endif

/* paypal.h:4006 */
#ifndef SOAP_TYPE_ns3__SolutionTypeType
#define SOAP_TYPE_ns3__SolutionTypeType (477)
/* ns3:SolutionTypeType */
enum ns3__SolutionTypeType {
	ns3__SolutionTypeType__Mark = 0,
	ns3__SolutionTypeType__Sole = 1
};
#endif

/* paypal.h:4024 */
#ifndef SOAP_TYPE_ns3__AllowedPaymentMethodType
#define SOAP_TYPE_ns3__AllowedPaymentMethodType (478)
/* ns3:AllowedPaymentMethodType */
enum ns3__AllowedPaymentMethodType {
	ns3__AllowedPaymentMethodType__Default = 0,
	ns3__AllowedPaymentMethodType__InstantPaymentOnly = 1,
	ns3__AllowedPaymentMethodType__AnyFundingSource = 2,
	ns3__AllowedPaymentMethodType__InstantFundingSource = 3
};
#endif

/* paypal.h:4038 */
#ifndef SOAP_TYPE_ns3__LandingPageType
#define SOAP_TYPE_ns3__LandingPageType (479)
/* ns3:LandingPageType */
enum ns3__LandingPageType {
	ns3__LandingPageType__None = 0,
	ns3__LandingPageType__Login = 1,
	ns3__LandingPageType__Billing = 2
};
#endif

/* paypal.h:4050 */
#ifndef SOAP_TYPE_ns3__BillingCodeType
#define SOAP_TYPE_ns3__BillingCodeType (480)
/* ns3:BillingCodeType */
enum ns3__BillingCodeType {
	ns3__BillingCodeType__None = 0,
	ns3__BillingCodeType__MerchantInitiatedBilling = 1,
	ns3__BillingCodeType__RecurringPayments = 2,
	ns3__BillingCodeType__MerchantInitiatedBillingSingleAgreement = 3,
	ns3__BillingCodeType__ChannelInitiatedBilling = 4
};
#endif

/* paypal.h:4064 */
#ifndef SOAP_TYPE_ns3__ApprovalTypeType
#define SOAP_TYPE_ns3__ApprovalTypeType (481)
/* ns3:ApprovalTypeType */
enum ns3__ApprovalTypeType {
	ns3__ApprovalTypeType__BillingAgreement = 0,
	ns3__ApprovalTypeType__Profile = 1
};
#endif

/* paypal.h:4075 */
#ifndef SOAP_TYPE_ns3__ApprovalSubTypeType
#define SOAP_TYPE_ns3__ApprovalSubTypeType (482)
/* ns3:ApprovalSubTypeType */
enum ns3__ApprovalSubTypeType {
	ns3__ApprovalSubTypeType__None = 0,
	ns3__ApprovalSubTypeType__MerchantInitiatedBilling = 1,
	ns3__ApprovalSubTypeType__MerchantInitiatedBillingSingleAgreement = 2,
	ns3__ApprovalSubTypeType__ChannelInitiatedBilling = 3
};
#endif

/* paypal.h:4089 */
#ifndef SOAP_TYPE_ns3__PendingStatusCodeType
#define SOAP_TYPE_ns3__PendingStatusCodeType (483)
/* ns3:PendingStatusCodeType */
enum ns3__PendingStatusCodeType {
	ns3__PendingStatusCodeType__none = 0,
	ns3__PendingStatusCodeType__echeck = 1,
	ns3__PendingStatusCodeType__intl = 2,
	ns3__PendingStatusCodeType__verify = 3,
	ns3__PendingStatusCodeType__address = 4,
	ns3__PendingStatusCodeType__unilateral = 5,
	ns3__PendingStatusCodeType__other = 6,
	ns3__PendingStatusCodeType__upgrade = 7,
	ns3__PendingStatusCodeType__multi_currency = 8,
	ns3__PendingStatusCodeType__authorization = 9,
	ns3__PendingStatusCodeType__order = 10,
	ns3__PendingStatusCodeType__payment_review = 11,
	ns3__PendingStatusCodeType__regulatory_review = 12,
	ns3__PendingStatusCodeType__delayed_disbursement = 13
};
#endif

/* paypal.h:4113 */
#ifndef SOAP_TYPE_ns3__ReceiverInfoCodeType
#define SOAP_TYPE_ns3__ReceiverInfoCodeType (484)
/* ns3:ReceiverInfoCodeType */
enum ns3__ReceiverInfoCodeType {
	ns3__ReceiverInfoCodeType__EmailAddress = 0,
	ns3__ReceiverInfoCodeType__UserID = 1,
	ns3__ReceiverInfoCodeType__PhoneNumber = 2
};
#endif

/* paypal.h:4126 */
#ifndef SOAP_TYPE_ns3__ReversalReasonCodeType
#define SOAP_TYPE_ns3__ReversalReasonCodeType (485)
/* ns3:ReversalReasonCodeType */
enum ns3__ReversalReasonCodeType {
	ns3__ReversalReasonCodeType__none = 0,
	ns3__ReversalReasonCodeType__chargeback = 1,
	ns3__ReversalReasonCodeType__guarantee = 2,
	ns3__ReversalReasonCodeType__buyer_complaint = 3,
	ns3__ReversalReasonCodeType__refund = 4,
	ns3__ReversalReasonCodeType__other = 5
};
#endif

/* paypal.h:4143 */
#ifndef SOAP_TYPE_ns3__POSTransactionCodeType
#define SOAP_TYPE_ns3__POSTransactionCodeType (486)
/* ns3:POSTransactionCodeType */
enum ns3__POSTransactionCodeType {
	ns3__POSTransactionCodeType__F = 'F',
	ns3__POSTransactionCodeType__S = 'S'
};
#endif

/* paypal.h:4155 */
#ifndef SOAP_TYPE_ns3__PaymentCodeType
#define SOAP_TYPE_ns3__PaymentCodeType (487)
/* ns3:PaymentCodeType */
enum ns3__PaymentCodeType {
	ns3__PaymentCodeType__none = 0,
	ns3__PaymentCodeType__echeck = 1,
	ns3__PaymentCodeType__instant = 2
};
#endif

/* paypal.h:4173 */
#ifndef SOAP_TYPE_ns3__RefundSourceCodeType
#define SOAP_TYPE_ns3__RefundSourceCodeType (488)
/* ns3:RefundSourceCodeType */
enum ns3__RefundSourceCodeType {
	ns3__RefundSourceCodeType__any = 0,
	ns3__RefundSourceCodeType__default_ = 1,
	ns3__RefundSourceCodeType__instant = 2,
	ns3__RefundSourceCodeType__echeck = 3
};
#endif

/* paypal.h:4187 */
#ifndef SOAP_TYPE_ns3__PayPalUserStatusCodeType
#define SOAP_TYPE_ns3__PayPalUserStatusCodeType (489)
/* ns3:PayPalUserStatusCodeType */
enum ns3__PayPalUserStatusCodeType {
	ns3__PayPalUserStatusCodeType__verified = 0,
	ns3__PayPalUserStatusCodeType__unverified = 1
};
#endif

/* paypal.h:4199 */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentCodeType
#define SOAP_TYPE_ns3__MerchantPullPaymentCodeType (490)
/* ns3:MerchantPullPaymentCodeType */
enum ns3__MerchantPullPaymentCodeType {
	ns3__MerchantPullPaymentCodeType__Any = 0,
	ns3__MerchantPullPaymentCodeType__InstantOnly = 1,
	ns3__MerchantPullPaymentCodeType__EcheckOnly = 2
};
#endif

/* paypal.h:4212 */
#ifndef SOAP_TYPE_ns3__MerchantPullStatusCodeType
#define SOAP_TYPE_ns3__MerchantPullStatusCodeType (491)
/* ns3:MerchantPullStatusCodeType */
enum ns3__MerchantPullStatusCodeType {
	ns3__MerchantPullStatusCodeType__Active = 0,
	ns3__MerchantPullStatusCodeType__Canceled = 1
};
#endif

/* paypal.h:4224 */
#ifndef SOAP_TYPE_ns3__PaymentTransactionStatusCodeType
#define SOAP_TYPE_ns3__PaymentTransactionStatusCodeType (492)
/* ns3:PaymentTransactionStatusCodeType */
enum ns3__PaymentTransactionStatusCodeType {
	ns3__PaymentTransactionStatusCodeType__Pending = 0,
	ns3__PaymentTransactionStatusCodeType__Processing = 1,
	ns3__PaymentTransactionStatusCodeType__Success = 2,
	ns3__PaymentTransactionStatusCodeType__Denied = 3,
	ns3__PaymentTransactionStatusCodeType__Reversed = 4
};
#endif

/* paypal.h:4239 */
#ifndef SOAP_TYPE_ns3__PaymentTransactionClassCodeType
#define SOAP_TYPE_ns3__PaymentTransactionClassCodeType (493)
/* ns3:PaymentTransactionClassCodeType */
enum ns3__PaymentTransactionClassCodeType {
	ns3__PaymentTransactionClassCodeType__All = 0,
	ns3__PaymentTransactionClassCodeType__Sent = 1,
	ns3__PaymentTransactionClassCodeType__Received = 2,
	ns3__PaymentTransactionClassCodeType__MassPay = 3,
	ns3__PaymentTransactionClassCodeType__MoneyRequest = 4,
	ns3__PaymentTransactionClassCodeType__FundsAdded = 5,
	ns3__PaymentTransactionClassCodeType__FundsWithdrawn = 6,
	ns3__PaymentTransactionClassCodeType__PayPalDebitCard = 7,
	ns3__PaymentTransactionClassCodeType__Referral = 8,
	ns3__PaymentTransactionClassCodeType__Fee = 9,
	ns3__PaymentTransactionClassCodeType__Subscription = 10,
	ns3__PaymentTransactionClassCodeType__Dividend = 11,
	ns3__PaymentTransactionClassCodeType__Billpay = 12,
	ns3__PaymentTransactionClassCodeType__Refund = 13,
	ns3__PaymentTransactionClassCodeType__CurrencyConversions = 14,
	ns3__PaymentTransactionClassCodeType__BalanceTransfer = 15,
	ns3__PaymentTransactionClassCodeType__Reversal = 16,
	ns3__PaymentTransactionClassCodeType__Shipping = 17,
	ns3__PaymentTransactionClassCodeType__BalanceAffecting = 18,
	ns3__PaymentTransactionClassCodeType__ECheck = 19,
	ns3__PaymentTransactionClassCodeType__ForcedPostTransaction = 20,
	ns3__PaymentTransactionClassCodeType__NonReferencedRefunds = 21
};
#endif

/* paypal.h:4271 */
#ifndef SOAP_TYPE_ns3__MatchStatusCodeType
#define SOAP_TYPE_ns3__MatchStatusCodeType (494)
/* ns3:MatchStatusCodeType */
enum ns3__MatchStatusCodeType {
	ns3__MatchStatusCodeType__None = 0,
	ns3__MatchStatusCodeType__Matched = 1,
	ns3__MatchStatusCodeType__Unmatched = 2
};
#endif

/* paypal.h:4284 */
#ifndef SOAP_TYPE_ns3__CompleteCodeType
#define SOAP_TYPE_ns3__CompleteCodeType (495)
/* ns3:CompleteCodeType */
enum ns3__CompleteCodeType {
	ns3__CompleteCodeType__NotComplete = 0,
	ns3__CompleteCodeType__Complete = 1
};
#endif

/* paypal.h:4296 */
#ifndef SOAP_TYPE_ns3__TransactionEntityType
#define SOAP_TYPE_ns3__TransactionEntityType (496)
/* ns3:TransactionEntityType */
enum ns3__TransactionEntityType {
	ns3__TransactionEntityType__None = 0,
	ns3__TransactionEntityType__Auth = 1,
	ns3__TransactionEntityType__Reauth = 2,
	ns3__TransactionEntityType__Order = 3,
	ns3__TransactionEntityType__Payment = 4
};
#endif

/* paypal.h:4311 */
#ifndef SOAP_TYPE_ns3__MobileRecipientCodeType
#define SOAP_TYPE_ns3__MobileRecipientCodeType (497)
/* ns3:MobileRecipientCodeType */
enum ns3__MobileRecipientCodeType {
	ns3__MobileRecipientCodeType__PhoneNumber = 0,
	ns3__MobileRecipientCodeType__EmailAddress = 1
};
#endif

/* paypal.h:4323 */
#ifndef SOAP_TYPE_ns3__MobilePaymentCodeType
#define SOAP_TYPE_ns3__MobilePaymentCodeType (498)
/* ns3:MobilePaymentCodeType */
enum ns3__MobilePaymentCodeType {
	ns3__MobilePaymentCodeType__P2P = 0,
	ns3__MobilePaymentCodeType__HardGoods = 1,
	ns3__MobilePaymentCodeType__Donation = 2,
	ns3__MobilePaymentCodeType__TopUp = 3
};
#endif

/* paypal.h:4337 */
#ifndef SOAP_TYPE_ns3__MarketingCategoryType
#define SOAP_TYPE_ns3__MarketingCategoryType (499)
/* ns3:MarketingCategoryType */
enum ns3__MarketingCategoryType {
	ns3__MarketingCategoryType__Marketing_Category_Default = 0,
	ns3__MarketingCategoryType__Marketing_Category1 = 1,
	ns3__MarketingCategoryType__Marketing_Category2 = 2,
	ns3__MarketingCategoryType__Marketing_Category3 = 3,
	ns3__MarketingCategoryType__Marketing_Category4 = 4,
	ns3__MarketingCategoryType__Marketing_Category5 = 5,
	ns3__MarketingCategoryType__Marketing_Category6 = 6,
	ns3__MarketingCategoryType__Marketing_Category7 = 7,
	ns3__MarketingCategoryType__Marketing_Category8 = 8,
	ns3__MarketingCategoryType__Marketing_Category9 = 9,
	ns3__MarketingCategoryType__Marketing_Category10 = 10,
	ns3__MarketingCategoryType__Marketing_Category11 = 11,
	ns3__MarketingCategoryType__Marketing_Category12 = 12,
	ns3__MarketingCategoryType__Marketing_Category13 = 13,
	ns3__MarketingCategoryType__Marketing_Category14 = 14,
	ns3__MarketingCategoryType__Marketing_Category15 = 15,
	ns3__MarketingCategoryType__Marketing_Category16 = 16,
	ns3__MarketingCategoryType__Marketing_Category17 = 17,
	ns3__MarketingCategoryType__Marketing_Category18 = 18,
	ns3__MarketingCategoryType__Marketing_Category19 = 19,
	ns3__MarketingCategoryType__Marketing_Category20 = 20
};
#endif

/* paypal.h:4368 */
#ifndef SOAP_TYPE_ns3__BusinessTypeType
#define SOAP_TYPE_ns3__BusinessTypeType (500)
/* ns3:BusinessTypeType */
enum ns3__BusinessTypeType {
	ns3__BusinessTypeType__Unknown = 0,
	ns3__BusinessTypeType__Individual = 1,
	ns3__BusinessTypeType__Proprietorship = 2,
	ns3__BusinessTypeType__Partnership = 3,
	ns3__BusinessTypeType__Corporation = 4,
	ns3__BusinessTypeType__Nonprofit = 5,
	ns3__BusinessTypeType__Government = 6
};
#endif

/* paypal.h:4385 */
#ifndef SOAP_TYPE_ns3__BusinessCategoryType
#define SOAP_TYPE_ns3__BusinessCategoryType (501)
/* ns3:BusinessCategoryType */
enum ns3__BusinessCategoryType {
	ns3__BusinessCategoryType__Category_Unspecified = 0,
	ns3__BusinessCategoryType__Antiques = 1,
	ns3__BusinessCategoryType__Arts = 2,
	ns3__BusinessCategoryType__Automotive = 3,
	ns3__BusinessCategoryType__Beauty = 4,
	ns3__BusinessCategoryType__Books = 5,
	ns3__BusinessCategoryType__Business = 6,
	ns3__BusinessCategoryType__Cameras_and_Photography = 7,
	ns3__BusinessCategoryType__Clothing = 8,
	ns3__BusinessCategoryType__Collectibles = 9,
	ns3__BusinessCategoryType__Computer_Hardware_and_Software = 10,
	ns3__BusinessCategoryType__Culture_and_Religion = 11,
	ns3__BusinessCategoryType__Electronics_and_Telecom = 12,
	ns3__BusinessCategoryType__Entertainment = 13,
	ns3__BusinessCategoryType__Entertainment_Memorabilia = 14,
	ns3__BusinessCategoryType__Food_Drink_and_Nutrition = 15,
	ns3__BusinessCategoryType__Gifts_and_Flowers = 16,
	ns3__BusinessCategoryType__Hobbies_Toys_and_Games = 17,
	ns3__BusinessCategoryType__Home_and_Garden = 18,
	ns3__BusinessCategoryType__Internet_and_Network_Services = 19,
	ns3__BusinessCategoryType__Media_and_Entertainment = 20,
	ns3__BusinessCategoryType__Medical_and_Pharmaceutical = 21,
	ns3__BusinessCategoryType__Money_Service_Businesses = 22,
	ns3__BusinessCategoryType__Non_Profit_Political_and_Religion = 23,
	ns3__BusinessCategoryType__Not_Elsewhere_Classified = 24,
	ns3__BusinessCategoryType__Pets_and_Animals = 25,
	ns3__BusinessCategoryType__Real_Estate = 26,
	ns3__BusinessCategoryType__Services = 27,
	ns3__BusinessCategoryType__Sports_and_Recreation = 28,
	ns3__BusinessCategoryType__Travel = 29,
	ns3__BusinessCategoryType__Other_Categories = 30
};
#endif

/* paypal.h:4426 */
#ifndef SOAP_TYPE_ns3__BusinessSubCategoryType
#define SOAP_TYPE_ns3__BusinessSubCategoryType (502)
/* ns3:BusinessSubCategoryType */
enum ns3__BusinessSubCategoryType {
	ns3__BusinessSubCategoryType__SubCategory_Unspecified = 0,
	ns3__BusinessSubCategoryType__ANTIQUES_General = 1,
	ns3__BusinessSubCategoryType__ANTIQUES_Antiquities = 2,
	ns3__BusinessSubCategoryType__ANTIQUES_Decorative = 3,
	ns3__BusinessSubCategoryType__ANTIQUES_Books_Manuscripts = 4,
	ns3__BusinessSubCategoryType__ANTIQUES_Furniture = 5,
	ns3__BusinessSubCategoryType__ANTIQUES_Glass = 6,
	ns3__BusinessSubCategoryType__ANTIQUES_RugsCarpets = 7,
	ns3__BusinessSubCategoryType__ANTIQUES_Pottery = 8,
	ns3__BusinessSubCategoryType__ANTIQUES_Cultural = 9,
	ns3__BusinessSubCategoryType__ANTIQUES_Artifacts_Grave_related_and_Native_American_Crafts = 10,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_General = 11,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Art_Dealer_and_Galleries = 12,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Prints = 13,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Painting = 14,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Photography = 15,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Reproductions = 16,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Sculptures = 17,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Woodworking = 18,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Art_and_Craft_Supplies = 19,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Fabrics_and_Sewing = 20,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Quilting = 21,
	ns3__BusinessSubCategoryType__ARTSANDCRAFTS_Scrapbooking = 22,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_General = 23,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Autos = 24,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Aviation = 25,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Motorcycles = 26,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Parts_and_Supplies = 27,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Services = 28,
	ns3__BusinessSubCategoryType__AUTOMOTIVE_Vintage_and_Collectible_Vehicles = 29,
	ns3__BusinessSubCategoryType__BEAUTY_General = 30,
	ns3__BusinessSubCategoryType__BEAUTY_Body_Care_Personal_Hygiene = 31,
	ns3__BusinessSubCategoryType__BEAUTY_Fragrances_and_Perfumes = 32,
	ns3__BusinessSubCategoryType__BEAUTY_Makeup = 33,
	ns3__BusinessSubCategoryType__BOOKS_General = 34,
	ns3__BusinessSubCategoryType__BOOKS_Audio_Books = 35,
	ns3__BusinessSubCategoryType__BOOKS_Children_Books = 36,
	ns3__BusinessSubCategoryType__BOOKS_Computer_Books = 37,
	ns3__BusinessSubCategoryType__BOOKS_Educational_and_Textbooks = 38,
	ns3__BusinessSubCategoryType__BOOKS_Magazines = 39,
	ns3__BusinessSubCategoryType__BOOKS_Fiction_and_Literature = 40,
	ns3__BusinessSubCategoryType__BOOKS_NonFiction = 41,
	ns3__BusinessSubCategoryType__BOOKS_Vintage_and_Collectibles = 42,
	ns3__BusinessSubCategoryType__BUSINESS_General = 43,
	ns3__BusinessSubCategoryType__BUSINESS_Agricultural = 44,
	ns3__BusinessSubCategoryType__BUSINESS_Construction = 45,
	ns3__BusinessSubCategoryType__BUSINESS_Educational = 46,
	ns3__BusinessSubCategoryType__BUSINESS_Industrial = 47,
	ns3__BusinessSubCategoryType__BUSINESS_Office_Supplies_and_Equipment = 48,
	ns3__BusinessSubCategoryType__BUSINESS_GeneralServices = 49,
	ns3__BusinessSubCategoryType__BUSINESS_Advertising = 50,
	ns3__BusinessSubCategoryType__BUSINESS_Employment = 51,
	ns3__BusinessSubCategoryType__BUSINESS_Marketing = 52,
	ns3__BusinessSubCategoryType__BUSINESS_Meeting_Planners = 53,
	ns3__BusinessSubCategoryType__BUSINESS_Messaging_and_Paging_Services = 54,
	ns3__BusinessSubCategoryType__BUSINESS_Seminars = 55,
	ns3__BusinessSubCategoryType__BUSINESS_Publishing = 56,
	ns3__BusinessSubCategoryType__BUSINESS_Shipping_and_Packaging = 57,
	ns3__BusinessSubCategoryType__BUSINESS_Wholesale = 58,
	ns3__BusinessSubCategoryType__BUSINESS_Industrial_Solvents = 59,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_General = 60,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_Accessories = 61,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_Cameras = 62,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_Video_Equipment = 63,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_Film = 64,
	ns3__BusinessSubCategoryType__CAMERASANDPHOTOGRAPHY_Supplies = 'A',
	ns3__BusinessSubCategoryType__CLOTHING_Accessories = 'B',
	ns3__BusinessSubCategoryType__CLOTHING_Babies_Clothing_and_Supplies = 'C',
	ns3__BusinessSubCategoryType__CLOTHING_Childrens_Clothing = 'D',
	ns3__BusinessSubCategoryType__CLOTHING_Mens_Clothing = 'E',
	ns3__BusinessSubCategoryType__CLOTHING_Shoes = 'F',
	ns3__BusinessSubCategoryType__CLOTHING_Wedding_Clothing = 'G',
	ns3__BusinessSubCategoryType__CLOTHING_Womens_Clothing = 'H',
	ns3__BusinessSubCategoryType__CLOTHING_General = 'I',
	ns3__BusinessSubCategoryType__CLOTHING_Jewelry = 'J',
	ns3__BusinessSubCategoryType__CLOTHING_Watches_and_Clocks = 'K',
	ns3__BusinessSubCategoryType__CLOTHING_Rings = 'L',
	ns3__BusinessSubCategoryType__COLLECTIBLES_General = 'M',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Advertising = 'N',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Animals = 'O',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Animation = 'P',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Coin_Operated_Banks_and_Casinos = 'Q',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Coins_and_Paper_Money = 'R',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Comics = 'S',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Decorative = 'T',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Disneyana = 'U',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Holiday = 'V',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Knives_and_Swords = 'W',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Militaria = 'X',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Postcards_and_Paper = 'Y',
	ns3__BusinessSubCategoryType__COLLECTIBLES_Stamps = 'Z',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_General = 91,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Desktop_PCs = 92,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Monitors = 93,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Hardware = 94,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Peripherals = 95,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Laptops_Notebooks_PDAs = 96,
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Networking_Equipment = 'a',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Parts_and_Accessories = 'b',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_GeneralSoftware = 'c',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Oem_Software = 'd',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Academic_Software = 'e',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Beta_Software = 'f',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Game_Software = 'g',
	ns3__BusinessSubCategoryType__COMPUTERHARDWAREANDSOFTWARE_Data_Processing_Svc = 'h',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_General = 'i',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_Christianity = 'j',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_Metaphysical = 'k',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_New_Age = 'l',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_Organizations = 'm',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_Other_Faiths = 'n',
	ns3__BusinessSubCategoryType__CULTUREANDRELIGION_Collectibles = 'o',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_GeneralTelecom = 'p',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Cell_Phones_and_Pagers = 'q',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Telephone_Cards = 'r',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Telephone_Equipment = 's',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Telephone_Services = 't',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_GeneralElectronics = 'u',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Car_Audio_and_Electronics = 'v',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Home_Electronics = 'w',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Home_Audio = 'x',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Gadgets_and_other_electronics = 'y',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Batteries = 'z',
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_ScannersRadios = 123,
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Radar_Dectors = 124,
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Radar_Jamming_Devices = 125,
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Satellite_and_Cable_TV_Descramblers = 126,
	ns3__BusinessSubCategoryType__ELECTRONICSANDTELECOM_Surveillance_Equipment = 127,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_General = 128,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Movies = 129,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Music = 130,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Concerts = 131,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Theater = 132,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Bootleg_Recordings = 133,
	ns3__BusinessSubCategoryType__ENTERTAINMENT_Promotional_Items = 134,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_General = 135,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Autographs = 136,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Limited_Editions = 137,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Movie = 138,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Music = 139,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Novelties = 140,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Photos = 141,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Posters = 142,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Sports_and_Fan_Shop = 143,
	ns3__BusinessSubCategoryType__ENTERTAINMENTMEMORABILIA_Science_Fiction = 144,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_General = 145,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Coffee_and_Tea = 146,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Food_Products = 147,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Gourmet_Items = 148,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Health_and_Nutrition = 149,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Services = 150,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Vitamins_and_Supplements = 151,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Weight_Management_and_Health_Products = 152,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Restaurant = 153,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Tobacco_and_Cigars = 154,
	ns3__BusinessSubCategoryType__FOODDRINKANDNUTRITION_Alcoholic_Beverages = 155,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_General = 156,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Flowers = 157,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Greeting_Cards = 158,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Humorous_Gifts_and_Novelties = 159,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Personalized_Gifts = 160,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Products = 161,
	ns3__BusinessSubCategoryType__GIFTSANDFLOWERS_Services = 162,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_General = 163,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Action_Figures = 164,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Bean_Babies = 165,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Barbies = 166,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Bears = 167,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Dolls = 168,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Games = 169,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Model_Kits = 170,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Diecast_Toys_Vehicles = 171,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Video_Games_and_Systems = 172,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Vintage_and_Antique_Toys = 173,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_BackupUnreleased_Games = 174,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Game_copying_hardwaresoftware = 175,
	ns3__BusinessSubCategoryType__HOBBIESTOYSANDGAMES_Mod_Chips = 176,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_General = 177,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Appliances = 178,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Bed_and_Bath = 179,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Furnishing_and_Decorating = 180,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Garden_Supplies = 181,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Hardware_and_Tools = 182,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Household_Goods = 183,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Kitchenware = 184,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Rugs_and_Carpets = 185,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Security_and_Home_Defense = 186,
	ns3__BusinessSubCategoryType__HOMEANDGARDEN_Plants_and_Seeds = 187,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_General = 188,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_Bulletin_board = 189,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_online_services = 190,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_Auction_management_tools = 191,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_ecommerce_development = 192,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_training_services = 193,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_Online_Malls = 194,
	ns3__BusinessSubCategoryType__INTERNETANDNETWORKSERVICES_Web_hosting_and_design = 195,
	ns3__BusinessSubCategoryType__MEDIAANDENTERTAINMENT_General = 196,
	ns3__BusinessSubCategoryType__MEDIAANDENTERTAINMENT_Concerts = 197,
	ns3__BusinessSubCategoryType__MEDIAANDENTERTAINMENT_Theater = 198,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_General = 199,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_Medical = 200,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_Dental = 201,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_Opthamalic = 202,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_Prescription_Drugs = 203,
	ns3__BusinessSubCategoryType__MEDICALANDPHARMACEUTICAL_Devices = 204,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_General = 205,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Remittance = 206,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Wire_Transfer = 207,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Money_Orders = 208,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Electronic_Cash = 209,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Currency_DealerExchange = 210,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Check_Cashier = 211,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Travelers_Checks = 212,
	ns3__BusinessSubCategoryType__MONEYSERVICEBUSINESSES_Stored_Value_Cards = 213,
	ns3__BusinessSubCategoryType__NONPROFITPOLITICALANDRELIGION_General = 214,
	ns3__BusinessSubCategoryType__NONPROFITPOLITICALANDRELIGION_Charities = 215,
	ns3__BusinessSubCategoryType__NONPROFITPOLITICALANDRELIGION_Political = 216,
	ns3__BusinessSubCategoryType__NONPROFITPOLITICALANDRELIGION_Religious = 217,
	ns3__BusinessSubCategoryType__PETSANDANIMALS_General = 218,
	ns3__BusinessSubCategoryType__PETSANDANIMALS_Supplies_and_Toys = 219,
	ns3__BusinessSubCategoryType__PETSANDANIMALS_Wildlife_Products = 220,
	ns3__BusinessSubCategoryType__REALESTATE_General = 221,
	ns3__BusinessSubCategoryType__REALESTATE_Commercial = 222,
	ns3__BusinessSubCategoryType__REALESTATE_Residential = 223,
	ns3__BusinessSubCategoryType__REALESTATE_Time_Shares = 224,
	ns3__BusinessSubCategoryType__SERVICES_GeneralGovernment = 225,
	ns3__BusinessSubCategoryType__SERVICES_Legal = 226,
	ns3__BusinessSubCategoryType__SERVICES_Medical = 227,
	ns3__BusinessSubCategoryType__SERVICES_Dental = 228,
	ns3__BusinessSubCategoryType__SERVICES_Vision = 229,
	ns3__BusinessSubCategoryType__SERVICES_General = 230,
	ns3__BusinessSubCategoryType__SERVICES_Child_Care_Services = 231,
	ns3__BusinessSubCategoryType__SERVICES_Consulting = 232,
	ns3__BusinessSubCategoryType__SERVICES_ImportingExporting = 233,
	ns3__BusinessSubCategoryType__SERVICES_InsuranceDirect = 234,
	ns3__BusinessSubCategoryType__SERVICES_Financial_Services = 235,
	ns3__BusinessSubCategoryType__SERVICES_Graphic_and_Commercial_Design = 236,
	ns3__BusinessSubCategoryType__SERVICES_Landscaping = 237,
	ns3__BusinessSubCategoryType__SERVICES_Locksmith = 238,
	ns3__BusinessSubCategoryType__SERVICES_Online_Dating = 239,
	ns3__BusinessSubCategoryType__SERVICES_Event_and_Wedding_Planning = 240,
	ns3__BusinessSubCategoryType__SERVICES_Schools_and_Colleges = 241,
	ns3__BusinessSubCategoryType__SERVICES_Entertainment = 242,
	ns3__BusinessSubCategoryType__SERVICES_Aggregators = 243,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_General = 244,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Bicycles_and_Accessories = 245,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Boating_Sailing_and_Accessories = 246,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Camping_and_Survival = 247,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Exercise_Equipment = 248,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Fishing = 249,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Golf = 250,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Hunting = 251,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Paintball = 252,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Sporting_Goods = 253,
	ns3__BusinessSubCategoryType__SPORTSANDRECREATION_Swimming_Pools_and_Spas = 254,
	ns3__BusinessSubCategoryType__TRAVEL_General = 255,
	ns3__BusinessSubCategoryType__TRAVEL_Accommodations = 256,
	ns3__BusinessSubCategoryType__TRAVEL_Agencies = 257,
	ns3__BusinessSubCategoryType__TRAVEL_Airlines = 258,
	ns3__BusinessSubCategoryType__TRAVEL_Auto_Rentals = 259,
	ns3__BusinessSubCategoryType__TRAVEL_Cruises = 260,
	ns3__BusinessSubCategoryType__TRAVEL_Other_Transportation = 261,
	ns3__BusinessSubCategoryType__TRAVEL_Services = 262,
	ns3__BusinessSubCategoryType__TRAVEL_Supplies = 263,
	ns3__BusinessSubCategoryType__TRAVEL_Tours = 264,
	ns3__BusinessSubCategoryType__TRAVEL_AirlinesSpirit_Air = 265,
	ns3__BusinessSubCategoryType__Other_SubCategories = 266
};
#endif

/* paypal.h:4754 */
#ifndef SOAP_TYPE_ns3__AverageTransactionPriceType
#define SOAP_TYPE_ns3__AverageTransactionPriceType (503)
/* ns3:AverageTransactionPriceType */
enum ns3__AverageTransactionPriceType {
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Not_Applicable = 0,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range1 = 1,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range2 = 2,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range3 = 3,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range4 = 4,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range5 = 5,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range6 = 6,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range7 = 7,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range8 = 8,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range9 = 9,
	ns3__AverageTransactionPriceType__AverageTransactionPrice_Range10 = 10
};
#endif

/* paypal.h:4808 */
#ifndef SOAP_TYPE_ns3__AverageMonthlyVolumeType
#define SOAP_TYPE_ns3__AverageMonthlyVolumeType (504)
/* ns3:AverageMonthlyVolumeType */
enum ns3__AverageMonthlyVolumeType {
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Not_Applicable = 0,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range1 = 1,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range2 = 2,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range3 = 3,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range4 = 4,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range5 = 5,
	ns3__AverageMonthlyVolumeType__AverageMonthlyVolume_Range6 = 6
};
#endif

/* paypal.h:4825 */
#ifndef SOAP_TYPE_ns3__SalesVenueType
#define SOAP_TYPE_ns3__SalesVenueType (505)
/* ns3:SalesVenueType */
enum ns3__SalesVenueType {
	ns3__SalesVenueType__Venue_Unspecified = 0,
	ns3__SalesVenueType__eBay = 1,
	ns3__SalesVenueType__AnotherMarketPlace = 2,
	ns3__SalesVenueType__OwnWebsite = 3,
	ns3__SalesVenueType__Other = 4
};
#endif

/* paypal.h:4867 */
#ifndef SOAP_TYPE_ns3__PercentageRevenueFromOnlineSalesType
#define SOAP_TYPE_ns3__PercentageRevenueFromOnlineSalesType (506)
/* ns3:PercentageRevenueFromOnlineSalesType */
enum ns3__PercentageRevenueFromOnlineSalesType {
	ns3__PercentageRevenueFromOnlineSalesType__PercentageRevenueFromOnlineSales_Not_Applicable = 0,
	ns3__PercentageRevenueFromOnlineSalesType__PercentageRevenueFromOnlineSales_Range1 = 1,
	ns3__PercentageRevenueFromOnlineSalesType__PercentageRevenueFromOnlineSales_Range2 = 2,
	ns3__PercentageRevenueFromOnlineSalesType__PercentageRevenueFromOnlineSales_Range3 = 3,
	ns3__PercentageRevenueFromOnlineSalesType__PercentageRevenueFromOnlineSales_Range4 = 4
};
#endif

/* paypal.h:4882 */
#ifndef SOAP_TYPE_ns3__BankAccountTypeType
#define SOAP_TYPE_ns3__BankAccountTypeType (507)
/* ns3:BankAccountTypeType */
enum ns3__BankAccountTypeType {
	ns3__BankAccountTypeType__Checking = 0,
	ns3__BankAccountTypeType__Savings = 1
};
#endif

/* paypal.h:4898 */
#ifndef SOAP_TYPE_ns3__BoardingStatusType
#define SOAP_TYPE_ns3__BoardingStatusType (509)
/* ns3:BoardingStatusType */
enum ns3__BoardingStatusType {
	ns3__BoardingStatusType__Unknown = 0,
	ns3__BoardingStatusType__Completed = 1,
	ns3__BoardingStatusType__Cancelled = 2,
	ns3__BoardingStatusType__Pending = 3
};
#endif

/* paypal.h:4912 */
#ifndef SOAP_TYPE_ns3__UserWithdrawalLimitTypeType
#define SOAP_TYPE_ns3__UserWithdrawalLimitTypeType (510)
/* ns3:UserWithdrawalLimitTypeType */
enum ns3__UserWithdrawalLimitTypeType {
	ns3__UserWithdrawalLimitTypeType__Unknown = 0,
	ns3__UserWithdrawalLimitTypeType__Limited = 1,
	ns3__UserWithdrawalLimitTypeType__Unlimited = 2
};
#endif

/* paypal.h:4925 */
#ifndef SOAP_TYPE_ns3__APIAuthenticationType
#define SOAP_TYPE_ns3__APIAuthenticationType (511)
/* ns3:APIAuthenticationType */
enum ns3__APIAuthenticationType {
	ns3__APIAuthenticationType__Auth_None = 0,
	ns3__APIAuthenticationType__Cert = 1,
	ns3__APIAuthenticationType__Sign = 2
};
#endif

/* paypal.h:4935 */
#ifndef SOAP_TYPE_ns3__EbayCheckoutType
#define SOAP_TYPE_ns3__EbayCheckoutType (512)
/* ns3:EbayCheckoutType */
enum ns3__EbayCheckoutType {
	ns3__EbayCheckoutType__none = 0,
	ns3__EbayCheckoutType__Auction = 1,
	ns3__EbayCheckoutType__BuyItNow = 2,
	ns3__EbayCheckoutType__FixedPriceItem = 3,
	ns3__EbayCheckoutType__Autopay = 4
};
#endif

/* paypal.h:4947 */
#ifndef SOAP_TYPE_ns3__DyneticClientType
#define SOAP_TYPE_ns3__DyneticClientType (513)
/* ns3:DyneticClientType */
enum ns3__DyneticClientType {
	ns3__DyneticClientType__none = 0,
	ns3__DyneticClientType__WAP = 1,
	ns3__DyneticClientType__J2MEClient = 2
};
#endif

/* paypal.h:4959 */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsProfileStatusType
#define SOAP_TYPE_ns3__RecurringPaymentsProfileStatusType (514)
/* ns3:RecurringPaymentsProfileStatusType */
enum ns3__RecurringPaymentsProfileStatusType {
	ns3__RecurringPaymentsProfileStatusType__ActiveProfile = 0,
	ns3__RecurringPaymentsProfileStatusType__PendingProfile = 1,
	ns3__RecurringPaymentsProfileStatusType__CancelledProfile = 2,
	ns3__RecurringPaymentsProfileStatusType__ExpiredProfile = 3,
	ns3__RecurringPaymentsProfileStatusType__SuspendedProfile = 4
};
#endif

/* paypal.h:4973 */
#ifndef SOAP_TYPE_ns3__FailedPaymentActionType
#define SOAP_TYPE_ns3__FailedPaymentActionType (515)
/* ns3:FailedPaymentActionType */
enum ns3__FailedPaymentActionType {
	ns3__FailedPaymentActionType__CancelOnFailure = 0,
	ns3__FailedPaymentActionType__ContinueOnFailure = 1
};
#endif

/* paypal.h:4984 */
#ifndef SOAP_TYPE_ns3__AutoBillType
#define SOAP_TYPE_ns3__AutoBillType (516)
/* ns3:AutoBillType */
enum ns3__AutoBillType {
	ns3__AutoBillType__NoAutoBill = 0,
	ns3__AutoBillType__AddToNextBilling = 1
};
#endif

/* paypal.h:4995 */
#ifndef SOAP_TYPE_ns3__StatusChangeActionType
#define SOAP_TYPE_ns3__StatusChangeActionType (517)
/* ns3:StatusChangeActionType */
enum ns3__StatusChangeActionType {
	ns3__StatusChangeActionType__Cancel = 0,
	ns3__StatusChangeActionType__Suspend = 1,
	ns3__StatusChangeActionType__Reactivate = 2
};
#endif

/* paypal.h:5007 */
#ifndef SOAP_TYPE_ns3__BillingPeriodType
#define SOAP_TYPE_ns3__BillingPeriodType (518)
/* ns3:BillingPeriodType */
enum ns3__BillingPeriodType {
	ns3__BillingPeriodType__NoBillingPeriodType = 0,
	ns3__BillingPeriodType__Day = 1,
	ns3__BillingPeriodType__Week = 2,
	ns3__BillingPeriodType__SemiMonth = 3,
	ns3__BillingPeriodType__Month = 4,
	ns3__BillingPeriodType__Year = 5
};
#endif

/* paypal.h:5022 */
#ifndef SOAP_TYPE_ns3__ProductCategoryType
#define SOAP_TYPE_ns3__ProductCategoryType (519)
/* ns3:ProductCategoryType */
enum ns3__ProductCategoryType {
	ns3__ProductCategoryType__Other = 0,
	ns3__ProductCategoryType__Airlines = 1,
	ns3__ProductCategoryType__Antiques = 2,
	ns3__ProductCategoryType__Art = 3,
	ns3__ProductCategoryType__Cameras_USCOREPhotos = 4,
	ns3__ProductCategoryType__Cars_USCOREBoats_USCOREVehicles_USCOREParts = 5,
	ns3__ProductCategoryType__CellPhones_USCORETelecom = 6,
	ns3__ProductCategoryType__Coins_USCOREPaperMoney = 7,
	ns3__ProductCategoryType__Collectibles = 8,
	ns3__ProductCategoryType__Computers_USCORENetworking = 9,
	ns3__ProductCategoryType__ConsumerElectronics = 10,
	ns3__ProductCategoryType__Jewelry_USCOREWatches = 11,
	ns3__ProductCategoryType__MusicalInstruments = 12,
	ns3__ProductCategoryType__RealEstate = 13,
	ns3__ProductCategoryType__SportsMemorabilia_USCORECards_USCOREFanShop = 14,
	ns3__ProductCategoryType__Stamps = 15,
	ns3__ProductCategoryType__Tickets = 16,
	ns3__ProductCategoryType__Travels = 17,
	ns3__ProductCategoryType__Gambling = 18,
	ns3__ProductCategoryType__Alcohol = 19,
	ns3__ProductCategoryType__Tobacco = 20,
	ns3__ProductCategoryType__MoneyTransfer = 21,
	ns3__ProductCategoryType__Software = 22
};
#endif

/* paypal.h:5124 */
#ifndef SOAP_TYPE_ns3__ButtonCodeType
#define SOAP_TYPE_ns3__ButtonCodeType (520)
/* ns3:ButtonCodeType */
enum ns3__ButtonCodeType {
	ns3__ButtonCodeType__HOSTED = 0,
	ns3__ButtonCodeType__ENCRYPTED = 1,
	ns3__ButtonCodeType__CLEARTEXT = 2,
	ns3__ButtonCodeType__TOKEN = 3
};
#endif

/* paypal.h:5150 */
#ifndef SOAP_TYPE_ns3__ButtonTypeType
#define SOAP_TYPE_ns3__ButtonTypeType (521)
/* ns3:ButtonTypeType */
enum ns3__ButtonTypeType {
	ns3__ButtonTypeType__BUYNOW = 0,
	ns3__ButtonTypeType__CART = 1,
	ns3__ButtonTypeType__GIFTCERTIFICATE = 2,
	ns3__ButtonTypeType__SUBSCRIBE = 3,
	ns3__ButtonTypeType__DONATE = 4,
	ns3__ButtonTypeType__UNSUBSCRIBE = 5,
	ns3__ButtonTypeType__VIEWCART = 6,
	ns3__ButtonTypeType__PAYMENTPLAN = 7,
	ns3__ButtonTypeType__AUTOBILLING = 8,
	ns3__ButtonTypeType__PAYMENT = 9
};
#endif

/* paypal.h:5200 */
#ifndef SOAP_TYPE_ns3__ButtonSubTypeType
#define SOAP_TYPE_ns3__ButtonSubTypeType (522)
/* ns3:ButtonSubTypeType */
enum ns3__ButtonSubTypeType {
	ns3__ButtonSubTypeType__PRODUCTS = 0,
	ns3__ButtonSubTypeType__SERVICES = 1
};
#endif

/* paypal.h:5218 */
#ifndef SOAP_TYPE_ns3__ButtonImageType
#define SOAP_TYPE_ns3__ButtonImageType (523)
/* ns3:ButtonImageType */
enum ns3__ButtonImageType {
	ns3__ButtonImageType__REG = 0,
	ns3__ButtonImageType__SML = 1,
	ns3__ButtonImageType__CC = 2
};
#endif

/* paypal.h:5240 */
#ifndef SOAP_TYPE_ns3__BuyNowTextType
#define SOAP_TYPE_ns3__BuyNowTextType (524)
/* ns3:BuyNowTextType */
enum ns3__BuyNowTextType {
	ns3__BuyNowTextType__BUYNOW = 0,
	ns3__BuyNowTextType__PAYNOW = 1
};
#endif

/* paypal.h:5258 */
#ifndef SOAP_TYPE_ns3__SubscribeTextType
#define SOAP_TYPE_ns3__SubscribeTextType (525)
/* ns3:SubscribeTextType */
enum ns3__SubscribeTextType {
	ns3__SubscribeTextType__BUYNOW = 0,
	ns3__SubscribeTextType__SUBSCRIBE = 1
};
#endif

/* paypal.h:5276 */
#ifndef SOAP_TYPE_ns3__ButtonStatusType
#define SOAP_TYPE_ns3__ButtonStatusType (526)
/* ns3:ButtonStatusType */
enum ns3__ButtonStatusType {
	ns3__ButtonStatusType__DELETE = 0
};
#endif

/* paypal.h:5289 */
#ifndef SOAP_TYPE_ns3__OptionTypeListType
#define SOAP_TYPE_ns3__OptionTypeListType (527)
/* ns3:OptionTypeListType */
enum ns3__OptionTypeListType {
	ns3__OptionTypeListType__NoOptionType = 0,
	ns3__OptionTypeListType__FULL = 1,
	ns3__OptionTypeListType__EMI = 2,
	ns3__OptionTypeListType__VARIABLE = 3
};
#endif

/* paypal.h:5304 */
#ifndef SOAP_TYPE_ns3__UserSelectedFundingSourceType
#define SOAP_TYPE_ns3__UserSelectedFundingSourceType (528)
/* ns3:UserSelectedFundingSourceType */
enum ns3__UserSelectedFundingSourceType {
	ns3__UserSelectedFundingSourceType__ELV = 0,
	ns3__UserSelectedFundingSourceType__CreditCard = 1,
	ns3__UserSelectedFundingSourceType__ChinaUnionPay = 2,
	ns3__UserSelectedFundingSourceType__BML = 3,
	ns3__UserSelectedFundingSourceType__Finance = 4,
	ns3__UserSelectedFundingSourceType__QIWI = 5
};
#endif

/* paypal.h:5319 */
#ifndef SOAP_TYPE_ns3__ItemCategoryType
#define SOAP_TYPE_ns3__ItemCategoryType (529)
/* ns3:ItemCategoryType */
enum ns3__ItemCategoryType {
	ns3__ItemCategoryType__Physical = 0,
	ns3__ItemCategoryType__Digital = 1
};
#endif

/* paypal.h:5336 */
#ifndef SOAP_TYPE_ns3__RecurringFlagType
#define SOAP_TYPE_ns3__RecurringFlagType (530)
/* ns3:RecurringFlagType */
enum ns3__RecurringFlagType {
	ns3__RecurringFlagType__Y = 'Y',
	ns3__RecurringFlagType__y = 'y'
};
#endif

/* paypal.h:5348 */
#ifndef SOAP_TYPE_ns3__CoupleType
#define SOAP_TYPE_ns3__CoupleType (531)
/* ns3:CoupleType */
enum ns3__CoupleType {
	ns3__CoupleType__LifeTime = 0
};
#endif

/* paypal.h:5362 */
#ifndef SOAP_TYPE_ns3__PaymentCategoryType
#define SOAP_TYPE_ns3__PaymentCategoryType (532)
/* ns3:PaymentCategoryType */
enum ns3__PaymentCategoryType {
	ns3__PaymentCategoryType__InternationalShipping = 0,
	ns3__PaymentCategoryType__LocalDelivery = 1,
	ns3__PaymentCategoryType__BOPIS = 2,
	ns3__PaymentCategoryType__PUDO = 3
};
#endif

/* paypal.h:5388 */
#ifndef SOAP_TYPE_ns3__LocationType
#define SOAP_TYPE_ns3__LocationType (533)
/* ns3:LocationType */
enum ns3__LocationType {
	ns3__LocationType__Consumer = 0,
	ns3__LocationType__Store = 1,
	ns3__LocationType__PickupDropoff = 2
};
#endif

/* paypal.h:5407 */
#ifndef SOAP_TYPE_ns3__WalletItemType
#define SOAP_TYPE_ns3__WalletItemType (534)
/* ns3:WalletItemType */
enum ns3__WalletItemType {
	ns3__WalletItemType__MERCHANT_USCORECOUPON = 0,
	ns3__WalletItemType__LOYALTY_USCORECARD = 1,
	ns3__WalletItemType__MANUFACTURER_USCORECOUPON = 2,
	ns3__WalletItemType__MERCHANT_USCORECLOSED_USCORELOOP_USCOREOFFER = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/chrono_duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (10)
typedef std::chrono::nanoseconds xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__InstallmentDetailsType;	/* paypal.h:184 */
class ns1__OptionSelectionDetailsType;	/* paypal.h:187 */
class ns1__OptionDetailsType;	/* paypal.h:190 */
class ns1__MassPayRequestItemType;	/* paypal.h:283 */
class _ns1__BMCreateButtonReq;	/* paypal.h:538 */
class _ns1__BMUpdateButtonReq;	/* paypal.h:541 */
class _ns1__BMManageButtonStatusReq;	/* paypal.h:544 */
class _ns1__BMGetButtonDetailsReq;	/* paypal.h:547 */
class _ns1__BMSetInventoryReq;	/* paypal.h:550 */
class _ns1__BMGetInventoryReq;	/* paypal.h:553 */
class _ns1__BMButtonSearchReq;	/* paypal.h:556 */
class _ns1__RefundTransactionReq;	/* paypal.h:559 */
class _ns1__InitiateRecoupReq;	/* paypal.h:562 */
class _ns1__CompleteRecoupReq;	/* paypal.h:565 */
class _ns1__CancelRecoupReq;	/* paypal.h:568 */
class _ns1__GetTransactionDetailsReq;	/* paypal.h:571 */
class _ns1__BillUserReq;	/* paypal.h:574 */
class _ns1__TransactionSearchReq;	/* paypal.h:577 */
class _ns1__MassPayReq;	/* paypal.h:580 */
class _ns1__BillAgreementUpdateReq;	/* paypal.h:583 */
class _ns1__AddressVerifyReq;	/* paypal.h:586 */
class _ns1__EnterBoardingReq;	/* paypal.h:589 */
class _ns1__GetBoardingDetailsReq;	/* paypal.h:592 */
class _ns1__SetAuthFlowParamReq;	/* paypal.h:595 */
class _ns1__GetAuthDetailsReq;	/* paypal.h:598 */
class _ns1__SetAccessPermissionsReq;	/* paypal.h:601 */
class _ns1__UpdateAccessPermissionsReq;	/* paypal.h:604 */
class _ns1__GetAccessPermissionDetailsReq;	/* paypal.h:607 */
class _ns1__GetIncentiveEvaluationReq;	/* paypal.h:610 */
class _ns1__SetExpressCheckoutReq;	/* paypal.h:613 */
class _ns1__ExecuteCheckoutOperationsReq;	/* paypal.h:616 */
class _ns1__GetExpressCheckoutDetailsReq;	/* paypal.h:619 */
class _ns1__DoExpressCheckoutPaymentReq;	/* paypal.h:622 */
class _ns1__DoUATPExpressCheckoutPaymentReq;	/* paypal.h:625 */
class _ns1__ManagePendingTransactionStatusReq;	/* paypal.h:628 */
class _ns1__DoDirectPaymentReq;	/* paypal.h:631 */
class _ns1__DoCancelReq;	/* paypal.h:634 */
class _ns1__DoCaptureReq;	/* paypal.h:637 */
class _ns1__DoReauthorizationReq;	/* paypal.h:640 */
class _ns1__DoVoidReq;	/* paypal.h:643 */
class _ns1__DoAuthorizationReq;	/* paypal.h:646 */
class _ns1__UpdateAuthorizationReq;	/* paypal.h:649 */
class _ns1__DoUATPAuthorizationReq;	/* paypal.h:652 */
class _ns1__CreateMobilePaymentReq;	/* paypal.h:655 */
class _ns1__GetMobileStatusReq;	/* paypal.h:658 */
class _ns1__SetMobileCheckoutReq;	/* paypal.h:661 */
class _ns1__DoMobileCheckoutPaymentReq;	/* paypal.h:664 */
class _ns1__GetBalanceReq;	/* paypal.h:667 */
class _ns1__SetCustomerBillingAgreementReq;	/* paypal.h:670 */
class _ns1__GetBillingAgreementCustomerDetailsReq;	/* paypal.h:673 */
class _ns1__CreateBillingAgreementReq;	/* paypal.h:676 */
class _ns1__DoReferenceTransactionReq;	/* paypal.h:679 */
class _ns1__DoNonReferencedCreditReq;	/* paypal.h:682 */
class _ns1__CreateRecurringPaymentsProfileReq;	/* paypal.h:685 */
class _ns1__GetRecurringPaymentsProfileDetailsReq;	/* paypal.h:688 */
class _ns1__ManageRecurringPaymentsProfileStatusReq;	/* paypal.h:691 */
class _ns1__BillOutstandingAmountReq;	/* paypal.h:694 */
class _ns1__UpdateRecurringPaymentsProfileReq;	/* paypal.h:697 */
class _ns1__GetPalDetailsReq;	/* paypal.h:700 */
class _ns1__ReverseTransactionReq;	/* paypal.h:703 */
class _ns1__ExternalRememberMeOptOutReq;	/* paypal.h:706 */
class ns3__AccountEntryType;	/* paypal.h:721 */
class ns3__AdditionalAccountType;	/* paypal.h:724 */
class ns3__PromotedItemType;	/* paypal.h:727 */
class ns3__CrossPromotionsType;	/* paypal.h:730 */
union _ns3__union_AccountSummaryType;	/* paypal.h:7128 */
class __ns3__union_AccountSummaryType;	/* paypal.h:7037 */
class ns3__AccountSummaryType;	/* paypal.h:733 */
class ns3__BuyerType;	/* paypal.h:736 */
class ns3__SellerType;	/* paypal.h:739 */
class ns3__FeeType;	/* paypal.h:742 */
class ns3__FeesType;	/* paypal.h:745 */
class ns3__ShippingCarrierDetailsType;	/* paypal.h:748 */
class ns3__CalculatedShippingRateType;	/* paypal.h:751 */
class ns3__FlatShippingRateType;	/* paypal.h:754 */
class ns3__SalesTaxType;	/* paypal.h:757 */
class ns3__ShippingDetailsType;	/* paypal.h:760 */
class ns3__SiteHostedPictureType;	/* paypal.h:763 */
class ns3__VendorHostedPictureType;	/* paypal.h:766 */
class ns3__ValType;	/* paypal.h:769 */
class ns3__AttributeType;	/* paypal.h:772 */
class ns3__AttributeSetType;	/* paypal.h:775 */
class ns3__ListOfAttributeSetType;	/* paypal.h:778 */
class ns3__CategoryType;	/* paypal.h:781 */
class ns3__StorefrontType;	/* paypal.h:784 */
class ns3__ListingDesignerType;	/* paypal.h:787 */
class ns3__CharityType;	/* paypal.h:790 */
class ns3__SellingStatusType;	/* paypal.h:793 */
class ns3__ReviseStatusType;	/* paypal.h:796 */
class ns3__ListingDetailsType;	/* paypal.h:799 */
class ns3__ItemType;	/* paypal.h:802 */
class ns3__TransactionsType;	/* paypal.h:805 */
class ns3__TransactionType;	/* paypal.h:808 */
class ns3__PaymentMeansType;	/* paypal.h:811 */
class ns3__PaymentType;	/* paypal.h:814 */
class ns3__TransactionStatusType;	/* paypal.h:817 */
class ns3__UserType;	/* paypal.h:820 */
class ns3__VATDetailsType;	/* paypal.h:823 */
class ns3__SchedulingInfoType;	/* paypal.h:826 */
class ns3__ItemArrayType;	/* paypal.h:829 */
class ns3__CategoryArrayType;	/* paypal.h:832 */
class ns3__PaginationType;	/* paypal.h:835 */
class ns3__ModifiedFieldType;	/* paypal.h:838 */
class ns3__PaginationResultType;	/* paypal.h:841 */
class ns3__ErrorParameterType;	/* paypal.h:844 */
class ns3__ErrorType;	/* paypal.h:847 */
class ns3__FaultDetailsType;	/* paypal.h:850 */
class ns3__AbstractRequestType;	/* paypal.h:853 */
class ns3__AbstractResponseType;	/* paypal.h:856 */
class ns3__PhoneNumberType;	/* paypal.h:859 */
class ns3__AddressType;	/* paypal.h:862 */
class ns3__PersonNameType;	/* paypal.h:865 */
class ns3__IncentiveAppliedToType;	/* paypal.h:868 */
class ns3__IncentiveDetailType;	/* paypal.h:871 */
class ns3__IncentiveItemType;	/* paypal.h:874 */
class ns3__IncentiveBucketType;	/* paypal.h:877 */
class ns3__IncentiveRequestDetailsType;	/* paypal.h:880 */
class ns3__GetIncentiveEvaluationRequestDetailsType;	/* paypal.h:883 */
class ns3__GetIncentiveEvaluationResponseDetailsType;	/* paypal.h:886 */
class ns3__SetExpressCheckoutRequestDetailsType;	/* paypal.h:889 */
class ns3__ExecuteCheckoutOperationsRequestDetailsType;	/* paypal.h:892 */
class ns3__SetDataRequestType;	/* paypal.h:895 */
class ns3__AuthorizationRequestType;	/* paypal.h:898 */
class ns3__BillingApprovalDetailsType;	/* paypal.h:901 */
class ns3__InfoSharingDirectivesType;	/* paypal.h:904 */
class ns3__OrderDetailsType;	/* paypal.h:907 */
class ns3__PaymentDirectivesType;	/* paypal.h:910 */
class ns3__BuyerDetailType;	/* paypal.h:913 */
class ns3__IdentificationInfoType;	/* paypal.h:916 */
class ns3__MobileIDInfoType;	/* paypal.h:919 */
class ns3__RememberMeIDInfoType;	/* paypal.h:922 */
class ns3__IdentityTokenInfoType;	/* paypal.h:925 */
class ns3__FundingSourceDetailsType;	/* paypal.h:928 */
class ns3__BillingAgreementDetailsType;	/* paypal.h:931 */
class ns3__GetExpressCheckoutDetailsResponseDetailsType;	/* paypal.h:934 */
class ns3__ExecuteCheckoutOperationsResponseDetailsType;	/* paypal.h:937 */
class ns3__SetDataResponseType;	/* paypal.h:940 */
class ns3__AuthorizationResponseType;	/* paypal.h:943 */
class ns3__DoExpressCheckoutPaymentRequestDetailsType;	/* paypal.h:946 */
class ns3__DoExpressCheckoutPaymentResponseDetailsType;	/* paypal.h:949 */
class ns3__DoCaptureResponseDetailsType;	/* paypal.h:952 */
class ns3__DoDirectPaymentRequestDetailsType;	/* paypal.h:955 */
class ns3__CreateMobilePaymentRequestDetailsType;	/* paypal.h:958 */
class ns3__GetMobileStatusRequestDetailsType;	/* paypal.h:961 */
class ns3__SetAuthFlowParamRequestDetailsType;	/* paypal.h:964 */
class ns3__GetAuthDetailsResponseDetailsType;	/* paypal.h:967 */
class ns3__SetAccessPermissionsRequestDetailsType;	/* paypal.h:970 */
class ns3__GetAccessPermissionDetailsResponseDetailsType;	/* paypal.h:973 */
class ns3__BAUpdateResponseDetailsType;	/* paypal.h:976 */
class ns3__MerchantPullPaymentResponseType;	/* paypal.h:979 */
class ns3__MerchantPullInfoType;	/* paypal.h:982 */
class ns3__PaymentTransactionSearchResultType;	/* paypal.h:985 */
class ns3__ShippingInfoType;	/* paypal.h:988 */
class ns3__TaxInfoType;	/* paypal.h:991 */
class ns3__MerchantPullPaymentType;	/* paypal.h:994 */
class ns3__PaymentTransactionType;	/* paypal.h:997 */
class ns3__ReceiverInfoType;	/* paypal.h:1000 */
class ns3__PayerInfoType;	/* paypal.h:1003 */
class ns3__PayeeInfoType;	/* paypal.h:1006 */
class ns3__InstrumentDetailsType;	/* paypal.h:1009 */
class ns3__BMLOfferInfoType;	/* paypal.h:1012 */
class ns3__OfferDetailsType;	/* paypal.h:1015 */
class ns3__PaymentInfoType;	/* paypal.h:1018 */
class ns3__SubscriptionTermsType;	/* paypal.h:1021 */
class ns3__SubscriptionInfoType;	/* paypal.h:1024 */
class ns3__AuctionInfoType;	/* paypal.h:1027 */
class ns3__OptionType;	/* paypal.h:1030 */
class ns3__EbayItemPaymentDetailsItemType;	/* paypal.h:1033 */
class ns3__PaymentDetailsItemType;	/* paypal.h:1036 */
class ns3__PaymentItemType;	/* paypal.h:1039 */
class ns3__PaymentItemInfoType;	/* paypal.h:1042 */
class ns3__OfferCouponInfoType;	/* paypal.h:1045 */
class ns3__PaymentDetailsType;	/* paypal.h:1048 */
class ns3__IncentiveDetailsType;	/* paypal.h:1051 */
class ns3__IncentiveAppliedDetailsType;	/* paypal.h:1054 */
class ns3__SellerDetailsType;	/* paypal.h:1057 */
class ns3__OtherPaymentMethodDetailsType;	/* paypal.h:1060 */
class ns3__BuyerDetailsType;	/* paypal.h:1063 */
class ns3__TaxIdDetailsType;	/* paypal.h:1066 */
class ns3__ThreeDSecureRequestType;	/* paypal.h:1069 */
class ns3__ThreeDSecureResponseType;	/* paypal.h:1072 */
class ns3__ThreeDSecureInfoType;	/* paypal.h:1075 */
class ns3__CreditCardDetailsType;	/* paypal.h:1078 */
class ns3__ShippingOptionType;	/* paypal.h:1081 */
class ns3__UserSelectedOptionType;	/* paypal.h:1084 */
class ns3__CreditCardNumberTypeType;	/* paypal.h:1087 */
class ns3__ReferenceCreditCardDetailsType;	/* paypal.h:1090 */
class ns3__CustomSecurityHeaderType;	/* paypal.h:1093 */
class ns3__UserIdPasswordType;	/* paypal.h:1096 */
class ns3__SetCustomerBillingAgreementRequestDetailsType;	/* paypal.h:1099 */
class ns3__GetBillingAgreementCustomerDetailsResponseDetailsType;	/* paypal.h:1102 */
class ns3__DeviceDetailsType;	/* paypal.h:1105 */
class ns3__SenderDetailsType;	/* paypal.h:1108 */
class ns3__DoReferenceTransactionRequestDetailsType;	/* paypal.h:1111 */
class ns3__DoReferenceTransactionResponseDetailsType;	/* paypal.h:1114 */
class ns3__DoNonReferencedCreditRequestDetailsType;	/* paypal.h:1117 */
class ns3__DoNonReferencedCreditResponseDetailsType;	/* paypal.h:1120 */
class ns3__EnterBoardingRequestDetailsType;	/* paypal.h:1123 */
class ns3__BusinessInfoType;	/* paypal.h:1126 */
class ns3__BusinessOwnerInfoType;	/* paypal.h:1129 */
class ns3__BankAccountDetailsType;	/* paypal.h:1132 */
class ns3__GetBoardingDetailsResponseDetailsType;	/* paypal.h:1135 */
class ns3__APICredentialsType;	/* paypal.h:1138 */
class ns3__SetMobileCheckoutRequestDetailsType;	/* paypal.h:1141 */
class ns3__DoMobileCheckoutPaymentResponseDetailsType;	/* paypal.h:1144 */
class ns3__SetEbayMobileCheckoutRequestDetailsType;	/* paypal.h:1147 */
class ns3__UATPDetailsType;	/* paypal.h:1150 */
class ns3__RecurringPaymentsSummaryType;	/* paypal.h:1153 */
class ns3__ActivationDetailsType;	/* paypal.h:1156 */
class ns3__BillingPeriodDetailsType;	/* paypal.h:1159 */
class ns3__BillingPeriodDetailsType_USCOREUpdate;	/* paypal.h:1162 */
class ns3__ScheduleDetailsType;	/* paypal.h:1165 */
class ns3__RecurringPaymentsProfileDetailsType;	/* paypal.h:1168 */
class ns3__CreateRecurringPaymentsProfileRequestDetailsType;	/* paypal.h:1171 */
class ns3__CreateRecurringPaymentsProfileResponseDetailsType;	/* paypal.h:1174 */
class ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType;	/* paypal.h:1177 */
class ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType;	/* paypal.h:1180 */
class ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType;	/* paypal.h:1183 */
class ns3__BillOutstandingAmountRequestDetailsType;	/* paypal.h:1186 */
class ns3__BillOutstandingAmountResponseDetailsType;	/* paypal.h:1189 */
class ns3__UpdateRecurringPaymentsProfileRequestDetailsType;	/* paypal.h:1192 */
class ns3__UpdateRecurringPaymentsProfileResponseDetailsType;	/* paypal.h:1195 */
class ns3__RiskFilterDetailsType;	/* paypal.h:1198 */
class ns3__RiskFilterListType;	/* paypal.h:1201 */
class ns3__FMFDetailsType;	/* paypal.h:1204 */
class ns3__EnhancedDataType;	/* paypal.h:1207 */
class ns3__AirlineItineraryType;	/* paypal.h:1210 */
class ns3__FlightDetailsType;	/* paypal.h:1213 */
class ns3__AuthorizationInfoType;	/* paypal.h:1216 */
class ns3__OptionTrackingDetailsType;	/* paypal.h:1219 */
class ns3__ItemTrackingDetailsType;	/* paypal.h:1222 */
class ns3__ButtonSearchResultType;	/* paypal.h:1225 */
class ns3__ReverseTransactionRequestDetailsType;	/* paypal.h:1228 */
class ns3__ReverseTransactionResponseDetailsType;	/* paypal.h:1231 */
class ns3__IncentiveInfoType;	/* paypal.h:1234 */
class ns3__IncentiveApplyIndicationType;	/* paypal.h:1237 */
class ns3__PaymentRequestInfoType;	/* paypal.h:1240 */
class ns3__ExternalRememberMeOwnerDetailsType;	/* paypal.h:1243 */
class ns3__ExternalRememberMeOptInDetailsType;	/* paypal.h:1246 */
class ns3__FlowControlDetailsType;	/* paypal.h:1249 */
class ns3__ExternalRememberMeStatusDetailsType;	/* paypal.h:1252 */
class ns3__RefreshTokenStatusDetailsType;	/* paypal.h:1255 */
class ns3__DisplayControlDetailsType;	/* paypal.h:1258 */
class ns3__ExternalPartnerTrackingDetailsType;	/* paypal.h:1261 */
class ns3__MerchantStoreDetailsType;	/* paypal.h:1264 */
class ns3__AdditionalFeeType;	/* paypal.h:1267 */
class ns3__DiscountType;	/* paypal.h:1270 */
class ns3__InvoiceItemType;	/* paypal.h:1273 */
class ns3__RefundInfoType;	/* paypal.h:1276 */
class ns3__CoupledBucketsType;	/* paypal.h:1279 */
class ns3__CoupledPaymentInfoType;	/* paypal.h:1282 */
class ns3__TupleType;	/* paypal.h:1285 */
class ns3__MerchantDataType;	/* paypal.h:1288 */
class ns3__WalletItemsType;	/* paypal.h:1291 */
class ns3__DiscountInfoType;	/* paypal.h:1294 */
class ns4__EnhancedCheckoutDataType;	/* paypal.h:1297 */
class ns4__EnhancedPaymentDataType;	/* paypal.h:1300 */
class ns4__EnhancedPaymentInfoType;	/* paypal.h:1303 */
class ns4__EnhancedItemDataType;	/* paypal.h:1306 */
class ns4__EnhancedInitiateRecoupRequestDetailsType;	/* paypal.h:1309 */
class ns4__EnhancedCompleteRecoupRequestDetailsType;	/* paypal.h:1312 */
class ns4__EnhancedCompleteRecoupResponseDetailsType;	/* paypal.h:1315 */
class ns4__EnhancedCancelRecoupRequestDetailsType;	/* paypal.h:1318 */
class ns4__EnhancedPayerInfoType;	/* paypal.h:1321 */
class ns1__BMCreateButtonRequestType;	/* paypal.h:193 */
class ns1__BMCreateButtonResponseType;	/* paypal.h:196 */
class ns1__BMUpdateButtonRequestType;	/* paypal.h:199 */
class ns1__BMUpdateButtonResponseType;	/* paypal.h:202 */
class ns1__BMManageButtonStatusRequestType;	/* paypal.h:205 */
class ns1__BMManageButtonStatusResponseType;	/* paypal.h:208 */
class ns1__BMGetButtonDetailsRequestType;	/* paypal.h:211 */
class ns1__BMGetButtonDetailsResponseType;	/* paypal.h:214 */
class ns1__BMSetInventoryRequestType;	/* paypal.h:217 */
class ns1__BMSetInventoryResponseType;	/* paypal.h:220 */
class ns1__BMGetInventoryRequestType;	/* paypal.h:223 */
class ns1__BMGetInventoryResponseType;	/* paypal.h:226 */
class ns1__BMButtonSearchRequestType;	/* paypal.h:229 */
class ns1__BMButtonSearchResponseType;	/* paypal.h:232 */
class ns1__RefundTransactionRequestType;	/* paypal.h:235 */
class ns1__RefundTransactionResponseType;	/* paypal.h:238 */
class ns1__InitiateRecoupRequestType;	/* paypal.h:241 */
class ns1__InitiateRecoupResponseType;	/* paypal.h:244 */
class ns1__CompleteRecoupRequestType;	/* paypal.h:247 */
class ns1__CompleteRecoupResponseType;	/* paypal.h:250 */
class ns1__CancelRecoupRequestType;	/* paypal.h:253 */
class ns1__CancelRecoupResponseType;	/* paypal.h:256 */
class ns1__GetTransactionDetailsRequestType;	/* paypal.h:259 */
class ns1__GetTransactionDetailsResponseType;	/* paypal.h:262 */
class ns1__BillUserRequestType;	/* paypal.h:265 */
class ns1__BillUserResponseType;	/* paypal.h:268 */
class ns1__TransactionSearchRequestType;	/* paypal.h:271 */
class ns1__TransactionSearchResponseType;	/* paypal.h:274 */
class ns1__MassPayRequestType;	/* paypal.h:277 */
class ns1__MassPayResponseType;	/* paypal.h:280 */
class ns1__BAUpdateRequestType;	/* paypal.h:286 */
class ns1__BAUpdateResponseType;	/* paypal.h:289 */
class ns1__AddressVerifyRequestType;	/* paypal.h:292 */
class ns1__AddressVerifyResponseType;	/* paypal.h:295 */
class ns1__EnterBoardingRequestType;	/* paypal.h:298 */
class ns1__EnterBoardingResponseType;	/* paypal.h:301 */
class ns1__GetBoardingDetailsRequestType;	/* paypal.h:304 */
class ns1__GetBoardingDetailsResponseType;	/* paypal.h:307 */
class ns1__SetAuthFlowParamRequestType;	/* paypal.h:310 */
class ns1__SetAuthFlowParamResponseType;	/* paypal.h:313 */
class ns1__GetAuthDetailsRequestType;	/* paypal.h:316 */
class ns1__GetAuthDetailsResponseType;	/* paypal.h:319 */
class ns1__SetAccessPermissionsRequestType;	/* paypal.h:322 */
class ns1__SetAccessPermissionsResponseType;	/* paypal.h:325 */
class ns1__UpdateAccessPermissionsRequestType;	/* paypal.h:328 */
class ns1__UpdateAccessPermissionsResponseType;	/* paypal.h:331 */
class ns1__GetAccessPermissionDetailsRequestType;	/* paypal.h:334 */
class ns1__GetAccessPermissionDetailsResponseType;	/* paypal.h:337 */
class ns1__GetIncentiveEvaluationRequestType;	/* paypal.h:340 */
class ns1__GetIncentiveEvaluationResponseType;	/* paypal.h:343 */
class ns1__SetExpressCheckoutRequestType;	/* paypal.h:346 */
class ns1__SetExpressCheckoutResponseType;	/* paypal.h:349 */
class ns1__ExecuteCheckoutOperationsRequestType;	/* paypal.h:352 */
class ns1__ExecuteCheckoutOperationsResponseType;	/* paypal.h:355 */
class ns1__GetExpressCheckoutDetailsRequestType;	/* paypal.h:358 */
class ns1__GetExpressCheckoutDetailsResponseType;	/* paypal.h:361 */
class ns1__DoExpressCheckoutPaymentRequestType;	/* paypal.h:364 */
class ns1__DoExpressCheckoutPaymentResponseType;	/* paypal.h:367 */
class ns1__ManagePendingTransactionStatusRequestType;	/* paypal.h:376 */
class ns1__ManagePendingTransactionStatusResponseType;	/* paypal.h:379 */
class ns1__DoDirectPaymentRequestType;	/* paypal.h:382 */
class ns1__DoDirectPaymentResponseType;	/* paypal.h:385 */
class ns1__DoCancelRequestType;	/* paypal.h:388 */
class ns1__DoCancelResponseType;	/* paypal.h:391 */
class ns1__DoCaptureRequestType;	/* paypal.h:394 */
class ns1__DoCaptureResponseType;	/* paypal.h:397 */
class ns1__DoReauthorizationRequestType;	/* paypal.h:400 */
class ns1__DoReauthorizationResponseType;	/* paypal.h:403 */
class ns1__DoVoidRequestType;	/* paypal.h:406 */
class ns1__DoVoidResponseType;	/* paypal.h:409 */
class ns1__DoAuthorizationRequestType;	/* paypal.h:412 */
class ns1__DoAuthorizationResponseType;	/* paypal.h:415 */
class ns1__UpdateAuthorizationRequestType;	/* paypal.h:418 */
class ns1__UpdateAuthorizationResponseType;	/* paypal.h:421 */
class ns1__DoUATPAuthorizationRequestType;	/* paypal.h:424 */
class ns1__CreateMobilePaymentRequestType;	/* paypal.h:430 */
class ns1__CreateMobilePaymentResponseType;	/* paypal.h:433 */
class ns1__GetMobileStatusRequestType;	/* paypal.h:436 */
class ns1__GetMobileStatusResponseType;	/* paypal.h:439 */
class ns1__SetMobileCheckoutRequestType;	/* paypal.h:442 */
class ns1__SetMobileCheckoutResponseType;	/* paypal.h:445 */
class ns1__DoMobileCheckoutPaymentRequestType;	/* paypal.h:448 */
class ns1__DoMobileCheckoutPaymentResponseType;	/* paypal.h:451 */
class ns1__GetBalanceRequestType;	/* paypal.h:454 */
class ns1__GetBalanceResponseType;	/* paypal.h:457 */
class ns1__SetCustomerBillingAgreementRequestType;	/* paypal.h:460 */
class ns1__SetCustomerBillingAgreementResponseType;	/* paypal.h:463 */
class ns1__GetBillingAgreementCustomerDetailsRequestType;	/* paypal.h:466 */
class ns1__GetBillingAgreementCustomerDetailsResponseType;	/* paypal.h:469 */
class ns1__CreateBillingAgreementRequestType;	/* paypal.h:472 */
class ns1__CreateBillingAgreementResponseType;	/* paypal.h:475 */
class ns1__DoReferenceTransactionRequestType;	/* paypal.h:478 */
class ns1__DoReferenceTransactionResponseType;	/* paypal.h:481 */
class ns1__DoNonReferencedCreditRequestType;	/* paypal.h:484 */
class ns1__DoNonReferencedCreditResponseType;	/* paypal.h:487 */
class ns1__CreateRecurringPaymentsProfileRequestType;	/* paypal.h:490 */
class ns1__CreateRecurringPaymentsProfileResponseType;	/* paypal.h:493 */
class ns1__GetRecurringPaymentsProfileDetailsRequestType;	/* paypal.h:496 */
class ns1__GetRecurringPaymentsProfileDetailsResponseType;	/* paypal.h:499 */
class ns1__ManageRecurringPaymentsProfileStatusRequestType;	/* paypal.h:502 */
class ns1__ManageRecurringPaymentsProfileStatusResponseType;	/* paypal.h:505 */
class ns1__BillOutstandingAmountRequestType;	/* paypal.h:508 */
class ns1__BillOutstandingAmountResponseType;	/* paypal.h:511 */
class ns1__UpdateRecurringPaymentsProfileRequestType;	/* paypal.h:514 */
class ns1__UpdateRecurringPaymentsProfileResponseType;	/* paypal.h:517 */
class ns1__GetPalDetailsRequestType;	/* paypal.h:520 */
class ns1__GetPalDetailsResponseType;	/* paypal.h:523 */
class ns1__ReverseTransactionRequestType;	/* paypal.h:526 */
class ns1__ReverseTransactionResponseType;	/* paypal.h:529 */
class ns1__ExternalRememberMeOptOutRequestType;	/* paypal.h:532 */
class ns1__ExternalRememberMeOptOutResponseType;	/* paypal.h:535 */
class ns2__AmountType;	/* paypal.h:709 */
class ns2__BasicAmountType;	/* paypal.h:712 */
class ns2__MeasureType;	/* paypal.h:715 */
class ns2__QuantityType;	/* paypal.h:718 */
class ns1__DoUATPExpressCheckoutPaymentRequestType;	/* paypal.h:370 */
class ns1__DoUATPExpressCheckoutPaymentResponseType;	/* paypal.h:373 */
class ns1__DoUATPAuthorizationResponseType;	/* paypal.h:427 */
struct __ns1__RefundTransaction;	/* paypal.h:26324 */
struct __ns1__InitiateRecoup;	/* paypal.h:26400 */
struct __ns1__CompleteRecoup;	/* paypal.h:26476 */
struct __ns1__CancelRecoup;	/* paypal.h:26552 */
struct __ns1__GetTransactionDetails;	/* paypal.h:26628 */
struct __ns1__BMCreateButton;	/* paypal.h:26704 */
struct __ns1__BMUpdateButton;	/* paypal.h:26780 */
struct __ns1__BMSetInventory;	/* paypal.h:26856 */
struct __ns1__BMGetButtonDetails;	/* paypal.h:26932 */
struct __ns1__BMGetInventory;	/* paypal.h:27008 */
struct __ns1__BMManageButtonStatus;	/* paypal.h:27084 */
struct __ns1__BMButtonSearch;	/* paypal.h:27160 */
struct __ns1__BillUser;	/* paypal.h:27236 */
struct __ns1__TransactionSearch;	/* paypal.h:27312 */
struct __ns1__MassPay;	/* paypal.h:27388 */
struct __ns1__BillAgreementUpdate;	/* paypal.h:27464 */
struct __ns1__AddressVerify;	/* paypal.h:27540 */
struct __ns1__EnterBoarding;	/* paypal.h:27616 */
struct __ns1__GetBoardingDetails;	/* paypal.h:27692 */
struct __ns1__CreateMobilePayment;	/* paypal.h:27768 */
struct __ns1__GetMobileStatus;	/* paypal.h:27844 */
struct __ns1__SetMobileCheckout;	/* paypal.h:27920 */
struct __ns1__DoMobileCheckoutPayment;	/* paypal.h:27996 */
struct __ns1__GetBalance;	/* paypal.h:28072 */
struct __ns1__GetPalDetails;	/* paypal.h:28148 */
struct __ns1__DoExpressCheckoutPayment;	/* paypal.h:28224 */
struct __ns1__DoUATPExpressCheckoutPayment;	/* paypal.h:28300 */
struct __ns1__SetAuthFlowParam;	/* paypal.h:28376 */
struct __ns1__GetAuthDetails;	/* paypal.h:28452 */
struct __ns1__SetAccessPermissions;	/* paypal.h:28528 */
struct __ns1__UpdateAccessPermissions;	/* paypal.h:28604 */
struct __ns1__GetAccessPermissionDetails;	/* paypal.h:28680 */
struct __ns1__GetIncentiveEvaluation;	/* paypal.h:28756 */
struct __ns1__SetExpressCheckout;	/* paypal.h:28832 */
struct __ns1__ExecuteCheckoutOperations;	/* paypal.h:28908 */
struct __ns1__GetExpressCheckoutDetails;	/* paypal.h:28984 */
struct __ns1__DoDirectPayment;	/* paypal.h:29060 */
struct __ns1__ManagePendingTransactionStatus;	/* paypal.h:29136 */
struct __ns1__DoCancel;	/* paypal.h:29212 */
struct __ns1__DoCapture;	/* paypal.h:29288 */
struct __ns1__DoReauthorization;	/* paypal.h:29364 */
struct __ns1__DoVoid;	/* paypal.h:29440 */
struct __ns1__DoAuthorization;	/* paypal.h:29516 */
struct __ns1__UpdateAuthorization;	/* paypal.h:29592 */
struct __ns1__DoUATPAuthorization;	/* paypal.h:29668 */
struct __ns1__SetCustomerBillingAgreement;	/* paypal.h:29744 */
struct __ns1__GetBillingAgreementCustomerDetails;	/* paypal.h:29820 */
struct __ns1__CreateBillingAgreement;	/* paypal.h:29896 */
struct __ns1__DoReferenceTransaction;	/* paypal.h:29972 */
struct __ns1__CreateRecurringPaymentsProfile;	/* paypal.h:30048 */
struct __ns1__GetRecurringPaymentsProfileDetails;	/* paypal.h:30124 */
struct __ns1__ManageRecurringPaymentsProfileStatus;	/* paypal.h:30200 */
struct __ns1__BillOutstandingAmount;	/* paypal.h:30276 */
struct __ns1__UpdateRecurringPaymentsProfile;	/* paypal.h:30352 */
struct __ns1__DoNonReferencedCredit;	/* paypal.h:30428 */
struct __ns1__ReverseTransaction;	/* paypal.h:30504 */
struct __ns1__ExternalRememberMeOptOut;	/* paypal.h:30580 */

/* paypal.h:184 */
#ifndef SOAP_TYPE_ns1__InstallmentDetailsType
#define SOAP_TYPE_ns1__InstallmentDetailsType (16)
/* complex XSD type 'ns1:InstallmentDetailsType': */
class SOAP_CMAC ns1__InstallmentDetailsType {
      public:
        /// Optional element 'ns1:BillingPeriod' of XSD type 'ns3:BillingPeriodType'
        enum ns3__BillingPeriodType *BillingPeriod;
        /// Optional element 'ns1:BillingFrequency' of XSD type 'xsd:int'
        int *BillingFrequency;
        /// Optional element 'ns1:TotalBillingCycles' of XSD type 'xsd:int'
        int *TotalBillingCycles;
        /// Optional element 'ns1:Amount' of XSD type 'xsd:string'
        std::string *Amount;
        /// Optional element 'ns1:ShippingAmount' of XSD type 'xsd:string'
        std::string *ShippingAmount;
        /// Optional element 'ns1:TaxAmount' of XSD type 'xsd:string'
        std::string *TaxAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InstallmentDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InstallmentDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InstallmentDetailsType, default initialized and not managed by a soap context
        virtual ns1__InstallmentDetailsType *soap_alloc(void) const { return SOAP_NEW(ns1__InstallmentDetailsType); }
      public:
        /// Constructor with initializations
        ns1__InstallmentDetailsType() : BillingPeriod(), BillingFrequency(), TotalBillingCycles(), Amount(), ShippingAmount(), TaxAmount(), soap() { }
        virtual ~ns1__InstallmentDetailsType() { }
        /// Friend allocator used by soap_new_ns1__InstallmentDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InstallmentDetailsType * SOAP_FMAC2 soap_instantiate_ns1__InstallmentDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:187 */
#ifndef SOAP_TYPE_ns1__OptionSelectionDetailsType
#define SOAP_TYPE_ns1__OptionSelectionDetailsType (17)
/* complex XSD type 'ns1:OptionSelectionDetailsType': */
class SOAP_CMAC ns1__OptionSelectionDetailsType {
      public:
        /// Required element 'ns1:OptionSelection' of XSD type 'xsd:string'
        std::string OptionSelection;
        /// Optional element 'ns1:Price' of XSD type 'xsd:string'
        std::string *Price;
        /// Optional element 'ns1:OptionType' of XSD type 'ns3:OptionTypeListType'
        enum ns3__OptionTypeListType *OptionType;
        /// Sequence of 0 to 10 elements 'ns1:PaymentPeriod' of XSD type 'ns1:InstallmentDetailsType'
        std::vector<ns1__InstallmentDetailsType *> PaymentPeriod;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OptionSelectionDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OptionSelectionDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OptionSelectionDetailsType, default initialized and not managed by a soap context
        virtual ns1__OptionSelectionDetailsType *soap_alloc(void) const { return SOAP_NEW(ns1__OptionSelectionDetailsType); }
      public:
        /// Constructor with initializations
        ns1__OptionSelectionDetailsType() : OptionSelection(), Price(), OptionType(), PaymentPeriod(), soap() { }
        virtual ~ns1__OptionSelectionDetailsType() { }
        /// Friend allocator used by soap_new_ns1__OptionSelectionDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OptionSelectionDetailsType * SOAP_FMAC2 soap_instantiate_ns1__OptionSelectionDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:190 */
#ifndef SOAP_TYPE_ns1__OptionDetailsType
#define SOAP_TYPE_ns1__OptionDetailsType (18)
/* complex XSD type 'ns1:OptionDetailsType': */
class SOAP_CMAC ns1__OptionDetailsType {
      public:
        /// Required element 'ns1:OptionName' of XSD type 'xsd:string'
        std::string OptionName;
        /// Sequence of 0 to 100 elements 'ns1:OptionSelectionDetails' of XSD type 'ns1:OptionSelectionDetailsType'
        std::vector<ns1__OptionSelectionDetailsType *> OptionSelectionDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OptionDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OptionDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OptionDetailsType, default initialized and not managed by a soap context
        virtual ns1__OptionDetailsType *soap_alloc(void) const { return SOAP_NEW(ns1__OptionDetailsType); }
      public:
        /// Constructor with initializations
        ns1__OptionDetailsType() : OptionName(), OptionSelectionDetails(), soap() { }
        virtual ~ns1__OptionDetailsType() { }
        /// Friend allocator used by soap_new_ns1__OptionDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OptionDetailsType * SOAP_FMAC2 soap_instantiate_ns1__OptionDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:283 */
#ifndef SOAP_TYPE_ns1__MassPayRequestItemType
#define SOAP_TYPE_ns1__MassPayRequestItemType (49)
/* complex XSD type 'ns1:MassPayRequestItemType': */
class SOAP_CMAC ns1__MassPayRequestItemType {
      public:
        /// Optional element 'ns1:ReceiverEmail' of XSD type 'ns3:EmailAddressType'
        std::string *ReceiverEmail;
        /// Optional element 'ns1:ReceiverPhone' of XSD type 'xsd:string'
        std::string *ReceiverPhone;
        /// Optional element 'ns1:ReceiverID' of XSD type 'ns3:UserIDType'
        std::string *ReceiverID;
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns1:UniqueId' of XSD type 'xsd:string'
        std::string *UniqueId;
        /// Optional element 'ns1:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MassPayRequestItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MassPayRequestItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MassPayRequestItemType, default initialized and not managed by a soap context
        virtual ns1__MassPayRequestItemType *soap_alloc(void) const { return SOAP_NEW(ns1__MassPayRequestItemType); }
      public:
        /// Constructor with initializations
        ns1__MassPayRequestItemType() : ReceiverEmail(), ReceiverPhone(), ReceiverID(), Amount(), UniqueId(), Note(), soap() { }
        virtual ~ns1__MassPayRequestItemType() { }
        /// Friend allocator used by soap_new_ns1__MassPayRequestItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MassPayRequestItemType * SOAP_FMAC2 soap_instantiate_ns1__MassPayRequestItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:538 */
#ifndef SOAP_TYPE__ns1__BMCreateButtonReq
#define SOAP_TYPE__ns1__BMCreateButtonReq (134)
/* complex XSD type 'ns1:BMCreateButtonReq': */
class SOAP_CMAC _ns1__BMCreateButtonReq {
      public:
        /// Required element 'ns1:BMCreateButtonRequest' of XSD type 'ns1:BMCreateButtonRequestType'
        ns1__BMCreateButtonRequestType *BMCreateButtonRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMCreateButtonReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMCreateButtonReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMCreateButtonReq, default initialized and not managed by a soap context
        virtual _ns1__BMCreateButtonReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMCreateButtonReq); }
      public:
        /// Constructor with initializations
        _ns1__BMCreateButtonReq() : BMCreateButtonRequest(), soap() { }
        virtual ~_ns1__BMCreateButtonReq() { }
        /// Friend allocator used by soap_new__ns1__BMCreateButtonReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMCreateButtonReq * SOAP_FMAC2 soap_instantiate__ns1__BMCreateButtonReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:541 */
#ifndef SOAP_TYPE__ns1__BMUpdateButtonReq
#define SOAP_TYPE__ns1__BMUpdateButtonReq (135)
/* complex XSD type 'ns1:BMUpdateButtonReq': */
class SOAP_CMAC _ns1__BMUpdateButtonReq {
      public:
        /// Required element 'ns1:BMUpdateButtonRequest' of XSD type 'ns1:BMUpdateButtonRequestType'
        ns1__BMUpdateButtonRequestType *BMUpdateButtonRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMUpdateButtonReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMUpdateButtonReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMUpdateButtonReq, default initialized and not managed by a soap context
        virtual _ns1__BMUpdateButtonReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMUpdateButtonReq); }
      public:
        /// Constructor with initializations
        _ns1__BMUpdateButtonReq() : BMUpdateButtonRequest(), soap() { }
        virtual ~_ns1__BMUpdateButtonReq() { }
        /// Friend allocator used by soap_new__ns1__BMUpdateButtonReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMUpdateButtonReq * SOAP_FMAC2 soap_instantiate__ns1__BMUpdateButtonReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:544 */
#ifndef SOAP_TYPE__ns1__BMManageButtonStatusReq
#define SOAP_TYPE__ns1__BMManageButtonStatusReq (136)
/* complex XSD type 'ns1:BMManageButtonStatusReq': */
class SOAP_CMAC _ns1__BMManageButtonStatusReq {
      public:
        /// Required element 'ns1:BMManageButtonStatusRequest' of XSD type 'ns1:BMManageButtonStatusRequestType'
        ns1__BMManageButtonStatusRequestType *BMManageButtonStatusRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMManageButtonStatusReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMManageButtonStatusReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMManageButtonStatusReq, default initialized and not managed by a soap context
        virtual _ns1__BMManageButtonStatusReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMManageButtonStatusReq); }
      public:
        /// Constructor with initializations
        _ns1__BMManageButtonStatusReq() : BMManageButtonStatusRequest(), soap() { }
        virtual ~_ns1__BMManageButtonStatusReq() { }
        /// Friend allocator used by soap_new__ns1__BMManageButtonStatusReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMManageButtonStatusReq * SOAP_FMAC2 soap_instantiate__ns1__BMManageButtonStatusReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:547 */
#ifndef SOAP_TYPE__ns1__BMGetButtonDetailsReq
#define SOAP_TYPE__ns1__BMGetButtonDetailsReq (137)
/* complex XSD type 'ns1:BMGetButtonDetailsReq': */
class SOAP_CMAC _ns1__BMGetButtonDetailsReq {
      public:
        /// Required element 'ns1:BMGetButtonDetailsRequest' of XSD type 'ns1:BMGetButtonDetailsRequestType'
        ns1__BMGetButtonDetailsRequestType *BMGetButtonDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMGetButtonDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMGetButtonDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMGetButtonDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__BMGetButtonDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMGetButtonDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__BMGetButtonDetailsReq() : BMGetButtonDetailsRequest(), soap() { }
        virtual ~_ns1__BMGetButtonDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__BMGetButtonDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMGetButtonDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__BMGetButtonDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:550 */
#ifndef SOAP_TYPE__ns1__BMSetInventoryReq
#define SOAP_TYPE__ns1__BMSetInventoryReq (138)
/* complex XSD type 'ns1:BMSetInventoryReq': */
class SOAP_CMAC _ns1__BMSetInventoryReq {
      public:
        /// Required element 'ns1:BMSetInventoryRequest' of XSD type 'ns1:BMSetInventoryRequestType'
        ns1__BMSetInventoryRequestType *BMSetInventoryRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMSetInventoryReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMSetInventoryReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMSetInventoryReq, default initialized and not managed by a soap context
        virtual _ns1__BMSetInventoryReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMSetInventoryReq); }
      public:
        /// Constructor with initializations
        _ns1__BMSetInventoryReq() : BMSetInventoryRequest(), soap() { }
        virtual ~_ns1__BMSetInventoryReq() { }
        /// Friend allocator used by soap_new__ns1__BMSetInventoryReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMSetInventoryReq * SOAP_FMAC2 soap_instantiate__ns1__BMSetInventoryReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:553 */
#ifndef SOAP_TYPE__ns1__BMGetInventoryReq
#define SOAP_TYPE__ns1__BMGetInventoryReq (139)
/* complex XSD type 'ns1:BMGetInventoryReq': */
class SOAP_CMAC _ns1__BMGetInventoryReq {
      public:
        /// Required element 'ns1:BMGetInventoryRequest' of XSD type 'ns1:BMGetInventoryRequestType'
        ns1__BMGetInventoryRequestType *BMGetInventoryRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMGetInventoryReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMGetInventoryReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMGetInventoryReq, default initialized and not managed by a soap context
        virtual _ns1__BMGetInventoryReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMGetInventoryReq); }
      public:
        /// Constructor with initializations
        _ns1__BMGetInventoryReq() : BMGetInventoryRequest(), soap() { }
        virtual ~_ns1__BMGetInventoryReq() { }
        /// Friend allocator used by soap_new__ns1__BMGetInventoryReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMGetInventoryReq * SOAP_FMAC2 soap_instantiate__ns1__BMGetInventoryReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:556 */
#ifndef SOAP_TYPE__ns1__BMButtonSearchReq
#define SOAP_TYPE__ns1__BMButtonSearchReq (140)
/* complex XSD type 'ns1:BMButtonSearchReq': */
class SOAP_CMAC _ns1__BMButtonSearchReq {
      public:
        /// Required element 'ns1:BMButtonSearchRequest' of XSD type 'ns1:BMButtonSearchRequestType'
        ns1__BMButtonSearchRequestType *BMButtonSearchRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BMButtonSearchReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BMButtonSearchReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BMButtonSearchReq, default initialized and not managed by a soap context
        virtual _ns1__BMButtonSearchReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BMButtonSearchReq); }
      public:
        /// Constructor with initializations
        _ns1__BMButtonSearchReq() : BMButtonSearchRequest(), soap() { }
        virtual ~_ns1__BMButtonSearchReq() { }
        /// Friend allocator used by soap_new__ns1__BMButtonSearchReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BMButtonSearchReq * SOAP_FMAC2 soap_instantiate__ns1__BMButtonSearchReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:559 */
#ifndef SOAP_TYPE__ns1__RefundTransactionReq
#define SOAP_TYPE__ns1__RefundTransactionReq (141)
/* complex XSD type 'ns1:RefundTransactionReq': */
class SOAP_CMAC _ns1__RefundTransactionReq {
      public:
        /// Required element 'ns1:RefundTransactionRequest' of XSD type 'ns1:RefundTransactionRequestType'
        ns1__RefundTransactionRequestType *RefundTransactionRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RefundTransactionReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RefundTransactionReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RefundTransactionReq, default initialized and not managed by a soap context
        virtual _ns1__RefundTransactionReq *soap_alloc(void) const { return SOAP_NEW(_ns1__RefundTransactionReq); }
      public:
        /// Constructor with initializations
        _ns1__RefundTransactionReq() : RefundTransactionRequest(), soap() { }
        virtual ~_ns1__RefundTransactionReq() { }
        /// Friend allocator used by soap_new__ns1__RefundTransactionReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RefundTransactionReq * SOAP_FMAC2 soap_instantiate__ns1__RefundTransactionReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:562 */
#ifndef SOAP_TYPE__ns1__InitiateRecoupReq
#define SOAP_TYPE__ns1__InitiateRecoupReq (142)
/* complex XSD type 'ns1:InitiateRecoupReq': */
class SOAP_CMAC _ns1__InitiateRecoupReq {
      public:
        /// Required element 'ns1:InitiateRecoupRequest' of XSD type 'ns1:InitiateRecoupRequestType'
        ns1__InitiateRecoupRequestType *InitiateRecoupRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InitiateRecoupReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InitiateRecoupReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InitiateRecoupReq, default initialized and not managed by a soap context
        virtual _ns1__InitiateRecoupReq *soap_alloc(void) const { return SOAP_NEW(_ns1__InitiateRecoupReq); }
      public:
        /// Constructor with initializations
        _ns1__InitiateRecoupReq() : InitiateRecoupRequest(), soap() { }
        virtual ~_ns1__InitiateRecoupReq() { }
        /// Friend allocator used by soap_new__ns1__InitiateRecoupReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InitiateRecoupReq * SOAP_FMAC2 soap_instantiate__ns1__InitiateRecoupReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:565 */
#ifndef SOAP_TYPE__ns1__CompleteRecoupReq
#define SOAP_TYPE__ns1__CompleteRecoupReq (143)
/* complex XSD type 'ns1:CompleteRecoupReq': */
class SOAP_CMAC _ns1__CompleteRecoupReq {
      public:
        /// Required element 'ns1:CompleteRecoupRequest' of XSD type 'ns1:CompleteRecoupRequestType'
        ns1__CompleteRecoupRequestType *CompleteRecoupRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CompleteRecoupReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CompleteRecoupReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CompleteRecoupReq, default initialized and not managed by a soap context
        virtual _ns1__CompleteRecoupReq *soap_alloc(void) const { return SOAP_NEW(_ns1__CompleteRecoupReq); }
      public:
        /// Constructor with initializations
        _ns1__CompleteRecoupReq() : CompleteRecoupRequest(), soap() { }
        virtual ~_ns1__CompleteRecoupReq() { }
        /// Friend allocator used by soap_new__ns1__CompleteRecoupReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CompleteRecoupReq * SOAP_FMAC2 soap_instantiate__ns1__CompleteRecoupReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:568 */
#ifndef SOAP_TYPE__ns1__CancelRecoupReq
#define SOAP_TYPE__ns1__CancelRecoupReq (144)
/* complex XSD type 'ns1:CancelRecoupReq': */
class SOAP_CMAC _ns1__CancelRecoupReq {
      public:
        /// Required element 'ns1:CancelRecoupRequest' of XSD type 'ns1:CancelRecoupRequestType'
        ns1__CancelRecoupRequestType *CancelRecoupRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelRecoupReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelRecoupReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelRecoupReq, default initialized and not managed by a soap context
        virtual _ns1__CancelRecoupReq *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelRecoupReq); }
      public:
        /// Constructor with initializations
        _ns1__CancelRecoupReq() : CancelRecoupRequest(), soap() { }
        virtual ~_ns1__CancelRecoupReq() { }
        /// Friend allocator used by soap_new__ns1__CancelRecoupReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelRecoupReq * SOAP_FMAC2 soap_instantiate__ns1__CancelRecoupReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:571 */
#ifndef SOAP_TYPE__ns1__GetTransactionDetailsReq
#define SOAP_TYPE__ns1__GetTransactionDetailsReq (145)
/* complex XSD type 'ns1:GetTransactionDetailsReq': */
class SOAP_CMAC _ns1__GetTransactionDetailsReq {
      public:
        /// Required element 'ns1:GetTransactionDetailsRequest' of XSD type 'ns1:GetTransactionDetailsRequestType'
        ns1__GetTransactionDetailsRequestType *GetTransactionDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTransactionDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTransactionDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTransactionDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetTransactionDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTransactionDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetTransactionDetailsReq() : GetTransactionDetailsRequest(), soap() { }
        virtual ~_ns1__GetTransactionDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetTransactionDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTransactionDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetTransactionDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:574 */
#ifndef SOAP_TYPE__ns1__BillUserReq
#define SOAP_TYPE__ns1__BillUserReq (146)
/* complex XSD type 'ns1:BillUserReq': */
class SOAP_CMAC _ns1__BillUserReq {
      public:
        /// Required element 'ns1:BillUserRequest' of XSD type 'ns1:BillUserRequestType'
        ns1__BillUserRequestType *BillUserRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BillUserReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BillUserReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BillUserReq, default initialized and not managed by a soap context
        virtual _ns1__BillUserReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BillUserReq); }
      public:
        /// Constructor with initializations
        _ns1__BillUserReq() : BillUserRequest(), soap() { }
        virtual ~_ns1__BillUserReq() { }
        /// Friend allocator used by soap_new__ns1__BillUserReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BillUserReq * SOAP_FMAC2 soap_instantiate__ns1__BillUserReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:577 */
#ifndef SOAP_TYPE__ns1__TransactionSearchReq
#define SOAP_TYPE__ns1__TransactionSearchReq (147)
/* complex XSD type 'ns1:TransactionSearchReq': */
class SOAP_CMAC _ns1__TransactionSearchReq {
      public:
        /// Required element 'ns1:TransactionSearchRequest' of XSD type 'ns1:TransactionSearchRequestType'
        ns1__TransactionSearchRequestType *TransactionSearchRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__TransactionSearchReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__TransactionSearchReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__TransactionSearchReq, default initialized and not managed by a soap context
        virtual _ns1__TransactionSearchReq *soap_alloc(void) const { return SOAP_NEW(_ns1__TransactionSearchReq); }
      public:
        /// Constructor with initializations
        _ns1__TransactionSearchReq() : TransactionSearchRequest(), soap() { }
        virtual ~_ns1__TransactionSearchReq() { }
        /// Friend allocator used by soap_new__ns1__TransactionSearchReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__TransactionSearchReq * SOAP_FMAC2 soap_instantiate__ns1__TransactionSearchReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:580 */
#ifndef SOAP_TYPE__ns1__MassPayReq
#define SOAP_TYPE__ns1__MassPayReq (148)
/* complex XSD type 'ns1:MassPayReq': */
class SOAP_CMAC _ns1__MassPayReq {
      public:
        /// Required element 'ns1:MassPayRequest' of XSD type 'ns1:MassPayRequestType'
        ns1__MassPayRequestType *MassPayRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MassPayReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MassPayReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MassPayReq, default initialized and not managed by a soap context
        virtual _ns1__MassPayReq *soap_alloc(void) const { return SOAP_NEW(_ns1__MassPayReq); }
      public:
        /// Constructor with initializations
        _ns1__MassPayReq() : MassPayRequest(), soap() { }
        virtual ~_ns1__MassPayReq() { }
        /// Friend allocator used by soap_new__ns1__MassPayReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MassPayReq * SOAP_FMAC2 soap_instantiate__ns1__MassPayReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:583 */
#ifndef SOAP_TYPE__ns1__BillAgreementUpdateReq
#define SOAP_TYPE__ns1__BillAgreementUpdateReq (149)
/* complex XSD type 'ns1:BillAgreementUpdateReq': */
class SOAP_CMAC _ns1__BillAgreementUpdateReq {
      public:
        /// Required element 'ns1:BAUpdateRequest' of XSD type 'ns1:BAUpdateRequestType'
        ns1__BAUpdateRequestType *BAUpdateRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BillAgreementUpdateReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BillAgreementUpdateReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BillAgreementUpdateReq, default initialized and not managed by a soap context
        virtual _ns1__BillAgreementUpdateReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BillAgreementUpdateReq); }
      public:
        /// Constructor with initializations
        _ns1__BillAgreementUpdateReq() : BAUpdateRequest(), soap() { }
        virtual ~_ns1__BillAgreementUpdateReq() { }
        /// Friend allocator used by soap_new__ns1__BillAgreementUpdateReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BillAgreementUpdateReq * SOAP_FMAC2 soap_instantiate__ns1__BillAgreementUpdateReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:586 */
#ifndef SOAP_TYPE__ns1__AddressVerifyReq
#define SOAP_TYPE__ns1__AddressVerifyReq (150)
/* complex XSD type 'ns1:AddressVerifyReq': */
class SOAP_CMAC _ns1__AddressVerifyReq {
      public:
        /// Required element 'ns1:AddressVerifyRequest' of XSD type 'ns1:AddressVerifyRequestType'
        ns1__AddressVerifyRequestType *AddressVerifyRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddressVerifyReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddressVerifyReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddressVerifyReq, default initialized and not managed by a soap context
        virtual _ns1__AddressVerifyReq *soap_alloc(void) const { return SOAP_NEW(_ns1__AddressVerifyReq); }
      public:
        /// Constructor with initializations
        _ns1__AddressVerifyReq() : AddressVerifyRequest(), soap() { }
        virtual ~_ns1__AddressVerifyReq() { }
        /// Friend allocator used by soap_new__ns1__AddressVerifyReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddressVerifyReq * SOAP_FMAC2 soap_instantiate__ns1__AddressVerifyReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:589 */
#ifndef SOAP_TYPE__ns1__EnterBoardingReq
#define SOAP_TYPE__ns1__EnterBoardingReq (151)
/* complex XSD type 'ns1:EnterBoardingReq': */
class SOAP_CMAC _ns1__EnterBoardingReq {
      public:
        /// Required element 'ns1:EnterBoardingRequest' of XSD type 'ns1:EnterBoardingRequestType'
        ns1__EnterBoardingRequestType *EnterBoardingRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EnterBoardingReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EnterBoardingReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EnterBoardingReq, default initialized and not managed by a soap context
        virtual _ns1__EnterBoardingReq *soap_alloc(void) const { return SOAP_NEW(_ns1__EnterBoardingReq); }
      public:
        /// Constructor with initializations
        _ns1__EnterBoardingReq() : EnterBoardingRequest(), soap() { }
        virtual ~_ns1__EnterBoardingReq() { }
        /// Friend allocator used by soap_new__ns1__EnterBoardingReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EnterBoardingReq * SOAP_FMAC2 soap_instantiate__ns1__EnterBoardingReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:592 */
#ifndef SOAP_TYPE__ns1__GetBoardingDetailsReq
#define SOAP_TYPE__ns1__GetBoardingDetailsReq (152)
/* complex XSD type 'ns1:GetBoardingDetailsReq': */
class SOAP_CMAC _ns1__GetBoardingDetailsReq {
      public:
        /// Required element 'ns1:GetBoardingDetailsRequest' of XSD type 'ns1:GetBoardingDetailsRequestType'
        ns1__GetBoardingDetailsRequestType *GetBoardingDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetBoardingDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetBoardingDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetBoardingDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetBoardingDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetBoardingDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetBoardingDetailsReq() : GetBoardingDetailsRequest(), soap() { }
        virtual ~_ns1__GetBoardingDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetBoardingDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetBoardingDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetBoardingDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:595 */
#ifndef SOAP_TYPE__ns1__SetAuthFlowParamReq
#define SOAP_TYPE__ns1__SetAuthFlowParamReq (153)
/* complex XSD type 'ns1:SetAuthFlowParamReq': */
class SOAP_CMAC _ns1__SetAuthFlowParamReq {
      public:
        /// Required element 'ns1:SetAuthFlowParamRequest' of XSD type 'ns1:SetAuthFlowParamRequestType'
        ns1__SetAuthFlowParamRequestType *SetAuthFlowParamRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAuthFlowParamReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAuthFlowParamReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAuthFlowParamReq, default initialized and not managed by a soap context
        virtual _ns1__SetAuthFlowParamReq *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAuthFlowParamReq); }
      public:
        /// Constructor with initializations
        _ns1__SetAuthFlowParamReq() : SetAuthFlowParamRequest(), soap() { }
        virtual ~_ns1__SetAuthFlowParamReq() { }
        /// Friend allocator used by soap_new__ns1__SetAuthFlowParamReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAuthFlowParamReq * SOAP_FMAC2 soap_instantiate__ns1__SetAuthFlowParamReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:598 */
#ifndef SOAP_TYPE__ns1__GetAuthDetailsReq
#define SOAP_TYPE__ns1__GetAuthDetailsReq (154)
/* complex XSD type 'ns1:GetAuthDetailsReq': */
class SOAP_CMAC _ns1__GetAuthDetailsReq {
      public:
        /// Required element 'ns1:GetAuthDetailsRequest' of XSD type 'ns1:GetAuthDetailsRequestType'
        ns1__GetAuthDetailsRequestType *GetAuthDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAuthDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAuthDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAuthDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetAuthDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAuthDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetAuthDetailsReq() : GetAuthDetailsRequest(), soap() { }
        virtual ~_ns1__GetAuthDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetAuthDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAuthDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetAuthDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:601 */
#ifndef SOAP_TYPE__ns1__SetAccessPermissionsReq
#define SOAP_TYPE__ns1__SetAccessPermissionsReq (155)
/* complex XSD type 'ns1:SetAccessPermissionsReq': */
class SOAP_CMAC _ns1__SetAccessPermissionsReq {
      public:
        /// Required element 'ns1:SetAccessPermissionsRequest' of XSD type 'ns1:SetAccessPermissionsRequestType'
        ns1__SetAccessPermissionsRequestType *SetAccessPermissionsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAccessPermissionsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAccessPermissionsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAccessPermissionsReq, default initialized and not managed by a soap context
        virtual _ns1__SetAccessPermissionsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAccessPermissionsReq); }
      public:
        /// Constructor with initializations
        _ns1__SetAccessPermissionsReq() : SetAccessPermissionsRequest(), soap() { }
        virtual ~_ns1__SetAccessPermissionsReq() { }
        /// Friend allocator used by soap_new__ns1__SetAccessPermissionsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAccessPermissionsReq * SOAP_FMAC2 soap_instantiate__ns1__SetAccessPermissionsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:604 */
#ifndef SOAP_TYPE__ns1__UpdateAccessPermissionsReq
#define SOAP_TYPE__ns1__UpdateAccessPermissionsReq (156)
/* complex XSD type 'ns1:UpdateAccessPermissionsReq': */
class SOAP_CMAC _ns1__UpdateAccessPermissionsReq {
      public:
        /// Required element 'ns1:UpdateAccessPermissionsRequest' of XSD type 'ns1:UpdateAccessPermissionsRequestType'
        ns1__UpdateAccessPermissionsRequestType *UpdateAccessPermissionsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdateAccessPermissionsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdateAccessPermissionsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdateAccessPermissionsReq, default initialized and not managed by a soap context
        virtual _ns1__UpdateAccessPermissionsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateAccessPermissionsReq); }
      public:
        /// Constructor with initializations
        _ns1__UpdateAccessPermissionsReq() : UpdateAccessPermissionsRequest(), soap() { }
        virtual ~_ns1__UpdateAccessPermissionsReq() { }
        /// Friend allocator used by soap_new__ns1__UpdateAccessPermissionsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdateAccessPermissionsReq * SOAP_FMAC2 soap_instantiate__ns1__UpdateAccessPermissionsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:607 */
#ifndef SOAP_TYPE__ns1__GetAccessPermissionDetailsReq
#define SOAP_TYPE__ns1__GetAccessPermissionDetailsReq (157)
/* complex XSD type 'ns1:GetAccessPermissionDetailsReq': */
class SOAP_CMAC _ns1__GetAccessPermissionDetailsReq {
      public:
        /// Required element 'ns1:GetAccessPermissionDetailsRequest' of XSD type 'ns1:GetAccessPermissionDetailsRequestType'
        ns1__GetAccessPermissionDetailsRequestType *GetAccessPermissionDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAccessPermissionDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAccessPermissionDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAccessPermissionDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetAccessPermissionDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAccessPermissionDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetAccessPermissionDetailsReq() : GetAccessPermissionDetailsRequest(), soap() { }
        virtual ~_ns1__GetAccessPermissionDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetAccessPermissionDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAccessPermissionDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetAccessPermissionDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:610 */
#ifndef SOAP_TYPE__ns1__GetIncentiveEvaluationReq
#define SOAP_TYPE__ns1__GetIncentiveEvaluationReq (158)
/* complex XSD type 'ns1:GetIncentiveEvaluationReq': */
class SOAP_CMAC _ns1__GetIncentiveEvaluationReq {
      public:
        /// Required element 'ns1:GetIncentiveEvaluationRequest' of XSD type 'ns1:GetIncentiveEvaluationRequestType'
        ns1__GetIncentiveEvaluationRequestType *GetIncentiveEvaluationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetIncentiveEvaluationReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetIncentiveEvaluationReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetIncentiveEvaluationReq, default initialized and not managed by a soap context
        virtual _ns1__GetIncentiveEvaluationReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetIncentiveEvaluationReq); }
      public:
        /// Constructor with initializations
        _ns1__GetIncentiveEvaluationReq() : GetIncentiveEvaluationRequest(), soap() { }
        virtual ~_ns1__GetIncentiveEvaluationReq() { }
        /// Friend allocator used by soap_new__ns1__GetIncentiveEvaluationReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetIncentiveEvaluationReq * SOAP_FMAC2 soap_instantiate__ns1__GetIncentiveEvaluationReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:613 */
#ifndef SOAP_TYPE__ns1__SetExpressCheckoutReq
#define SOAP_TYPE__ns1__SetExpressCheckoutReq (159)
/* complex XSD type 'ns1:SetExpressCheckoutReq': */
class SOAP_CMAC _ns1__SetExpressCheckoutReq {
      public:
        /// Required element 'ns1:SetExpressCheckoutRequest' of XSD type 'ns1:SetExpressCheckoutRequestType'
        ns1__SetExpressCheckoutRequestType *SetExpressCheckoutRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetExpressCheckoutReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetExpressCheckoutReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetExpressCheckoutReq, default initialized and not managed by a soap context
        virtual _ns1__SetExpressCheckoutReq *soap_alloc(void) const { return SOAP_NEW(_ns1__SetExpressCheckoutReq); }
      public:
        /// Constructor with initializations
        _ns1__SetExpressCheckoutReq() : SetExpressCheckoutRequest(), soap() { }
        virtual ~_ns1__SetExpressCheckoutReq() { }
        /// Friend allocator used by soap_new__ns1__SetExpressCheckoutReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetExpressCheckoutReq * SOAP_FMAC2 soap_instantiate__ns1__SetExpressCheckoutReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:616 */
#ifndef SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq
#define SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq (160)
/* complex XSD type 'ns1:ExecuteCheckoutOperationsReq': */
class SOAP_CMAC _ns1__ExecuteCheckoutOperationsReq {
      public:
        /// Required element 'ns1:ExecuteCheckoutOperationsRequest' of XSD type 'ns1:ExecuteCheckoutOperationsRequestType'
        ns1__ExecuteCheckoutOperationsRequestType *ExecuteCheckoutOperationsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExecuteCheckoutOperationsReq, default initialized and not managed by a soap context
        virtual _ns1__ExecuteCheckoutOperationsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__ExecuteCheckoutOperationsReq); }
      public:
        /// Constructor with initializations
        _ns1__ExecuteCheckoutOperationsReq() : ExecuteCheckoutOperationsRequest(), soap() { }
        virtual ~_ns1__ExecuteCheckoutOperationsReq() { }
        /// Friend allocator used by soap_new__ns1__ExecuteCheckoutOperationsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExecuteCheckoutOperationsReq * SOAP_FMAC2 soap_instantiate__ns1__ExecuteCheckoutOperationsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:619 */
#ifndef SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq
#define SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq (161)
/* complex XSD type 'ns1:GetExpressCheckoutDetailsReq': */
class SOAP_CMAC _ns1__GetExpressCheckoutDetailsReq {
      public:
        /// Required element 'ns1:GetExpressCheckoutDetailsRequest' of XSD type 'ns1:GetExpressCheckoutDetailsRequestType'
        ns1__GetExpressCheckoutDetailsRequestType *GetExpressCheckoutDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetExpressCheckoutDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetExpressCheckoutDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetExpressCheckoutDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetExpressCheckoutDetailsReq() : GetExpressCheckoutDetailsRequest(), soap() { }
        virtual ~_ns1__GetExpressCheckoutDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetExpressCheckoutDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetExpressCheckoutDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetExpressCheckoutDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:622 */
#ifndef SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq (162)
/* complex XSD type 'ns1:DoExpressCheckoutPaymentReq': */
class SOAP_CMAC _ns1__DoExpressCheckoutPaymentReq {
      public:
        /// Required element 'ns1:DoExpressCheckoutPaymentRequest' of XSD type 'ns1:DoExpressCheckoutPaymentRequestType'
        ns1__DoExpressCheckoutPaymentRequestType *DoExpressCheckoutPaymentRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoExpressCheckoutPaymentReq, default initialized and not managed by a soap context
        virtual _ns1__DoExpressCheckoutPaymentReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoExpressCheckoutPaymentReq); }
      public:
        /// Constructor with initializations
        _ns1__DoExpressCheckoutPaymentReq() : DoExpressCheckoutPaymentRequest(), soap() { }
        virtual ~_ns1__DoExpressCheckoutPaymentReq() { }
        /// Friend allocator used by soap_new__ns1__DoExpressCheckoutPaymentReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoExpressCheckoutPaymentReq * SOAP_FMAC2 soap_instantiate__ns1__DoExpressCheckoutPaymentReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:625 */
#ifndef SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq (163)
/* complex XSD type 'ns1:DoUATPExpressCheckoutPaymentReq': */
class SOAP_CMAC _ns1__DoUATPExpressCheckoutPaymentReq {
      public:
        /// Required element 'ns1:DoUATPExpressCheckoutPaymentRequest' of XSD type 'ns1:DoUATPExpressCheckoutPaymentRequestType'
        ns1__DoUATPExpressCheckoutPaymentRequestType *DoUATPExpressCheckoutPaymentRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoUATPExpressCheckoutPaymentReq, default initialized and not managed by a soap context
        virtual _ns1__DoUATPExpressCheckoutPaymentReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoUATPExpressCheckoutPaymentReq); }
      public:
        /// Constructor with initializations
        _ns1__DoUATPExpressCheckoutPaymentReq() : DoUATPExpressCheckoutPaymentRequest(), soap() { }
        virtual ~_ns1__DoUATPExpressCheckoutPaymentReq() { }
        /// Friend allocator used by soap_new__ns1__DoUATPExpressCheckoutPaymentReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoUATPExpressCheckoutPaymentReq * SOAP_FMAC2 soap_instantiate__ns1__DoUATPExpressCheckoutPaymentReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:628 */
#ifndef SOAP_TYPE__ns1__ManagePendingTransactionStatusReq
#define SOAP_TYPE__ns1__ManagePendingTransactionStatusReq (164)
/* complex XSD type 'ns1:ManagePendingTransactionStatusReq': */
class SOAP_CMAC _ns1__ManagePendingTransactionStatusReq {
      public:
        /// Required element 'ns1:ManagePendingTransactionStatusRequest' of XSD type 'ns1:ManagePendingTransactionStatusRequestType'
        ns1__ManagePendingTransactionStatusRequestType *ManagePendingTransactionStatusRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ManagePendingTransactionStatusReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ManagePendingTransactionStatusReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ManagePendingTransactionStatusReq, default initialized and not managed by a soap context
        virtual _ns1__ManagePendingTransactionStatusReq *soap_alloc(void) const { return SOAP_NEW(_ns1__ManagePendingTransactionStatusReq); }
      public:
        /// Constructor with initializations
        _ns1__ManagePendingTransactionStatusReq() : ManagePendingTransactionStatusRequest(), soap() { }
        virtual ~_ns1__ManagePendingTransactionStatusReq() { }
        /// Friend allocator used by soap_new__ns1__ManagePendingTransactionStatusReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ManagePendingTransactionStatusReq * SOAP_FMAC2 soap_instantiate__ns1__ManagePendingTransactionStatusReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:631 */
#ifndef SOAP_TYPE__ns1__DoDirectPaymentReq
#define SOAP_TYPE__ns1__DoDirectPaymentReq (165)
/* complex XSD type 'ns1:DoDirectPaymentReq': */
class SOAP_CMAC _ns1__DoDirectPaymentReq {
      public:
        /// Required element 'ns1:DoDirectPaymentRequest' of XSD type 'ns1:DoDirectPaymentRequestType'
        ns1__DoDirectPaymentRequestType *DoDirectPaymentRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoDirectPaymentReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoDirectPaymentReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoDirectPaymentReq, default initialized and not managed by a soap context
        virtual _ns1__DoDirectPaymentReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoDirectPaymentReq); }
      public:
        /// Constructor with initializations
        _ns1__DoDirectPaymentReq() : DoDirectPaymentRequest(), soap() { }
        virtual ~_ns1__DoDirectPaymentReq() { }
        /// Friend allocator used by soap_new__ns1__DoDirectPaymentReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoDirectPaymentReq * SOAP_FMAC2 soap_instantiate__ns1__DoDirectPaymentReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:634 */
#ifndef SOAP_TYPE__ns1__DoCancelReq
#define SOAP_TYPE__ns1__DoCancelReq (166)
/* complex XSD type 'ns1:DoCancelReq': */
class SOAP_CMAC _ns1__DoCancelReq {
      public:
        /// Required element 'ns1:DoCancelRequest' of XSD type 'ns1:DoCancelRequestType'
        ns1__DoCancelRequestType *DoCancelRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoCancelReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoCancelReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoCancelReq, default initialized and not managed by a soap context
        virtual _ns1__DoCancelReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoCancelReq); }
      public:
        /// Constructor with initializations
        _ns1__DoCancelReq() : DoCancelRequest(), soap() { }
        virtual ~_ns1__DoCancelReq() { }
        /// Friend allocator used by soap_new__ns1__DoCancelReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoCancelReq * SOAP_FMAC2 soap_instantiate__ns1__DoCancelReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:637 */
#ifndef SOAP_TYPE__ns1__DoCaptureReq
#define SOAP_TYPE__ns1__DoCaptureReq (167)
/* complex XSD type 'ns1:DoCaptureReq': */
class SOAP_CMAC _ns1__DoCaptureReq {
      public:
        /// Required element 'ns1:DoCaptureRequest' of XSD type 'ns1:DoCaptureRequestType'
        ns1__DoCaptureRequestType *DoCaptureRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoCaptureReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoCaptureReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoCaptureReq, default initialized and not managed by a soap context
        virtual _ns1__DoCaptureReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoCaptureReq); }
      public:
        /// Constructor with initializations
        _ns1__DoCaptureReq() : DoCaptureRequest(), soap() { }
        virtual ~_ns1__DoCaptureReq() { }
        /// Friend allocator used by soap_new__ns1__DoCaptureReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoCaptureReq * SOAP_FMAC2 soap_instantiate__ns1__DoCaptureReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:640 */
#ifndef SOAP_TYPE__ns1__DoReauthorizationReq
#define SOAP_TYPE__ns1__DoReauthorizationReq (168)
/* complex XSD type 'ns1:DoReauthorizationReq': */
class SOAP_CMAC _ns1__DoReauthorizationReq {
      public:
        /// Required element 'ns1:DoReauthorizationRequest' of XSD type 'ns1:DoReauthorizationRequestType'
        ns1__DoReauthorizationRequestType *DoReauthorizationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoReauthorizationReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoReauthorizationReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoReauthorizationReq, default initialized and not managed by a soap context
        virtual _ns1__DoReauthorizationReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoReauthorizationReq); }
      public:
        /// Constructor with initializations
        _ns1__DoReauthorizationReq() : DoReauthorizationRequest(), soap() { }
        virtual ~_ns1__DoReauthorizationReq() { }
        /// Friend allocator used by soap_new__ns1__DoReauthorizationReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoReauthorizationReq * SOAP_FMAC2 soap_instantiate__ns1__DoReauthorizationReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:643 */
#ifndef SOAP_TYPE__ns1__DoVoidReq
#define SOAP_TYPE__ns1__DoVoidReq (169)
/* complex XSD type 'ns1:DoVoidReq': */
class SOAP_CMAC _ns1__DoVoidReq {
      public:
        /// Required element 'ns1:DoVoidRequest' of XSD type 'ns1:DoVoidRequestType'
        ns1__DoVoidRequestType *DoVoidRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoVoidReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoVoidReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoVoidReq, default initialized and not managed by a soap context
        virtual _ns1__DoVoidReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoVoidReq); }
      public:
        /// Constructor with initializations
        _ns1__DoVoidReq() : DoVoidRequest(), soap() { }
        virtual ~_ns1__DoVoidReq() { }
        /// Friend allocator used by soap_new__ns1__DoVoidReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoVoidReq * SOAP_FMAC2 soap_instantiate__ns1__DoVoidReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:646 */
#ifndef SOAP_TYPE__ns1__DoAuthorizationReq
#define SOAP_TYPE__ns1__DoAuthorizationReq (170)
/* complex XSD type 'ns1:DoAuthorizationReq': */
class SOAP_CMAC _ns1__DoAuthorizationReq {
      public:
        /// Required element 'ns1:DoAuthorizationRequest' of XSD type 'ns1:DoAuthorizationRequestType'
        ns1__DoAuthorizationRequestType *DoAuthorizationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoAuthorizationReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoAuthorizationReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoAuthorizationReq, default initialized and not managed by a soap context
        virtual _ns1__DoAuthorizationReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoAuthorizationReq); }
      public:
        /// Constructor with initializations
        _ns1__DoAuthorizationReq() : DoAuthorizationRequest(), soap() { }
        virtual ~_ns1__DoAuthorizationReq() { }
        /// Friend allocator used by soap_new__ns1__DoAuthorizationReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoAuthorizationReq * SOAP_FMAC2 soap_instantiate__ns1__DoAuthorizationReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:649 */
#ifndef SOAP_TYPE__ns1__UpdateAuthorizationReq
#define SOAP_TYPE__ns1__UpdateAuthorizationReq (171)
/* complex XSD type 'ns1:UpdateAuthorizationReq': */
class SOAP_CMAC _ns1__UpdateAuthorizationReq {
      public:
        /// Required element 'ns1:UpdateAuthorizationRequest' of XSD type 'ns1:UpdateAuthorizationRequestType'
        ns1__UpdateAuthorizationRequestType *UpdateAuthorizationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdateAuthorizationReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdateAuthorizationReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdateAuthorizationReq, default initialized and not managed by a soap context
        virtual _ns1__UpdateAuthorizationReq *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateAuthorizationReq); }
      public:
        /// Constructor with initializations
        _ns1__UpdateAuthorizationReq() : UpdateAuthorizationRequest(), soap() { }
        virtual ~_ns1__UpdateAuthorizationReq() { }
        /// Friend allocator used by soap_new__ns1__UpdateAuthorizationReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdateAuthorizationReq * SOAP_FMAC2 soap_instantiate__ns1__UpdateAuthorizationReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:652 */
#ifndef SOAP_TYPE__ns1__DoUATPAuthorizationReq
#define SOAP_TYPE__ns1__DoUATPAuthorizationReq (172)
/* complex XSD type 'ns1:DoUATPAuthorizationReq': */
class SOAP_CMAC _ns1__DoUATPAuthorizationReq {
      public:
        /// Required element 'ns1:DoUATPAuthorizationRequest' of XSD type 'ns1:DoUATPAuthorizationRequestType'
        ns1__DoUATPAuthorizationRequestType *DoUATPAuthorizationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoUATPAuthorizationReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoUATPAuthorizationReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoUATPAuthorizationReq, default initialized and not managed by a soap context
        virtual _ns1__DoUATPAuthorizationReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoUATPAuthorizationReq); }
      public:
        /// Constructor with initializations
        _ns1__DoUATPAuthorizationReq() : DoUATPAuthorizationRequest(), soap() { }
        virtual ~_ns1__DoUATPAuthorizationReq() { }
        /// Friend allocator used by soap_new__ns1__DoUATPAuthorizationReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoUATPAuthorizationReq * SOAP_FMAC2 soap_instantiate__ns1__DoUATPAuthorizationReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:655 */
#ifndef SOAP_TYPE__ns1__CreateMobilePaymentReq
#define SOAP_TYPE__ns1__CreateMobilePaymentReq (173)
/* complex XSD type 'ns1:CreateMobilePaymentReq': */
class SOAP_CMAC _ns1__CreateMobilePaymentReq {
      public:
        /// Required element 'ns1:CreateMobilePaymentRequest' of XSD type 'ns1:CreateMobilePaymentRequestType'
        ns1__CreateMobilePaymentRequestType *CreateMobilePaymentRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateMobilePaymentReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateMobilePaymentReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateMobilePaymentReq, default initialized and not managed by a soap context
        virtual _ns1__CreateMobilePaymentReq *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateMobilePaymentReq); }
      public:
        /// Constructor with initializations
        _ns1__CreateMobilePaymentReq() : CreateMobilePaymentRequest(), soap() { }
        virtual ~_ns1__CreateMobilePaymentReq() { }
        /// Friend allocator used by soap_new__ns1__CreateMobilePaymentReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateMobilePaymentReq * SOAP_FMAC2 soap_instantiate__ns1__CreateMobilePaymentReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:658 */
#ifndef SOAP_TYPE__ns1__GetMobileStatusReq
#define SOAP_TYPE__ns1__GetMobileStatusReq (174)
/* complex XSD type 'ns1:GetMobileStatusReq': */
class SOAP_CMAC _ns1__GetMobileStatusReq {
      public:
        /// Required element 'ns1:GetMobileStatusRequest' of XSD type 'ns1:GetMobileStatusRequestType'
        ns1__GetMobileStatusRequestType *GetMobileStatusRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMobileStatusReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetMobileStatusReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMobileStatusReq, default initialized and not managed by a soap context
        virtual _ns1__GetMobileStatusReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetMobileStatusReq); }
      public:
        /// Constructor with initializations
        _ns1__GetMobileStatusReq() : GetMobileStatusRequest(), soap() { }
        virtual ~_ns1__GetMobileStatusReq() { }
        /// Friend allocator used by soap_new__ns1__GetMobileStatusReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMobileStatusReq * SOAP_FMAC2 soap_instantiate__ns1__GetMobileStatusReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:661 */
#ifndef SOAP_TYPE__ns1__SetMobileCheckoutReq
#define SOAP_TYPE__ns1__SetMobileCheckoutReq (175)
/* complex XSD type 'ns1:SetMobileCheckoutReq': */
class SOAP_CMAC _ns1__SetMobileCheckoutReq {
      public:
        /// Required element 'ns1:SetMobileCheckoutRequest' of XSD type 'ns1:SetMobileCheckoutRequestType'
        ns1__SetMobileCheckoutRequestType *SetMobileCheckoutRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetMobileCheckoutReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetMobileCheckoutReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetMobileCheckoutReq, default initialized and not managed by a soap context
        virtual _ns1__SetMobileCheckoutReq *soap_alloc(void) const { return SOAP_NEW(_ns1__SetMobileCheckoutReq); }
      public:
        /// Constructor with initializations
        _ns1__SetMobileCheckoutReq() : SetMobileCheckoutRequest(), soap() { }
        virtual ~_ns1__SetMobileCheckoutReq() { }
        /// Friend allocator used by soap_new__ns1__SetMobileCheckoutReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetMobileCheckoutReq * SOAP_FMAC2 soap_instantiate__ns1__SetMobileCheckoutReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:664 */
#ifndef SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq (176)
/* complex XSD type 'ns1:DoMobileCheckoutPaymentReq': */
class SOAP_CMAC _ns1__DoMobileCheckoutPaymentReq {
      public:
        /// Required element 'ns1:DoMobileCheckoutPaymentRequest' of XSD type 'ns1:DoMobileCheckoutPaymentRequestType'
        ns1__DoMobileCheckoutPaymentRequestType *DoMobileCheckoutPaymentRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoMobileCheckoutPaymentReq, default initialized and not managed by a soap context
        virtual _ns1__DoMobileCheckoutPaymentReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoMobileCheckoutPaymentReq); }
      public:
        /// Constructor with initializations
        _ns1__DoMobileCheckoutPaymentReq() : DoMobileCheckoutPaymentRequest(), soap() { }
        virtual ~_ns1__DoMobileCheckoutPaymentReq() { }
        /// Friend allocator used by soap_new__ns1__DoMobileCheckoutPaymentReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoMobileCheckoutPaymentReq * SOAP_FMAC2 soap_instantiate__ns1__DoMobileCheckoutPaymentReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:667 */
#ifndef SOAP_TYPE__ns1__GetBalanceReq
#define SOAP_TYPE__ns1__GetBalanceReq (177)
/* complex XSD type 'ns1:GetBalanceReq': */
class SOAP_CMAC _ns1__GetBalanceReq {
      public:
        /// Required element 'ns1:GetBalanceRequest' of XSD type 'ns1:GetBalanceRequestType'
        ns1__GetBalanceRequestType *GetBalanceRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetBalanceReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetBalanceReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetBalanceReq, default initialized and not managed by a soap context
        virtual _ns1__GetBalanceReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetBalanceReq); }
      public:
        /// Constructor with initializations
        _ns1__GetBalanceReq() : GetBalanceRequest(), soap() { }
        virtual ~_ns1__GetBalanceReq() { }
        /// Friend allocator used by soap_new__ns1__GetBalanceReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetBalanceReq * SOAP_FMAC2 soap_instantiate__ns1__GetBalanceReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:670 */
#ifndef SOAP_TYPE__ns1__SetCustomerBillingAgreementReq
#define SOAP_TYPE__ns1__SetCustomerBillingAgreementReq (178)
/* complex XSD type 'ns1:SetCustomerBillingAgreementReq': */
class SOAP_CMAC _ns1__SetCustomerBillingAgreementReq {
      public:
        /// Required element 'ns1:SetCustomerBillingAgreementRequest' of XSD type 'ns1:SetCustomerBillingAgreementRequestType'
        ns1__SetCustomerBillingAgreementRequestType *SetCustomerBillingAgreementRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetCustomerBillingAgreementReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetCustomerBillingAgreementReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetCustomerBillingAgreementReq, default initialized and not managed by a soap context
        virtual _ns1__SetCustomerBillingAgreementReq *soap_alloc(void) const { return SOAP_NEW(_ns1__SetCustomerBillingAgreementReq); }
      public:
        /// Constructor with initializations
        _ns1__SetCustomerBillingAgreementReq() : SetCustomerBillingAgreementRequest(), soap() { }
        virtual ~_ns1__SetCustomerBillingAgreementReq() { }
        /// Friend allocator used by soap_new__ns1__SetCustomerBillingAgreementReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetCustomerBillingAgreementReq * SOAP_FMAC2 soap_instantiate__ns1__SetCustomerBillingAgreementReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:673 */
#ifndef SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq
#define SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq (179)
/* complex XSD type 'ns1:GetBillingAgreementCustomerDetailsReq': */
class SOAP_CMAC _ns1__GetBillingAgreementCustomerDetailsReq {
      public:
        /// Required element 'ns1:GetBillingAgreementCustomerDetailsRequest' of XSD type 'ns1:GetBillingAgreementCustomerDetailsRequestType'
        ns1__GetBillingAgreementCustomerDetailsRequestType *GetBillingAgreementCustomerDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetBillingAgreementCustomerDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetBillingAgreementCustomerDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetBillingAgreementCustomerDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetBillingAgreementCustomerDetailsReq() : GetBillingAgreementCustomerDetailsRequest(), soap() { }
        virtual ~_ns1__GetBillingAgreementCustomerDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetBillingAgreementCustomerDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetBillingAgreementCustomerDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetBillingAgreementCustomerDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:676 */
#ifndef SOAP_TYPE__ns1__CreateBillingAgreementReq
#define SOAP_TYPE__ns1__CreateBillingAgreementReq (180)
/* complex XSD type 'ns1:CreateBillingAgreementReq': */
class SOAP_CMAC _ns1__CreateBillingAgreementReq {
      public:
        /// Required element 'ns1:CreateBillingAgreementRequest' of XSD type 'ns1:CreateBillingAgreementRequestType'
        ns1__CreateBillingAgreementRequestType *CreateBillingAgreementRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateBillingAgreementReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateBillingAgreementReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateBillingAgreementReq, default initialized and not managed by a soap context
        virtual _ns1__CreateBillingAgreementReq *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateBillingAgreementReq); }
      public:
        /// Constructor with initializations
        _ns1__CreateBillingAgreementReq() : CreateBillingAgreementRequest(), soap() { }
        virtual ~_ns1__CreateBillingAgreementReq() { }
        /// Friend allocator used by soap_new__ns1__CreateBillingAgreementReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateBillingAgreementReq * SOAP_FMAC2 soap_instantiate__ns1__CreateBillingAgreementReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:679 */
#ifndef SOAP_TYPE__ns1__DoReferenceTransactionReq
#define SOAP_TYPE__ns1__DoReferenceTransactionReq (181)
/* complex XSD type 'ns1:DoReferenceTransactionReq': */
class SOAP_CMAC _ns1__DoReferenceTransactionReq {
      public:
        /// Required element 'ns1:DoReferenceTransactionRequest' of XSD type 'ns1:DoReferenceTransactionRequestType'
        ns1__DoReferenceTransactionRequestType *DoReferenceTransactionRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoReferenceTransactionReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoReferenceTransactionReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoReferenceTransactionReq, default initialized and not managed by a soap context
        virtual _ns1__DoReferenceTransactionReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoReferenceTransactionReq); }
      public:
        /// Constructor with initializations
        _ns1__DoReferenceTransactionReq() : DoReferenceTransactionRequest(), soap() { }
        virtual ~_ns1__DoReferenceTransactionReq() { }
        /// Friend allocator used by soap_new__ns1__DoReferenceTransactionReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoReferenceTransactionReq * SOAP_FMAC2 soap_instantiate__ns1__DoReferenceTransactionReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:682 */
#ifndef SOAP_TYPE__ns1__DoNonReferencedCreditReq
#define SOAP_TYPE__ns1__DoNonReferencedCreditReq (182)
/* complex XSD type 'ns1:DoNonReferencedCreditReq': */
class SOAP_CMAC _ns1__DoNonReferencedCreditReq {
      public:
        /// Required element 'ns1:DoNonReferencedCreditRequest' of XSD type 'ns1:DoNonReferencedCreditRequestType'
        ns1__DoNonReferencedCreditRequestType *DoNonReferencedCreditRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoNonReferencedCreditReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DoNonReferencedCreditReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoNonReferencedCreditReq, default initialized and not managed by a soap context
        virtual _ns1__DoNonReferencedCreditReq *soap_alloc(void) const { return SOAP_NEW(_ns1__DoNonReferencedCreditReq); }
      public:
        /// Constructor with initializations
        _ns1__DoNonReferencedCreditReq() : DoNonReferencedCreditRequest(), soap() { }
        virtual ~_ns1__DoNonReferencedCreditReq() { }
        /// Friend allocator used by soap_new__ns1__DoNonReferencedCreditReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoNonReferencedCreditReq * SOAP_FMAC2 soap_instantiate__ns1__DoNonReferencedCreditReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:685 */
#ifndef SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq
#define SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq (183)
/* complex XSD type 'ns1:CreateRecurringPaymentsProfileReq': */
class SOAP_CMAC _ns1__CreateRecurringPaymentsProfileReq {
      public:
        /// Required element 'ns1:CreateRecurringPaymentsProfileRequest' of XSD type 'ns1:CreateRecurringPaymentsProfileRequestType'
        ns1__CreateRecurringPaymentsProfileRequestType *CreateRecurringPaymentsProfileRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRecurringPaymentsProfileReq, default initialized and not managed by a soap context
        virtual _ns1__CreateRecurringPaymentsProfileReq *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRecurringPaymentsProfileReq); }
      public:
        /// Constructor with initializations
        _ns1__CreateRecurringPaymentsProfileReq() : CreateRecurringPaymentsProfileRequest(), soap() { }
        virtual ~_ns1__CreateRecurringPaymentsProfileReq() { }
        /// Friend allocator used by soap_new__ns1__CreateRecurringPaymentsProfileReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRecurringPaymentsProfileReq * SOAP_FMAC2 soap_instantiate__ns1__CreateRecurringPaymentsProfileReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:688 */
#ifndef SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq
#define SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq (184)
/* complex XSD type 'ns1:GetRecurringPaymentsProfileDetailsReq': */
class SOAP_CMAC _ns1__GetRecurringPaymentsProfileDetailsReq {
      public:
        /// Required element 'ns1:GetRecurringPaymentsProfileDetailsRequest' of XSD type 'ns1:GetRecurringPaymentsProfileDetailsRequestType'
        ns1__GetRecurringPaymentsProfileDetailsRequestType *GetRecurringPaymentsProfileDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecurringPaymentsProfileDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetRecurringPaymentsProfileDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRecurringPaymentsProfileDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetRecurringPaymentsProfileDetailsReq() : GetRecurringPaymentsProfileDetailsRequest(), soap() { }
        virtual ~_ns1__GetRecurringPaymentsProfileDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetRecurringPaymentsProfileDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecurringPaymentsProfileDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetRecurringPaymentsProfileDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:691 */
#ifndef SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq
#define SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq (185)
/* complex XSD type 'ns1:ManageRecurringPaymentsProfileStatusReq': */
class SOAP_CMAC _ns1__ManageRecurringPaymentsProfileStatusReq {
      public:
        /// Required element 'ns1:ManageRecurringPaymentsProfileStatusRequest' of XSD type 'ns1:ManageRecurringPaymentsProfileStatusRequestType'
        ns1__ManageRecurringPaymentsProfileStatusRequestType *ManageRecurringPaymentsProfileStatusRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ManageRecurringPaymentsProfileStatusReq, default initialized and not managed by a soap context
        virtual _ns1__ManageRecurringPaymentsProfileStatusReq *soap_alloc(void) const { return SOAP_NEW(_ns1__ManageRecurringPaymentsProfileStatusReq); }
      public:
        /// Constructor with initializations
        _ns1__ManageRecurringPaymentsProfileStatusReq() : ManageRecurringPaymentsProfileStatusRequest(), soap() { }
        virtual ~_ns1__ManageRecurringPaymentsProfileStatusReq() { }
        /// Friend allocator used by soap_new__ns1__ManageRecurringPaymentsProfileStatusReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ManageRecurringPaymentsProfileStatusReq * SOAP_FMAC2 soap_instantiate__ns1__ManageRecurringPaymentsProfileStatusReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:694 */
#ifndef SOAP_TYPE__ns1__BillOutstandingAmountReq
#define SOAP_TYPE__ns1__BillOutstandingAmountReq (186)
/* complex XSD type 'ns1:BillOutstandingAmountReq': */
class SOAP_CMAC _ns1__BillOutstandingAmountReq {
      public:
        /// Required element 'ns1:BillOutstandingAmountRequest' of XSD type 'ns1:BillOutstandingAmountRequestType'
        ns1__BillOutstandingAmountRequestType *BillOutstandingAmountRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BillOutstandingAmountReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BillOutstandingAmountReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BillOutstandingAmountReq, default initialized and not managed by a soap context
        virtual _ns1__BillOutstandingAmountReq *soap_alloc(void) const { return SOAP_NEW(_ns1__BillOutstandingAmountReq); }
      public:
        /// Constructor with initializations
        _ns1__BillOutstandingAmountReq() : BillOutstandingAmountRequest(), soap() { }
        virtual ~_ns1__BillOutstandingAmountReq() { }
        /// Friend allocator used by soap_new__ns1__BillOutstandingAmountReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BillOutstandingAmountReq * SOAP_FMAC2 soap_instantiate__ns1__BillOutstandingAmountReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:697 */
#ifndef SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq
#define SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq (187)
/* complex XSD type 'ns1:UpdateRecurringPaymentsProfileReq': */
class SOAP_CMAC _ns1__UpdateRecurringPaymentsProfileReq {
      public:
        /// Required element 'ns1:UpdateRecurringPaymentsProfileRequest' of XSD type 'ns1:UpdateRecurringPaymentsProfileRequestType'
        ns1__UpdateRecurringPaymentsProfileRequestType *UpdateRecurringPaymentsProfileRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdateRecurringPaymentsProfileReq, default initialized and not managed by a soap context
        virtual _ns1__UpdateRecurringPaymentsProfileReq *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateRecurringPaymentsProfileReq); }
      public:
        /// Constructor with initializations
        _ns1__UpdateRecurringPaymentsProfileReq() : UpdateRecurringPaymentsProfileRequest(), soap() { }
        virtual ~_ns1__UpdateRecurringPaymentsProfileReq() { }
        /// Friend allocator used by soap_new__ns1__UpdateRecurringPaymentsProfileReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdateRecurringPaymentsProfileReq * SOAP_FMAC2 soap_instantiate__ns1__UpdateRecurringPaymentsProfileReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:700 */
#ifndef SOAP_TYPE__ns1__GetPalDetailsReq
#define SOAP_TYPE__ns1__GetPalDetailsReq (188)
/* complex XSD type 'ns1:GetPalDetailsReq': */
class SOAP_CMAC _ns1__GetPalDetailsReq {
      public:
        /// Required element 'ns1:GetPalDetailsRequest' of XSD type 'ns1:GetPalDetailsRequestType'
        ns1__GetPalDetailsRequestType *GetPalDetailsRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPalDetailsReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPalDetailsReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPalDetailsReq, default initialized and not managed by a soap context
        virtual _ns1__GetPalDetailsReq *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPalDetailsReq); }
      public:
        /// Constructor with initializations
        _ns1__GetPalDetailsReq() : GetPalDetailsRequest(), soap() { }
        virtual ~_ns1__GetPalDetailsReq() { }
        /// Friend allocator used by soap_new__ns1__GetPalDetailsReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPalDetailsReq * SOAP_FMAC2 soap_instantiate__ns1__GetPalDetailsReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:703 */
#ifndef SOAP_TYPE__ns1__ReverseTransactionReq
#define SOAP_TYPE__ns1__ReverseTransactionReq (189)
/* complex XSD type 'ns1:ReverseTransactionReq': */
class SOAP_CMAC _ns1__ReverseTransactionReq {
      public:
        /// Required element 'ns1:ReverseTransactionRequest' of XSD type 'ns1:ReverseTransactionRequestType'
        ns1__ReverseTransactionRequestType *ReverseTransactionRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReverseTransactionReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReverseTransactionReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReverseTransactionReq, default initialized and not managed by a soap context
        virtual _ns1__ReverseTransactionReq *soap_alloc(void) const { return SOAP_NEW(_ns1__ReverseTransactionReq); }
      public:
        /// Constructor with initializations
        _ns1__ReverseTransactionReq() : ReverseTransactionRequest(), soap() { }
        virtual ~_ns1__ReverseTransactionReq() { }
        /// Friend allocator used by soap_new__ns1__ReverseTransactionReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReverseTransactionReq * SOAP_FMAC2 soap_instantiate__ns1__ReverseTransactionReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:706 */
#ifndef SOAP_TYPE__ns1__ExternalRememberMeOptOutReq
#define SOAP_TYPE__ns1__ExternalRememberMeOptOutReq (190)
/* complex XSD type 'ns1:ExternalRememberMeOptOutReq': */
class SOAP_CMAC _ns1__ExternalRememberMeOptOutReq {
      public:
        /// Required element 'ns1:ExternalRememberMeOptOutRequest' of XSD type 'ns1:ExternalRememberMeOptOutRequestType'
        ns1__ExternalRememberMeOptOutRequestType *ExternalRememberMeOptOutRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExternalRememberMeOptOutReq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ExternalRememberMeOptOutReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExternalRememberMeOptOutReq, default initialized and not managed by a soap context
        virtual _ns1__ExternalRememberMeOptOutReq *soap_alloc(void) const { return SOAP_NEW(_ns1__ExternalRememberMeOptOutReq); }
      public:
        /// Constructor with initializations
        _ns1__ExternalRememberMeOptOutReq() : ExternalRememberMeOptOutRequest(), soap() { }
        virtual ~_ns1__ExternalRememberMeOptOutReq() { }
        /// Friend allocator used by soap_new__ns1__ExternalRememberMeOptOutReq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExternalRememberMeOptOutReq * SOAP_FMAC2 soap_instantiate__ns1__ExternalRememberMeOptOutReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:721 */
#ifndef SOAP_TYPE_ns3__AccountEntryType
#define SOAP_TYPE_ns3__AccountEntryType (195)
/* complex XSD type 'ns3:AccountEntryType': */
class SOAP_CMAC ns3__AccountEntryType {
      public:
        /// Required element 'ns3:Balance' of XSD type 'ns2:AmountType'
        ns2__AmountType *Balance;
        /// Required element 'ns3:Credit' of XSD type 'ns2:AmountType'
        ns2__AmountType *Credit;
        /// Required element 'ns3:Date' of XSD type 'xsd:dateTime'
        time_t Date;
        /// Required element 'ns3:Debit' of XSD type 'ns2:AmountType'
        ns2__AmountType *Debit;
        /// Required element 'ns3:ItemID' of XSD type 'ns3:ItemIDType'
        std::string ItemID;
        /// Required element 'ns3:Memo' of XSD type 'xsd:string'
        std::string Memo;
        /// Required element 'ns3:RefNumber' of XSD type 'xsd:int'
        int RefNumber;
        /// Required element 'ns3:AccountEntryDetailsType' of XSD type 'xsd:int'
        int AccountEntryDetailsType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AccountEntryType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AccountEntryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AccountEntryType, default initialized and not managed by a soap context
        virtual ns3__AccountEntryType *soap_alloc(void) const { return SOAP_NEW(ns3__AccountEntryType); }
      public:
        /// Constructor with initializations
        ns3__AccountEntryType() : Balance(), Credit(), Date(), Debit(), ItemID(), Memo(), RefNumber(), AccountEntryDetailsType(), soap() { }
        virtual ~ns3__AccountEntryType() { }
        /// Friend allocator used by soap_new_ns3__AccountEntryType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AccountEntryType * SOAP_FMAC2 soap_instantiate_ns3__AccountEntryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:724 */
#ifndef SOAP_TYPE_ns3__AdditionalAccountType
#define SOAP_TYPE_ns3__AdditionalAccountType (196)
/* complex XSD type 'ns3:AdditionalAccountType': */
class SOAP_CMAC ns3__AdditionalAccountType {
      public:
        /// Required element 'ns3:Balance' of XSD type 'ns2:AmountType'
        ns2__AmountType *Balance;
        /// Required element 'ns3:Currency' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType Currency;
        /// Required element 'ns3:AccountCode' of XSD type 'xsd:string'
        std::string AccountCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AdditionalAccountType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AdditionalAccountType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AdditionalAccountType, default initialized and not managed by a soap context
        virtual ns3__AdditionalAccountType *soap_alloc(void) const { return SOAP_NEW(ns3__AdditionalAccountType); }
      public:
        /// Constructor with initializations
        ns3__AdditionalAccountType() : Balance(), Currency(), AccountCode(), soap() { }
        virtual ~ns3__AdditionalAccountType() { }
        /// Friend allocator used by soap_new_ns3__AdditionalAccountType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AdditionalAccountType * SOAP_FMAC2 soap_instantiate_ns3__AdditionalAccountType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:727 */
#ifndef SOAP_TYPE_ns3__PromotedItemType
#define SOAP_TYPE_ns3__PromotedItemType (197)
/* complex XSD type 'ns3:PromotedItemType': */
class SOAP_CMAC ns3__PromotedItemType {
      public:
        /// Required element 'ns3:ItemID' of XSD type 'ns3:ItemIDType'
        std::string ItemID;
        /// Optional element 'ns3:PictureURL' of XSD type 'xsd:string'
        std::string *PictureURL;
        /// Optional element 'ns3:position' of XSD type 'xsd:int'
        int *position;
        /// Optional element 'ns3:PromotionPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *PromotionPrice;
        /// Optional element 'ns3:PromotionPriceType' of XSD type 'ns3:PromotionItemPriceTypeCodeType'
        enum ns3__PromotionItemPriceTypeCodeType *PromotionPriceType;
        /// Optional element 'ns3:SelectionType' of XSD type 'ns3:PromotionItemSelectionCodeType'
        enum ns3__PromotionItemSelectionCodeType *SelectionType;
        /// Optional element 'ns3:Title' of XSD type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns3:ListingType' of XSD type 'ns3:ListingTypeCodeType'
        enum ns3__ListingTypeCodeType *ListingType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PromotedItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PromotedItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PromotedItemType, default initialized and not managed by a soap context
        virtual ns3__PromotedItemType *soap_alloc(void) const { return SOAP_NEW(ns3__PromotedItemType); }
      public:
        /// Constructor with initializations
        ns3__PromotedItemType() : ItemID(), PictureURL(), position(), PromotionPrice(), PromotionPriceType(), SelectionType(), Title(), ListingType(), soap() { }
        virtual ~ns3__PromotedItemType() { }
        /// Friend allocator used by soap_new_ns3__PromotedItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PromotedItemType * SOAP_FMAC2 soap_instantiate_ns3__PromotedItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:730 */
#ifndef SOAP_TYPE_ns3__CrossPromotionsType
#define SOAP_TYPE_ns3__CrossPromotionsType (198)
/* complex XSD type 'ns3:CrossPromotionsType': */
class SOAP_CMAC ns3__CrossPromotionsType {
      public:
        /// Required element 'ns3:ItemID' of XSD type 'ns3:ItemIDType'
        std::string ItemID;
        /// Required element 'ns3:PrimaryScheme' of XSD type 'ns3:PromotionSchemeCodeType'
        enum ns3__PromotionSchemeCodeType PrimaryScheme;
        /// Required element 'ns3:PromotionMethod' of XSD type 'ns3:PromotionMethodCodeType'
        enum ns3__PromotionMethodCodeType PromotionMethod;
        /// Required element 'ns3:SellerID' of XSD type 'xsd:string'
        std::string SellerID;
        /// Required element 'ns3:ShippingDiscount' of XSD type 'xsd:boolean'
        bool ShippingDiscount;
        /// Optional element 'ns3:SellerKey' of XSD type 'xsd:string'
        std::string *SellerKey;
        /// Optional element 'ns3:StoreName' of XSD type 'xsd:string'
        std::string *StoreName;
        /// Required element 'ns3:PromotedItem' of XSD type 'ns3:PromotedItemType'
        std::vector<ns3__PromotedItemType *> PromotedItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CrossPromotionsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CrossPromotionsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CrossPromotionsType, default initialized and not managed by a soap context
        virtual ns3__CrossPromotionsType *soap_alloc(void) const { return SOAP_NEW(ns3__CrossPromotionsType); }
      public:
        /// Constructor with initializations
        ns3__CrossPromotionsType() : ItemID(), PrimaryScheme(), PromotionMethod(), SellerID(), ShippingDiscount(), SellerKey(), StoreName(), PromotedItem(), soap() { }
        virtual ~ns3__CrossPromotionsType() { }
        /// Friend allocator used by soap_new_ns3__CrossPromotionsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CrossPromotionsType * SOAP_FMAC2 soap_instantiate_ns3__CrossPromotionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:7128 */
#ifndef SOAP_TYPE__ns3__union_AccountSummaryType
#define SOAP_TYPE__ns3__union_AccountSummaryType (616)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns3__union_AccountSummaryType
{
        #define SOAP_UNION__ns3__union_AccountSummaryType_AccountState	(1)	/**< union variant selector value for member AccountState */
        enum ns3__AccountStateCodeType AccountState;
        #define SOAP_UNION__ns3__union_AccountSummaryType_AdditionalAccount	(2)	/**< union variant selector value for member AdditionalAccount */
        std::vector<ns3__AdditionalAccountType *> *AdditionalAccount;
        #define SOAP_UNION__ns3__union_AccountSummaryType_AdditionalAccountsCount	(3)	/**< union variant selector value for member AdditionalAccountsCount */
        int AdditionalAccountsCount;
        #define SOAP_UNION__ns3__union_AccountSummaryType_AmountPastDue	(4)	/**< union variant selector value for member AmountPastDue */
        ns2__AmountType *AmountPastDue;
        #define SOAP_UNION__ns3__union_AccountSummaryType_BankAccountInfo	(5)	/**< union variant selector value for member BankAccountInfo */
        std::string *BankAccountInfo;
        #define SOAP_UNION__ns3__union_AccountSummaryType_BankModifyDate	(6)	/**< union variant selector value for member BankModifyDate */
        time_t BankModifyDate;
        #define SOAP_UNION__ns3__union_AccountSummaryType_BillingCycleDate	(7)	/**< union variant selector value for member BillingCycleDate */
        time_t BillingCycleDate;
        #define SOAP_UNION__ns3__union_AccountSummaryType_CCExp	(8)	/**< union variant selector value for member CCExp */
        time_t CCExp;
        #define SOAP_UNION__ns3__union_AccountSummaryType_CCInfo	(9)	/**< union variant selector value for member CCInfo */
        std::string *CCInfo;
        #define SOAP_UNION__ns3__union_AccountSummaryType_CCModifyDate	(10)	/**< union variant selector value for member CCModifyDate */
        time_t CCModifyDate;
        #define SOAP_UNION__ns3__union_AccountSummaryType_CurrentBalance	(11)	/**< union variant selector value for member CurrentBalance */
        ns2__AmountType *CurrentBalance;
        #define SOAP_UNION__ns3__union_AccountSummaryType_LastAmountPaid	(12)	/**< union variant selector value for member LastAmountPaid */
        ns2__AmountType *LastAmountPaid;
        #define SOAP_UNION__ns3__union_AccountSummaryType_LastInvoiceAmount	(13)	/**< union variant selector value for member LastInvoiceAmount */
        ns2__AmountType *LastInvoiceAmount;
        #define SOAP_UNION__ns3__union_AccountSummaryType_LastInvoiceDate	(14)	/**< union variant selector value for member LastInvoiceDate */
        time_t LastInvoiceDate;
        #define SOAP_UNION__ns3__union_AccountSummaryType_LastPaymentDate	(15)	/**< union variant selector value for member LastPaymentDate */
        time_t LastPaymentDate;
        #define SOAP_UNION__ns3__union_AccountSummaryType_PastDue	(16)	/**< union variant selector value for member PastDue */
        bool PastDue;
        #define SOAP_UNION__ns3__union_AccountSummaryType_PaymentMethod	(17)	/**< union variant selector value for member PaymentMethod */
        enum ns3__SellerPaymentMethodCodeType PaymentMethod;
};
#endif

/* paypal.h:7037 */
#ifndef SOAP_TYPE___ns3__union_AccountSummaryType
#define SOAP_TYPE___ns3__union_AccountSummaryType (612)
/* Wrapper: */
class SOAP_CMAC __ns3__union_AccountSummaryType {
      public:
        /// Union with union _ns3__union_AccountSummaryType variant selector __union_AccountSummaryType set to one of: SOAP_UNION__ns3__union_AccountSummaryType_AccountState SOAP_UNION__ns3__union_AccountSummaryType_AdditionalAccount SOAP_UNION__ns3__union_AccountSummaryType_AdditionalAccountsCount SOAP_UNION__ns3__union_AccountSummaryType_AmountPastDue SOAP_UNION__ns3__union_AccountSummaryType_BankAccountInfo SOAP_UNION__ns3__union_AccountSummaryType_BankModifyDate SOAP_UNION__ns3__union_AccountSummaryType_BillingCycleDate SOAP_UNION__ns3__union_AccountSummaryType_CCExp SOAP_UNION__ns3__union_AccountSummaryType_CCInfo SOAP_UNION__ns3__union_AccountSummaryType_CCModifyDate SOAP_UNION__ns3__union_AccountSummaryType_CurrentBalance SOAP_UNION__ns3__union_AccountSummaryType_LastAmountPaid SOAP_UNION__ns3__union_AccountSummaryType_LastInvoiceAmount SOAP_UNION__ns3__union_AccountSummaryType_LastInvoiceDate SOAP_UNION__ns3__union_AccountSummaryType_LastPaymentDate SOAP_UNION__ns3__union_AccountSummaryType_PastDue SOAP_UNION__ns3__union_AccountSummaryType_PaymentMethod
        int __union_AccountSummaryType;
        union _ns3__union_AccountSummaryType union_AccountSummaryType;
      public:
        /// Return unique type id SOAP_TYPE___ns3__union_AccountSummaryType
        virtual int soap_type(void) const { return SOAP_TYPE___ns3__union_AccountSummaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns3__union_AccountSummaryType, default initialized and not managed by a soap context
        virtual __ns3__union_AccountSummaryType *soap_alloc(void) const { return SOAP_NEW(__ns3__union_AccountSummaryType); }
      public:
        /// Constructor with initializations
        __ns3__union_AccountSummaryType() : __union_AccountSummaryType() { }
        virtual ~__ns3__union_AccountSummaryType() { }
        /// Friend allocator used by soap_new___ns3__union_AccountSummaryType(struct soap*, int)
        friend SOAP_FMAC1 __ns3__union_AccountSummaryType * SOAP_FMAC2 soap_instantiate___ns3__union_AccountSummaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:733 */
#ifndef SOAP_TYPE_ns3__AccountSummaryType
#define SOAP_TYPE_ns3__AccountSummaryType (199)
/* complex XSD type 'ns3:AccountSummaryType': */
class SOAP_CMAC ns3__AccountSummaryType {
      public:
        /// Sequence of elements '-union-AccountSummaryType' of XSD type '-ns3:union-AccountSummaryType' stored in dynamic array __union_AccountSummaryType of length __size_AccountSummaryType
        int __size_AccountSummaryType;
        __ns3__union_AccountSummaryType *__union_AccountSummaryType;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AccountSummaryType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AccountSummaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AccountSummaryType, default initialized and not managed by a soap context
        virtual ns3__AccountSummaryType *soap_alloc(void) const { return SOAP_NEW(ns3__AccountSummaryType); }
      public:
        /// Constructor with initializations
        ns3__AccountSummaryType() : __size_AccountSummaryType(), __union_AccountSummaryType(), __mixed(), soap() { }
        virtual ~ns3__AccountSummaryType() { }
        /// Friend allocator used by soap_new_ns3__AccountSummaryType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AccountSummaryType * SOAP_FMAC2 soap_instantiate_ns3__AccountSummaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:736 */
#ifndef SOAP_TYPE_ns3__BuyerType
#define SOAP_TYPE_ns3__BuyerType (200)
/* complex XSD type 'ns3:BuyerType': */
class SOAP_CMAC ns3__BuyerType {
      public:
        /// Optional element 'ns3:ShippingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *ShippingAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BuyerType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BuyerType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BuyerType, default initialized and not managed by a soap context
        virtual ns3__BuyerType *soap_alloc(void) const { return SOAP_NEW(ns3__BuyerType); }
      public:
        /// Constructor with initializations
        ns3__BuyerType() : ShippingAddress(), soap() { }
        virtual ~ns3__BuyerType() { }
        /// Friend allocator used by soap_new_ns3__BuyerType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BuyerType * SOAP_FMAC2 soap_instantiate_ns3__BuyerType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:739 */
#ifndef SOAP_TYPE_ns3__SellerType
#define SOAP_TYPE_ns3__SellerType (201)
/* complex XSD type 'ns3:SellerType': */
class SOAP_CMAC ns3__SellerType {
      public:
        /// Required element 'ns3:AllowPaymentEdit' of XSD type 'xsd:boolean'
        bool AllowPaymentEdit;
        /// Optional element 'ns3:BillingCurrency' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType *BillingCurrency;
        /// Required element 'ns3:CheckoutEnabled' of XSD type 'xsd:boolean'
        bool CheckoutEnabled;
        /// Required element 'ns3:CIPBankAccountStored' of XSD type 'xsd:boolean'
        bool CIPBankAccountStored;
        /// Required element 'ns3:GoodStanding' of XSD type 'xsd:boolean'
        bool GoodStanding;
        /// Required element 'ns3:LiveAuctionAuthorized' of XSD type 'xsd:boolean'
        bool LiveAuctionAuthorized;
        /// Required element 'ns3:MerchandizingPref' of XSD type 'ns3:MerchandizingPrefCodeType'
        enum ns3__MerchandizingPrefCodeType MerchandizingPref;
        /// Required element 'ns3:QualifiesForB2BVAT' of XSD type 'xsd:boolean'
        bool QualifiesForB2BVAT;
        /// Required element 'ns3:SellerLevel' of XSD type 'ns3:SellerLevelCodeType'
        enum ns3__SellerLevelCodeType SellerLevel;
        /// Optional element 'ns3:SellerPaymentAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *SellerPaymentAddress;
        /// Optional element 'ns3:SchedulingInfo' of XSD type 'ns3:SchedulingInfoType'
        ns3__SchedulingInfoType *SchedulingInfo;
        /// Required element 'ns3:StoreOwner' of XSD type 'xsd:boolean'
        bool StoreOwner;
        /// Optional element 'ns3:StoreURL' of XSD type 'xsd:anyURI'
        std::string *StoreURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SellerType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SellerType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SellerType, default initialized and not managed by a soap context
        virtual ns3__SellerType *soap_alloc(void) const { return SOAP_NEW(ns3__SellerType); }
      public:
        /// Constructor with initializations
        ns3__SellerType() : AllowPaymentEdit(), BillingCurrency(), CheckoutEnabled(), CIPBankAccountStored(), GoodStanding(), LiveAuctionAuthorized(), MerchandizingPref(), QualifiesForB2BVAT(), SellerLevel(), SellerPaymentAddress(), SchedulingInfo(), StoreOwner(), StoreURL(), soap() { }
        virtual ~ns3__SellerType() { }
        /// Friend allocator used by soap_new_ns3__SellerType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SellerType * SOAP_FMAC2 soap_instantiate_ns3__SellerType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:742 */
#ifndef SOAP_TYPE_ns3__FeeType
#define SOAP_TYPE_ns3__FeeType (202)
/* complex XSD type 'ns3:FeeType': */
class SOAP_CMAC ns3__FeeType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Fee' of XSD type 'ns2:AmountType'
        ns2__AmountType *Fee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FeeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FeeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FeeType, default initialized and not managed by a soap context
        virtual ns3__FeeType *soap_alloc(void) const { return SOAP_NEW(ns3__FeeType); }
      public:
        /// Constructor with initializations
        ns3__FeeType() : Name(), Fee(), soap() { }
        virtual ~ns3__FeeType() { }
        /// Friend allocator used by soap_new_ns3__FeeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FeeType * SOAP_FMAC2 soap_instantiate_ns3__FeeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:745 */
#ifndef SOAP_TYPE_ns3__FeesType
#define SOAP_TYPE_ns3__FeesType (203)
/* complex XSD type 'ns3:FeesType': */
class SOAP_CMAC ns3__FeesType {
      public:
        /// Required element 'ns3:Fee' of XSD type 'ns3:FeeType'
        std::vector<ns3__FeeType *> Fee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FeesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FeesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FeesType, default initialized and not managed by a soap context
        virtual ns3__FeesType *soap_alloc(void) const { return SOAP_NEW(ns3__FeesType); }
      public:
        /// Constructor with initializations
        ns3__FeesType() : Fee(), soap() { }
        virtual ~ns3__FeesType() { }
        /// Friend allocator used by soap_new_ns3__FeesType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FeesType * SOAP_FMAC2 soap_instantiate_ns3__FeesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:748 */
#ifndef SOAP_TYPE_ns3__ShippingCarrierDetailsType
#define SOAP_TYPE_ns3__ShippingCarrierDetailsType (204)
/* complex XSD type 'ns3:ShippingCarrierDetailsType': */
class SOAP_CMAC ns3__ShippingCarrierDetailsType {
      public:
        /// Optional element 'ns3:CarrierShippingFee' of XSD type 'ns2:AmountType'
        ns2__AmountType *CarrierShippingFee;
        /// Optional element 'ns3:InsuranceFee' of XSD type 'ns2:AmountType'
        ns2__AmountType *InsuranceFee;
        /// Optional element 'ns3:InsuranceOption' of XSD type 'ns3:InsuranceOptionCodeType'
        enum ns3__InsuranceOptionCodeType *InsuranceOption;
        /// Optional element 'ns3:PackagingHandlingCosts' of XSD type 'ns2:AmountType'
        ns2__AmountType *PackagingHandlingCosts;
        /// Optional element 'ns3:ShippingRateErrorMessage' of XSD type 'xsd:string'
        std::string *ShippingRateErrorMessage;
        /// Required element 'ns3:ShippingService' of XSD type 'ns3:ShippingServiceCodeType'
        enum ns3__ShippingServiceCodeType ShippingService;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ShippingCarrierDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ShippingCarrierDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ShippingCarrierDetailsType, default initialized and not managed by a soap context
        virtual ns3__ShippingCarrierDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ShippingCarrierDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ShippingCarrierDetailsType() : CarrierShippingFee(), InsuranceFee(), InsuranceOption(), PackagingHandlingCosts(), ShippingRateErrorMessage(), ShippingService(), soap() { }
        virtual ~ns3__ShippingCarrierDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ShippingCarrierDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ShippingCarrierDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ShippingCarrierDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:751 */
#ifndef SOAP_TYPE_ns3__CalculatedShippingRateType
#define SOAP_TYPE_ns3__CalculatedShippingRateType (205)
/* complex XSD type 'ns3:CalculatedShippingRateType': */
class SOAP_CMAC ns3__CalculatedShippingRateType {
      public:
        /// Optional element 'ns3:OriginatingPostalCode' of XSD type 'xsd:string'
        std::string *OriginatingPostalCode;
        /// Optional element 'ns3:ShippingIrregular' of XSD type 'xsd:boolean'
        bool *ShippingIrregular;
        /// Optional element 'ns3:CarrierDetails' of XSD type 'ns3:ShippingCarrierDetailsType'
        std::vector<ns3__ShippingCarrierDetailsType *> CarrierDetails;
        /// Optional element 'ns3:ShippingPackage' of XSD type 'ns3:ShippingPackageCodeType'
        enum ns3__ShippingPackageCodeType *ShippingPackage;
        /// Optional element 'ns3:WeightMajor' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *WeightMajor;
        /// Optional element 'ns3:WeightMinor' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *WeightMinor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CalculatedShippingRateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CalculatedShippingRateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CalculatedShippingRateType, default initialized and not managed by a soap context
        virtual ns3__CalculatedShippingRateType *soap_alloc(void) const { return SOAP_NEW(ns3__CalculatedShippingRateType); }
      public:
        /// Constructor with initializations
        ns3__CalculatedShippingRateType() : OriginatingPostalCode(), ShippingIrregular(), CarrierDetails(), ShippingPackage(), WeightMajor(), WeightMinor(), soap() { }
        virtual ~ns3__CalculatedShippingRateType() { }
        /// Friend allocator used by soap_new_ns3__CalculatedShippingRateType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CalculatedShippingRateType * SOAP_FMAC2 soap_instantiate_ns3__CalculatedShippingRateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:754 */
#ifndef SOAP_TYPE_ns3__FlatShippingRateType
#define SOAP_TYPE_ns3__FlatShippingRateType (206)
/* complex XSD type 'ns3:FlatShippingRateType': */
class SOAP_CMAC ns3__FlatShippingRateType {
      public:
        /// Optional element 'ns3:AdditionalShippingCosts' of XSD type 'ns2:AmountType'
        ns2__AmountType *AdditionalShippingCosts;
        /// Optional element 'ns3:FlatShippingHandlingCosts' of XSD type 'ns2:AmountType'
        ns2__AmountType *FlatShippingHandlingCosts;
        /// Optional element 'ns3:InsuranceFee' of XSD type 'ns2:AmountType'
        ns2__AmountType *InsuranceFee;
        /// Optional element 'ns3:InsuranceOption' of XSD type 'ns3:InsuranceOptionCodeType'
        enum ns3__InsuranceOptionCodeType *InsuranceOption;
        /// Optional element 'ns3:ShippingService' of XSD type 'ns3:ShippingServiceCodeType'
        enum ns3__ShippingServiceCodeType *ShippingService;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FlatShippingRateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FlatShippingRateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FlatShippingRateType, default initialized and not managed by a soap context
        virtual ns3__FlatShippingRateType *soap_alloc(void) const { return SOAP_NEW(ns3__FlatShippingRateType); }
      public:
        /// Constructor with initializations
        ns3__FlatShippingRateType() : AdditionalShippingCosts(), FlatShippingHandlingCosts(), InsuranceFee(), InsuranceOption(), ShippingService(), soap() { }
        virtual ~ns3__FlatShippingRateType() { }
        /// Friend allocator used by soap_new_ns3__FlatShippingRateType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FlatShippingRateType * SOAP_FMAC2 soap_instantiate_ns3__FlatShippingRateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:757 */
#ifndef SOAP_TYPE_ns3__SalesTaxType
#define SOAP_TYPE_ns3__SalesTaxType (207)
/* complex XSD type 'ns3:SalesTaxType': */
class SOAP_CMAC ns3__SalesTaxType {
      public:
        /// Optional element 'ns3:SalesTaxPercent' of XSD type 'xsd:float'
        float *SalesTaxPercent;
        /// Optional element 'ns3:SalesTaxState' of XSD type 'xsd:string'
        std::string *SalesTaxState;
        /// Optional element 'ns3:ShippingIncludedInTax' of XSD type 'xsd:boolean'
        bool *ShippingIncludedInTax;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SalesTaxType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SalesTaxType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SalesTaxType, default initialized and not managed by a soap context
        virtual ns3__SalesTaxType *soap_alloc(void) const { return SOAP_NEW(ns3__SalesTaxType); }
      public:
        /// Constructor with initializations
        ns3__SalesTaxType() : SalesTaxPercent(), SalesTaxState(), ShippingIncludedInTax(), soap() { }
        virtual ~ns3__SalesTaxType() { }
        /// Friend allocator used by soap_new_ns3__SalesTaxType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SalesTaxType * SOAP_FMAC2 soap_instantiate_ns3__SalesTaxType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:760 */
#ifndef SOAP_TYPE_ns3__ShippingDetailsType
#define SOAP_TYPE_ns3__ShippingDetailsType (208)
/* complex XSD type 'ns3:ShippingDetailsType': */
class SOAP_CMAC ns3__ShippingDetailsType {
      public:
        /// Optional element 'ns3:AllowPaymentEdit' of XSD type 'xsd:boolean'
        bool *AllowPaymentEdit;
        /// Optional element 'ns3:CalculatedShippingRate' of XSD type 'ns3:CalculatedShippingRateType'
        ns3__CalculatedShippingRateType *CalculatedShippingRate;
        /// Optional element 'ns3:ChangePaymentInstructions' of XSD type 'xsd:boolean'
        bool *ChangePaymentInstructions;
        /// Optional element 'ns3:FlatShippingRate' of XSD type 'ns3:FlatShippingRateType'
        std::vector<ns3__FlatShippingRateType *> FlatShippingRate;
        /// Optional element 'ns3:InsuranceTotal' of XSD type 'ns2:AmountType'
        ns2__AmountType *InsuranceTotal;
        /// Optional element 'ns3:InsuranceWanted' of XSD type 'xsd:boolean'
        bool *InsuranceWanted;
        /// Optional element 'ns3:PaymentInstructions' of XSD type 'xsd:string'
        std::string *PaymentInstructions;
        /// Optional element 'ns3:SalesTax' of XSD type 'ns3:SalesTaxType'
        ns3__SalesTaxType *SalesTax;
        /// Optional element 'ns3:SellerPostalCode' of XSD type 'xsd:string'
        std::string *SellerPostalCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ShippingDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ShippingDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ShippingDetailsType, default initialized and not managed by a soap context
        virtual ns3__ShippingDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ShippingDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ShippingDetailsType() : AllowPaymentEdit(), CalculatedShippingRate(), ChangePaymentInstructions(), FlatShippingRate(), InsuranceTotal(), InsuranceWanted(), PaymentInstructions(), SalesTax(), SellerPostalCode(), soap() { }
        virtual ~ns3__ShippingDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ShippingDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ShippingDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ShippingDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:763 */
#ifndef SOAP_TYPE_ns3__SiteHostedPictureType
#define SOAP_TYPE_ns3__SiteHostedPictureType (209)
/* complex XSD type 'ns3:SiteHostedPictureType': */
class SOAP_CMAC ns3__SiteHostedPictureType {
      public:
        /// Sequence of 0 to 6 elements 'ns3:PictureURL' of XSD type 'xsd:anyURI'
        std::vector<std::string> PictureURL;
        /// Optional element 'ns3:PhotoDisplay' of XSD type 'ns3:PhotoDisplayCodeType'
        enum ns3__PhotoDisplayCodeType *PhotoDisplay;
        /// Optional element 'ns3:GalleryType' of XSD type 'ns3:GalleryTypeCodeType'
        enum ns3__GalleryTypeCodeType *GalleryType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SiteHostedPictureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SiteHostedPictureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SiteHostedPictureType, default initialized and not managed by a soap context
        virtual ns3__SiteHostedPictureType *soap_alloc(void) const { return SOAP_NEW(ns3__SiteHostedPictureType); }
      public:
        /// Constructor with initializations
        ns3__SiteHostedPictureType() : PictureURL(), PhotoDisplay(), GalleryType(), soap() { }
        virtual ~ns3__SiteHostedPictureType() { }
        /// Friend allocator used by soap_new_ns3__SiteHostedPictureType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SiteHostedPictureType * SOAP_FMAC2 soap_instantiate_ns3__SiteHostedPictureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:766 */
#ifndef SOAP_TYPE_ns3__VendorHostedPictureType
#define SOAP_TYPE_ns3__VendorHostedPictureType (210)
/* complex XSD type 'ns3:VendorHostedPictureType': */
class SOAP_CMAC ns3__VendorHostedPictureType {
      public:
        /// Optional element 'ns3:PictureURL' of XSD type 'xsd:anyURI'
        std::string *PictureURL;
        /// Optional element 'ns3:GalleryURL' of XSD type 'xsd:anyURI'
        std::string *GalleryURL;
        /// Optional element 'ns3:GalleryType' of XSD type 'ns3:GalleryTypeCodeType'
        enum ns3__GalleryTypeCodeType *GalleryType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__VendorHostedPictureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__VendorHostedPictureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__VendorHostedPictureType, default initialized and not managed by a soap context
        virtual ns3__VendorHostedPictureType *soap_alloc(void) const { return SOAP_NEW(ns3__VendorHostedPictureType); }
      public:
        /// Constructor with initializations
        ns3__VendorHostedPictureType() : PictureURL(), GalleryURL(), GalleryType(), soap() { }
        virtual ~ns3__VendorHostedPictureType() { }
        /// Friend allocator used by soap_new_ns3__VendorHostedPictureType(struct soap*, int)
        friend SOAP_FMAC1 ns3__VendorHostedPictureType * SOAP_FMAC2 soap_instantiate_ns3__VendorHostedPictureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:769 */
#ifndef SOAP_TYPE_ns3__ValType
#define SOAP_TYPE_ns3__ValType (211)
/* complex XSD type 'ns3:ValType': */
class SOAP_CMAC ns3__ValType {
      public:
        /// Required element 'ns3:ValueLiteral' of XSD type 'xsd:string'
        std::string ValueLiteral;
        /// optional attribute 'ValueID' of XSD type 'xsd:string'
        std::string *ValueID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ValType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ValType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ValType, default initialized and not managed by a soap context
        virtual ns3__ValType *soap_alloc(void) const { return SOAP_NEW(ns3__ValType); }
      public:
        /// Constructor with initializations
        ns3__ValType() : ValueLiteral(), ValueID(), soap() { }
        virtual ~ns3__ValType() { }
        /// Friend allocator used by soap_new_ns3__ValType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ValType * SOAP_FMAC2 soap_instantiate_ns3__ValType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:772 */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (212)
/* complex XSD type 'ns3:AttributeType': */
class SOAP_CMAC ns3__AttributeType {
      public:
        /// Required element 'ns3:Value' of XSD type 'ns3:ValType'
        std::vector<ns3__ValType *> Value;
        /// optional attribute 'AttributeID' of XSD type 'xsd:string'
        std::string *AttributeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AttributeType, default initialized and not managed by a soap context
        virtual ns3__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeType); }
      public:
        /// Constructor with initializations
        ns3__AttributeType() : Value(), AttributeID(), soap() { }
        virtual ~ns3__AttributeType() { }
        /// Friend allocator used by soap_new_ns3__AttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 soap_instantiate_ns3__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:775 */
#ifndef SOAP_TYPE_ns3__AttributeSetType
#define SOAP_TYPE_ns3__AttributeSetType (213)
/* complex XSD type 'ns3:AttributeSetType': */
class SOAP_CMAC ns3__AttributeSetType {
      public:
        /// Required element 'ns3:Attribute' of XSD type 'ns3:AttributeType'
        std::vector<ns3__AttributeType *> Attribute;
        /// optional attribute 'AttributeSetID' of XSD type 'xsd:string'
        std::string *AttributeSetID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AttributeSetType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AttributeSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AttributeSetType, default initialized and not managed by a soap context
        virtual ns3__AttributeSetType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSetType); }
      public:
        /// Constructor with initializations
        ns3__AttributeSetType() : Attribute(), AttributeSetID(), soap() { }
        virtual ~ns3__AttributeSetType() { }
        /// Friend allocator used by soap_new_ns3__AttributeSetType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AttributeSetType * SOAP_FMAC2 soap_instantiate_ns3__AttributeSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:778 */
#ifndef SOAP_TYPE_ns3__ListOfAttributeSetType
#define SOAP_TYPE_ns3__ListOfAttributeSetType (214)
/* complex XSD type 'ns3:ListOfAttributeSetType': */
class SOAP_CMAC ns3__ListOfAttributeSetType {
      public:
        /// Required element 'ns3:AttributeSet' of XSD type 'ns3:AttributeSetType'
        std::vector<ns3__AttributeSetType *> AttributeSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ListOfAttributeSetType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ListOfAttributeSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ListOfAttributeSetType, default initialized and not managed by a soap context
        virtual ns3__ListOfAttributeSetType *soap_alloc(void) const { return SOAP_NEW(ns3__ListOfAttributeSetType); }
      public:
        /// Constructor with initializations
        ns3__ListOfAttributeSetType() : AttributeSet(), soap() { }
        virtual ~ns3__ListOfAttributeSetType() { }
        /// Friend allocator used by soap_new_ns3__ListOfAttributeSetType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ListOfAttributeSetType * SOAP_FMAC2 soap_instantiate_ns3__ListOfAttributeSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:781 */
#ifndef SOAP_TYPE_ns3__CategoryType
#define SOAP_TYPE_ns3__CategoryType (215)
/* complex XSD type 'ns3:CategoryType': */
class SOAP_CMAC ns3__CategoryType {
      public:
        /// Optional element 'ns3:AutoPayEnabled' of XSD type 'xsd:boolean'
        bool *AutoPayEnabled;
        /// Optional element 'ns3:B2BVATEnabled' of XSD type 'xsd:boolean'
        bool *B2BVATEnabled;
        /// Optional element 'ns3:CatalogEnabled' of XSD type 'xsd:boolean'
        bool *CatalogEnabled;
        /// Required element 'ns3:CategoryID' of XSD type 'xsd:string'
        std::string CategoryID;
        /// Optional element 'ns3:CategoryLevel' of XSD type 'xsd:int'
        int *CategoryLevel;
        /// Optional element 'ns3:CategoryName' of XSD type 'xsd:string'
        std::string *CategoryName;
        /// Optional element 'ns3:CategoryParentID' of XSD type 'xsd:string'
        std::vector<std::string> CategoryParentID;
        /// Optional element 'ns3:CategoryParentName' of XSD type 'xsd:string'
        std::vector<std::string> CategoryParentName;
        /// Optional element 'ns3:CSIDList' of XSD type 'xsd:string'
        std::vector<std::string> CSIDList;
        /// Optional element 'ns3:Expired' of XSD type 'xsd:boolean'
        bool *Expired;
        /// Optional element 'ns3:IntlAutosFixedCat' of XSD type 'xsd:boolean'
        bool *IntlAutosFixedCat;
        /// Optional element 'ns3:LeafCategory' of XSD type 'xsd:boolean'
        bool *LeafCategory;
        /// Optional element 'ns3:Virtual' of XSD type 'xsd:boolean'
        bool *Virtual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CategoryType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CategoryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CategoryType, default initialized and not managed by a soap context
        virtual ns3__CategoryType *soap_alloc(void) const { return SOAP_NEW(ns3__CategoryType); }
      public:
        /// Constructor with initializations
        ns3__CategoryType() : AutoPayEnabled(), B2BVATEnabled(), CatalogEnabled(), CategoryID(), CategoryLevel(), CategoryName(), CategoryParentID(), CategoryParentName(), CSIDList(), Expired(), IntlAutosFixedCat(), LeafCategory(), Virtual(), soap() { }
        virtual ~ns3__CategoryType() { }
        /// Friend allocator used by soap_new_ns3__CategoryType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CategoryType * SOAP_FMAC2 soap_instantiate_ns3__CategoryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:784 */
#ifndef SOAP_TYPE_ns3__StorefrontType
#define SOAP_TYPE_ns3__StorefrontType (216)
/* complex XSD type 'ns3:StorefrontType': */
class SOAP_CMAC ns3__StorefrontType {
      public:
        /// Required element 'ns3:StoreCategoryID' of XSD type 'xsd:int'
        int StoreCategoryID;
        /// Optional element 'ns3:StoreURL' of XSD type 'xsd:anyURI'
        std::string *StoreURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__StorefrontType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__StorefrontType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__StorefrontType, default initialized and not managed by a soap context
        virtual ns3__StorefrontType *soap_alloc(void) const { return SOAP_NEW(ns3__StorefrontType); }
      public:
        /// Constructor with initializations
        ns3__StorefrontType() : StoreCategoryID(), StoreURL(), soap() { }
        virtual ~ns3__StorefrontType() { }
        /// Friend allocator used by soap_new_ns3__StorefrontType(struct soap*, int)
        friend SOAP_FMAC1 ns3__StorefrontType * SOAP_FMAC2 soap_instantiate_ns3__StorefrontType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:787 */
#ifndef SOAP_TYPE_ns3__ListingDesignerType
#define SOAP_TYPE_ns3__ListingDesignerType (217)
/* complex XSD type 'ns3:ListingDesignerType': */
class SOAP_CMAC ns3__ListingDesignerType {
      public:
        /// Optional element 'ns3:LayoutID' of XSD type 'xsd:int'
        int *LayoutID;
        /// Optional element 'ns3:OptimalPictureSize' of XSD type 'xsd:boolean'
        bool *OptimalPictureSize;
        /// Optional element 'ns3:ThemeID' of XSD type 'xsd:int'
        int *ThemeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ListingDesignerType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ListingDesignerType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ListingDesignerType, default initialized and not managed by a soap context
        virtual ns3__ListingDesignerType *soap_alloc(void) const { return SOAP_NEW(ns3__ListingDesignerType); }
      public:
        /// Constructor with initializations
        ns3__ListingDesignerType() : LayoutID(), OptimalPictureSize(), ThemeID(), soap() { }
        virtual ~ns3__ListingDesignerType() { }
        /// Friend allocator used by soap_new_ns3__ListingDesignerType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ListingDesignerType * SOAP_FMAC2 soap_instantiate_ns3__ListingDesignerType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:790 */
#ifndef SOAP_TYPE_ns3__CharityType
#define SOAP_TYPE_ns3__CharityType (218)
/* complex XSD type 'ns3:CharityType': */
class SOAP_CMAC ns3__CharityType {
      public:
        /// Optional element 'ns3:CharityName' of XSD type 'xsd:string'
        std::string *CharityName;
        /// Optional element 'ns3:CharityNumber' of XSD type 'xsd:int'
        int *CharityNumber;
        /// Optional element 'ns3:DonationPercent' of XSD type 'xsd:float'
        float *DonationPercent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CharityType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CharityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CharityType, default initialized and not managed by a soap context
        virtual ns3__CharityType *soap_alloc(void) const { return SOAP_NEW(ns3__CharityType); }
      public:
        /// Constructor with initializations
        ns3__CharityType() : CharityName(), CharityNumber(), DonationPercent(), soap() { }
        virtual ~ns3__CharityType() { }
        /// Friend allocator used by soap_new_ns3__CharityType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CharityType * SOAP_FMAC2 soap_instantiate_ns3__CharityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:793 */
#ifndef SOAP_TYPE_ns3__SellingStatusType
#define SOAP_TYPE_ns3__SellingStatusType (219)
/* complex XSD type 'ns3:SellingStatusType': */
class SOAP_CMAC ns3__SellingStatusType {
      public:
        /// Optional element 'ns3:BidCount' of XSD type 'xsd:int'
        int *BidCount;
        /// Optional element 'ns3:BidIncrement' of XSD type 'ns2:AmountType'
        ns2__AmountType *BidIncrement;
        /// Optional element 'ns3:ConvertedCurrentPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedCurrentPrice;
        /// Required element 'ns3:CurrentPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *CurrentPrice;
        /// Optional element 'ns3:HighBidder' of XSD type 'ns3:UserType'
        ns3__UserType *HighBidder;
        /// Optional element 'ns3:LeadCount' of XSD type 'xsd:int'
        int *LeadCount;
        /// Optional element 'ns3:MinimumToBid' of XSD type 'ns2:AmountType'
        ns2__AmountType *MinimumToBid;
        /// Required element 'ns3:QuantitySold' of XSD type 'xsd:int'
        int QuantitySold;
        /// Optional element 'ns3:ReserveMet' of XSD type 'xsd:boolean'
        bool *ReserveMet;
        /// Optional element 'ns3:SecondChanceEligible' of XSD type 'xsd:boolean'
        bool *SecondChanceEligible;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SellingStatusType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SellingStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SellingStatusType, default initialized and not managed by a soap context
        virtual ns3__SellingStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__SellingStatusType); }
      public:
        /// Constructor with initializations
        ns3__SellingStatusType() : BidCount(), BidIncrement(), ConvertedCurrentPrice(), CurrentPrice(), HighBidder(), LeadCount(), MinimumToBid(), QuantitySold(), ReserveMet(), SecondChanceEligible(), soap() { }
        virtual ~ns3__SellingStatusType() { }
        /// Friend allocator used by soap_new_ns3__SellingStatusType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SellingStatusType * SOAP_FMAC2 soap_instantiate_ns3__SellingStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:796 */
#ifndef SOAP_TYPE_ns3__ReviseStatusType
#define SOAP_TYPE_ns3__ReviseStatusType (220)
/* complex XSD type 'ns3:ReviseStatusType': */
class SOAP_CMAC ns3__ReviseStatusType {
      public:
        /// Required element 'ns3:ItemRevised' of XSD type 'xsd:boolean'
        bool ItemRevised;
        /// Optional element 'ns3:BuyItNowAdded' of XSD type 'xsd:boolean'
        bool *BuyItNowAdded;
        /// Optional element 'ns3:BuyItNowLowered' of XSD type 'xsd:boolean'
        bool *BuyItNowLowered;
        /// Optional element 'ns3:ReserveLowered' of XSD type 'xsd:boolean'
        bool *ReserveLowered;
        /// Optional element 'ns3:ReserveRemoved' of XSD type 'xsd:boolean'
        bool *ReserveRemoved;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReviseStatusType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ReviseStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReviseStatusType, default initialized and not managed by a soap context
        virtual ns3__ReviseStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__ReviseStatusType); }
      public:
        /// Constructor with initializations
        ns3__ReviseStatusType() : ItemRevised(), BuyItNowAdded(), BuyItNowLowered(), ReserveLowered(), ReserveRemoved(), soap() { }
        virtual ~ns3__ReviseStatusType() { }
        /// Friend allocator used by soap_new_ns3__ReviseStatusType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReviseStatusType * SOAP_FMAC2 soap_instantiate_ns3__ReviseStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:799 */
#ifndef SOAP_TYPE_ns3__ListingDetailsType
#define SOAP_TYPE_ns3__ListingDetailsType (221)
/* complex XSD type 'ns3:ListingDetailsType': */
class SOAP_CMAC ns3__ListingDetailsType {
      public:
        /// Optional element 'ns3:Adult' of XSD type 'xsd:boolean'
        bool *Adult;
        /// Optional element 'ns3:BindingAuction' of XSD type 'xsd:boolean'
        bool *BindingAuction;
        /// Optional element 'ns3:CheckoutEnabled' of XSD type 'xsd:boolean'
        bool *CheckoutEnabled;
        /// Optional element 'ns3:ConvertedBuyItNowPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedBuyItNowPrice;
        /// Optional element 'ns3:ConvertedStartPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedStartPrice;
        /// Optional element 'ns3:ConvertedReservePrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedReservePrice;
        /// Optional element 'ns3:HasReservePrice' of XSD type 'xsd:boolean'
        bool *HasReservePrice;
        /// Optional element 'ns3:RegionName' of XSD type 'xsd:string'
        std::string *RegionName;
        /// Optional element 'ns3:RelistedItemID' of XSD type 'ns3:ItemIDType'
        std::string *RelistedItemID;
        /// Optional element 'ns3:SecondChanceOriginalItemID' of XSD type 'ns3:ItemIDType'
        std::string *SecondChanceOriginalItemID;
        /// Optional element 'ns3:StartTime' of XSD type 'xsd:dateTime'
        time_t *StartTime;
        /// Optional element 'ns3:EndTime' of XSD type 'xsd:dateTime'
        time_t *EndTime;
        /// Optional element 'ns3:ViewItemURL' of XSD type 'xsd:anyURI'
        std::string *ViewItemURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ListingDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ListingDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ListingDetailsType, default initialized and not managed by a soap context
        virtual ns3__ListingDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ListingDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ListingDetailsType() : Adult(), BindingAuction(), CheckoutEnabled(), ConvertedBuyItNowPrice(), ConvertedStartPrice(), ConvertedReservePrice(), HasReservePrice(), RegionName(), RelistedItemID(), SecondChanceOriginalItemID(), StartTime(), EndTime(), ViewItemURL(), soap() { }
        virtual ~ns3__ListingDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ListingDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ListingDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ListingDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:802 */
#ifndef SOAP_TYPE_ns3__ItemType
#define SOAP_TYPE_ns3__ItemType (222)
/* complex XSD type 'ns3:ItemType': */
class SOAP_CMAC ns3__ItemType {
      public:
        /// Optional element 'ns3:ApplicationData' of XSD type 'xsd:string'
        std::string *ApplicationData;
        /// Optional element 'ns3:ListOfAttributeSets' of XSD type 'ns3:ListOfAttributeSetType'
        ns3__ListOfAttributeSetType *ListOfAttributeSets;
        /// Optional element 'ns3:AutoPay' of XSD type 'xsd:boolean'
        bool *AutoPay;
        /// Optional element 'ns3:BuyerProtection' of XSD type 'ns3:BuyerProtectionCodeType'
        enum ns3__BuyerProtectionCodeType *BuyerProtection;
        /// Optional element 'ns3:BuyItNowPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *BuyItNowPrice;
        /// Optional element 'ns3:Charity' of XSD type 'ns3:CharityType'
        ns3__CharityType *Charity;
        /// Optional element 'ns3:Country' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *Country;
        /// Optional element 'ns3:CrossPromotion' of XSD type 'ns3:CrossPromotionsType'
        ns3__CrossPromotionsType *CrossPromotion;
        /// Optional element 'ns3:Currency' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType *Currency;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:Escrow' of XSD type 'ns3:EscrowCodeType'
        enum ns3__EscrowCodeType *Escrow;
        /// Optional element 'ns3:GiftIcon' of XSD type 'xsd:int'
        int *GiftIcon;
        /// Optional element 'ns3:GiftServices' of XSD type 'ns3:GiftServicesCodeType'
        std::vector<enum ns3__GiftServicesCodeType> GiftServices;
        /// Optional element 'ns3:HitCounter' of XSD type 'ns3:HitCounterCodeType'
        enum ns3__HitCounterCodeType *HitCounter;
        /// Optional element 'ns3:ItemID' of XSD type 'ns3:ItemIDType'
        std::string *ItemID;
        /// Optional element 'ns3:ListingDetails' of XSD type 'ns3:ListingDetailsType'
        ns3__ListingDetailsType *ListingDetails;
        /// Optional element 'ns3:ListingDesigner' of XSD type 'ns3:ListingDesignerType'
        ns3__ListingDesignerType *ListingDesigner;
        /// Optional element 'ns3:ListingDuration' of XSD type 'ns3:ListingDurationCodeType'
        enum ns3__ListingDurationCodeType *ListingDuration;
        /// Optional element 'ns3:ListingEnhancement' of XSD type 'ns3:ListingEnhancementsCodeType'
        std::vector<enum ns3__ListingEnhancementsCodeType> ListingEnhancement;
        /// Optional element 'ns3:ListingType' of XSD type 'ns3:ListingTypeCodeType'
        enum ns3__ListingTypeCodeType *ListingType;
        /// Optional element 'ns3:Location' of XSD type 'xsd:string'
        std::string *Location;
        /// Optional element 'ns3:PartnerCode' of XSD type 'xsd:string'
        std::string *PartnerCode;
        /// Optional element 'ns3:PartnerName' of XSD type 'xsd:string'
        std::string *PartnerName;
        /// Optional element 'ns3:PaymentMethods' of XSD type 'ns3:BuyerPaymentMethodCodeType'
        std::vector<enum ns3__BuyerPaymentMethodCodeType> PaymentMethods;
        /// Optional element 'ns3:PayPalEmailAddress' of XSD type 'xsd:string'
        std::string *PayPalEmailAddress;
        /// Optional element 'ns3:PrimaryCategory' of XSD type 'ns3:CategoryType'
        ns3__CategoryType *PrimaryCategory;
        /// Optional element 'ns3:PrivateListing' of XSD type 'xsd:boolean'
        bool *PrivateListing;
        /// Optional element 'ns3:Quantity' of XSD type 'xsd:int'
        int *Quantity;
        /// Optional element 'ns3:RegionID' of XSD type 'xsd:string'
        std::string *RegionID;
        /// Optional element 'ns3:RelistLink' of XSD type 'xsd:boolean'
        bool *RelistLink;
        /// Optional element 'ns3:ReservePrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ReservePrice;
        /// Optional element 'ns3:ReviseStatus' of XSD type 'ns3:ReviseStatusType'
        ns3__ReviseStatusType *ReviseStatus;
        /// Optional element 'ns3:ScheduleTime' of XSD type 'xsd:dateTime'
        time_t *ScheduleTime;
        /// Optional element 'ns3:SecondaryCategory' of XSD type 'ns3:CategoryType'
        ns3__CategoryType *SecondaryCategory;
        /// Optional element 'ns3:SiteHostedPicture' of XSD type 'ns3:SiteHostedPictureType'
        ns3__SiteHostedPictureType *SiteHostedPicture;
        /// Optional element 'ns3:Seller' of XSD type 'ns3:UserType'
        ns3__UserType *Seller;
        /// Optional element 'ns3:SellingStatus' of XSD type 'ns3:SellingStatusType'
        ns3__SellingStatusType *SellingStatus;
        /// Optional element 'ns3:ShippingOption' of XSD type 'ns3:ShippingOptionCodeType'
        enum ns3__ShippingOptionCodeType *ShippingOption;
        /// Optional element 'ns3:ShippingDetails' of XSD type 'ns3:ShippingDetailsType'
        ns3__ShippingDetailsType *ShippingDetails;
        /// Optional element 'ns3:ShippingRegions' of XSD type 'ns3:ShippingRegionCodeType'
        std::vector<enum ns3__ShippingRegionCodeType> ShippingRegions;
        /// Optional element 'ns3:ShippingTerms' of XSD type 'ns3:ShippingTermsCodeType'
        enum ns3__ShippingTermsCodeType *ShippingTerms;
        /// Optional element 'ns3:Site' of XSD type 'ns3:SiteCodeType'
        enum ns3__SiteCodeType *Site;
        /// Optional element 'ns3:StartPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *StartPrice;
        /// Optional element 'ns3:Storefront' of XSD type 'ns3:StorefrontType'
        ns3__StorefrontType *Storefront;
        /// Optional element 'ns3:SubTitle' of XSD type 'xsd:string'
        std::string *SubTitle;
        /// Optional element 'ns3:TimeLeft' of XSD type 'xsd:duration'
        std::chrono::nanoseconds *TimeLeft;
        /// Optional element 'ns3:Title' of XSD type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns3:UUID' of XSD type 'ns2:UUIDType'
        std::string *UUID;
        /// Optional element 'ns3:VATDetails' of XSD type 'ns3:VATDetailsType'
        ns3__VATDetailsType *VATDetails;
        /// Optional element 'ns3:VendorHostedPicture' of XSD type 'ns3:VendorHostedPictureType'
        ns3__VendorHostedPictureType *VendorHostedPicture;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ItemType, default initialized and not managed by a soap context
        virtual ns3__ItemType *soap_alloc(void) const { return SOAP_NEW(ns3__ItemType); }
      public:
        /// Constructor with initializations
        ns3__ItemType() : ApplicationData(), ListOfAttributeSets(), AutoPay(), BuyerProtection(), BuyItNowPrice(), Charity(), Country(), CrossPromotion(), Currency(), Description(), Escrow(), GiftIcon(), GiftServices(), HitCounter(), ItemID(), ListingDetails(), ListingDesigner(), ListingDuration(), ListingEnhancement(), ListingType(), Location(), PartnerCode(), PartnerName(), PaymentMethods(), PayPalEmailAddress(), PrimaryCategory(), PrivateListing(), Quantity(), RegionID(), RelistLink(), ReservePrice(), ReviseStatus(), ScheduleTime(), SecondaryCategory(), SiteHostedPicture(), Seller(), SellingStatus(), ShippingOption(), ShippingDetails(), ShippingRegions(), ShippingTerms(), Site(), StartPrice(), Storefront(), SubTitle(), TimeLeft(), Title(), UUID(), VATDetails(), VendorHostedPicture(), soap() { }
        virtual ~ns3__ItemType() { }
        /// Friend allocator used by soap_new_ns3__ItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ItemType * SOAP_FMAC2 soap_instantiate_ns3__ItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:805 */
#ifndef SOAP_TYPE_ns3__TransactionsType
#define SOAP_TYPE_ns3__TransactionsType (223)
/* complex XSD type 'ns3:TransactionsType': */
class SOAP_CMAC ns3__TransactionsType {
      public:
        /// Required element 'ns3:Transaction' of XSD type 'ns3:TransactionType'
        std::vector<ns3__TransactionType *> Transaction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TransactionsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TransactionsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TransactionsType, default initialized and not managed by a soap context
        virtual ns3__TransactionsType *soap_alloc(void) const { return SOAP_NEW(ns3__TransactionsType); }
      public:
        /// Constructor with initializations
        ns3__TransactionsType() : Transaction(), soap() { }
        virtual ~ns3__TransactionsType() { }
        /// Friend allocator used by soap_new_ns3__TransactionsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TransactionsType * SOAP_FMAC2 soap_instantiate_ns3__TransactionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:808 */
#ifndef SOAP_TYPE_ns3__TransactionType
#define SOAP_TYPE_ns3__TransactionType (224)
/* complex XSD type 'ns3:TransactionType': */
class SOAP_CMAC ns3__TransactionType {
      public:
        /// Optional element 'ns3:AmountPaid' of XSD type 'ns2:AmountType'
        ns2__AmountType *AmountPaid;
        /// Optional element 'ns3:Buyer' of XSD type 'ns3:UserType'
        ns3__UserType *Buyer;
        /// Optional element 'ns3:ShippingDetails' of XSD type 'ns3:ShippingDetailsType'
        ns3__ShippingDetailsType *ShippingDetails;
        /// Optional element 'ns3:ConvertedAmountPaid' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedAmountPaid;
        /// Optional element 'ns3:ConvertedTransactionPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *ConvertedTransactionPrice;
        /// Optional element 'ns3:CreatedDate' of XSD type 'xsd:dateTime'
        time_t *CreatedDate;
        /// Optional element 'ns3:DepositType' of XSD type 'ns3:DepositTypeCodeType'
        enum ns3__DepositTypeCodeType *DepositType;
        /// Optional element 'ns3:Item' of XSD type 'ns3:ItemType'
        ns3__ItemType *Item;
        /// Optional element 'ns3:QuantityPurchased' of XSD type 'xsd:int'
        int *QuantityPurchased;
        /// Optional element 'ns3:ShippingHandlingTotal' of XSD type 'ns2:AmountType'
        ns2__AmountType *ShippingHandlingTotal;
        /// Optional element 'ns3:Status' of XSD type 'ns3:TransactionStatusType'
        ns3__TransactionStatusType *Status;
        /// Optional element 'ns3:TransactionID' of XSD type 'xsd:string'
        std::string *TransactionID;
        /// Optional element 'ns3:AuthorizationID' of XSD type 'xsd:string'
        std::string *AuthorizationID;
        /// Optional element 'ns3:TransactionPrice' of XSD type 'ns2:AmountType'
        ns2__AmountType *TransactionPrice;
        /// Optional element 'ns3:VATPercent' of XSD type 'xsd:decimal'
        std::string *VATPercent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TransactionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TransactionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TransactionType, default initialized and not managed by a soap context
        virtual ns3__TransactionType *soap_alloc(void) const { return SOAP_NEW(ns3__TransactionType); }
      public:
        /// Constructor with initializations
        ns3__TransactionType() : AmountPaid(), Buyer(), ShippingDetails(), ConvertedAmountPaid(), ConvertedTransactionPrice(), CreatedDate(), DepositType(), Item(), QuantityPurchased(), ShippingHandlingTotal(), Status(), TransactionID(), AuthorizationID(), TransactionPrice(), VATPercent(), soap() { }
        virtual ~ns3__TransactionType() { }
        /// Friend allocator used by soap_new_ns3__TransactionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TransactionType * SOAP_FMAC2 soap_instantiate_ns3__TransactionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:811 */
#ifndef SOAP_TYPE_ns3__PaymentMeansType
#define SOAP_TYPE_ns3__PaymentMeansType (225)
/* complex XSD type 'ns3:PaymentMeansType': */
class SOAP_CMAC ns3__PaymentMeansType {
      public:
        /// Required element 'ns3:TypeCodeID' of XSD type 'ns3:SellerPaymentMethodCodeType'
        enum ns3__SellerPaymentMethodCodeType TypeCodeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentMeansType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentMeansType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentMeansType, default initialized and not managed by a soap context
        virtual ns3__PaymentMeansType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentMeansType); }
      public:
        /// Constructor with initializations
        ns3__PaymentMeansType() : TypeCodeID(), soap() { }
        virtual ~ns3__PaymentMeansType() { }
        /// Friend allocator used by soap_new_ns3__PaymentMeansType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentMeansType * SOAP_FMAC2 soap_instantiate_ns3__PaymentMeansType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:814 */
#ifndef SOAP_TYPE_ns3__PaymentType
#define SOAP_TYPE_ns3__PaymentType (226)
/* complex XSD type 'ns3:PaymentType': */
class SOAP_CMAC ns3__PaymentType {
      public:
        /// Required element 'ns3:PaymentMeans' of XSD type 'ns3:PaymentMeansType'
        ns3__PaymentMeansType *PaymentMeans;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentType, default initialized and not managed by a soap context
        virtual ns3__PaymentType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentType); }
      public:
        /// Constructor with initializations
        ns3__PaymentType() : PaymentMeans(), soap() { }
        virtual ~ns3__PaymentType() { }
        /// Friend allocator used by soap_new_ns3__PaymentType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentType * SOAP_FMAC2 soap_instantiate_ns3__PaymentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:817 */
#ifndef SOAP_TYPE_ns3__TransactionStatusType
#define SOAP_TYPE_ns3__TransactionStatusType (227)
/* complex XSD type 'ns3:TransactionStatusType': */
class SOAP_CMAC ns3__TransactionStatusType {
      public:
        /// Optional element 'ns3:eBayPaymentStatus' of XSD type 'xsd:int'
        int *eBayPaymentStatus;
        /// Optional element 'ns3:IncompleteState' of XSD type 'xsd:int'
        int *IncompleteState;
        /// Optional element 'ns3:LastTimeModified' of XSD type 'xsd:dateTime'
        time_t *LastTimeModified;
        /// Optional element 'ns3:PaymentMethodUsed' of XSD type 'ns3:BuyerPaymentMethodCodeType'
        enum ns3__BuyerPaymentMethodCodeType *PaymentMethodUsed;
        /// Optional element 'ns3:StatusIs' of XSD type 'xsd:int'
        int *StatusIs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TransactionStatusType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TransactionStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TransactionStatusType, default initialized and not managed by a soap context
        virtual ns3__TransactionStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__TransactionStatusType); }
      public:
        /// Constructor with initializations
        ns3__TransactionStatusType() : eBayPaymentStatus(), IncompleteState(), LastTimeModified(), PaymentMethodUsed(), StatusIs(), soap() { }
        virtual ~ns3__TransactionStatusType() { }
        /// Friend allocator used by soap_new_ns3__TransactionStatusType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TransactionStatusType * SOAP_FMAC2 soap_instantiate_ns3__TransactionStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:820 */
#ifndef SOAP_TYPE_ns3__UserType
#define SOAP_TYPE_ns3__UserType (228)
/* complex XSD type 'ns3:UserType': */
class SOAP_CMAC ns3__UserType {
      public:
        /// Optional element 'ns3:AboutMePage' of XSD type 'xsd:boolean'
        bool *AboutMePage;
        /// Optional element 'ns3:EAISToken' of XSD type 'xsd:string'
        std::string *EAISToken;
        /// Required element 'ns3:Email' of XSD type 'xsd:string'
        std::string Email;
        /// Optional element 'ns3:FeedbackScore' of XSD type 'xsd:int'
        int *FeedbackScore;
        /// Optional element 'ns3:FeedbackPrivate' of XSD type 'xsd:boolean'
        bool *FeedbackPrivate;
        /// Optional element 'ns3:FeedbackRatingStar' of XSD type 'ns3:FeedbackRatingStarCodeType'
        enum ns3__FeedbackRatingStarCodeType *FeedbackRatingStar;
        /// Optional element 'ns3:IDVerified' of XSD type 'xsd:boolean'
        bool *IDVerified;
        /// Optional element 'ns3:NewUser' of XSD type 'xsd:boolean'
        bool *NewUser;
        /// Optional element 'ns3:RegistrationAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *RegistrationAddress;
        /// Optional element 'ns3:RegistrationDate' of XSD type 'xsd:dateTime'
        time_t *RegistrationDate;
        /// Optional element 'ns3:Site' of XSD type 'ns3:SiteCodeType'
        enum ns3__SiteCodeType *Site;
        /// Optional element 'ns3:Status' of XSD type 'ns3:UserStatusCodeType'
        enum ns3__UserStatusCodeType *Status;
        /// Optional element 'ns3:UserID' of XSD type 'ns3:UserIDType'
        std::string *UserID;
        /// Optional element 'ns3:UserIDChanged' of XSD type 'xsd:boolean'
        bool *UserIDChanged;
        /// Optional element 'ns3:UserIDLastChanged' of XSD type 'xsd:dateTime'
        time_t *UserIDLastChanged;
        /// Optional element 'ns3:VATStatus' of XSD type 'ns3:VATStatusCodeType'
        enum ns3__VATStatusCodeType *VATStatus;
        /// Optional element 'ns3:BuyerInfo' of XSD type 'ns3:BuyerType'
        ns3__BuyerType *BuyerInfo;
        /// Optional element 'ns3:SellerInfo' of XSD type 'ns3:SellerType'
        ns3__SellerType *SellerInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UserType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UserType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UserType, default initialized and not managed by a soap context
        virtual ns3__UserType *soap_alloc(void) const { return SOAP_NEW(ns3__UserType); }
      public:
        /// Constructor with initializations
        ns3__UserType() : AboutMePage(), EAISToken(), Email(), FeedbackScore(), FeedbackPrivate(), FeedbackRatingStar(), IDVerified(), NewUser(), RegistrationAddress(), RegistrationDate(), Site(), Status(), UserID(), UserIDChanged(), UserIDLastChanged(), VATStatus(), BuyerInfo(), SellerInfo(), soap() { }
        virtual ~ns3__UserType() { }
        /// Friend allocator used by soap_new_ns3__UserType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UserType * SOAP_FMAC2 soap_instantiate_ns3__UserType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:823 */
#ifndef SOAP_TYPE_ns3__VATDetailsType
#define SOAP_TYPE_ns3__VATDetailsType (229)
/* complex XSD type 'ns3:VATDetailsType': */
class SOAP_CMAC ns3__VATDetailsType {
      public:
        /// Optional element 'ns3:BusinessSeller' of XSD type 'xsd:boolean'
        bool *BusinessSeller;
        /// Optional element 'ns3:RestrictedToBusiness' of XSD type 'xsd:boolean'
        bool *RestrictedToBusiness;
        /// Optional element 'ns3:VATPercent' of XSD type 'xsd:float'
        float *VATPercent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__VATDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__VATDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__VATDetailsType, default initialized and not managed by a soap context
        virtual ns3__VATDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__VATDetailsType); }
      public:
        /// Constructor with initializations
        ns3__VATDetailsType() : BusinessSeller(), RestrictedToBusiness(), VATPercent(), soap() { }
        virtual ~ns3__VATDetailsType() { }
        /// Friend allocator used by soap_new_ns3__VATDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__VATDetailsType * SOAP_FMAC2 soap_instantiate_ns3__VATDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:826 */
#ifndef SOAP_TYPE_ns3__SchedulingInfoType
#define SOAP_TYPE_ns3__SchedulingInfoType (230)
/* complex XSD type 'ns3:SchedulingInfoType': */
class SOAP_CMAC ns3__SchedulingInfoType {
      public:
        /// Optional element 'ns3:MaxScheduledMinutes' of XSD type 'xsd:int'
        int *MaxScheduledMinutes;
        /// Optional element 'ns3:MinScheduledMinutes' of XSD type 'xsd:int'
        int *MinScheduledMinutes;
        /// Optional element 'ns3:MaxScheduledItems' of XSD type 'xsd:int'
        int *MaxScheduledItems;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SchedulingInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SchedulingInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SchedulingInfoType, default initialized and not managed by a soap context
        virtual ns3__SchedulingInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__SchedulingInfoType); }
      public:
        /// Constructor with initializations
        ns3__SchedulingInfoType() : MaxScheduledMinutes(), MinScheduledMinutes(), MaxScheduledItems(), soap() { }
        virtual ~ns3__SchedulingInfoType() { }
        /// Friend allocator used by soap_new_ns3__SchedulingInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SchedulingInfoType * SOAP_FMAC2 soap_instantiate_ns3__SchedulingInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:829 */
#ifndef SOAP_TYPE_ns3__ItemArrayType
#define SOAP_TYPE_ns3__ItemArrayType (231)
/* complex XSD type 'ns3:ItemArrayType': */
class SOAP_CMAC ns3__ItemArrayType {
      public:
        /// Optional element 'ns3:Item' of XSD type 'ns3:ItemType'
        std::vector<ns3__ItemType *> Item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ItemArrayType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ItemArrayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ItemArrayType, default initialized and not managed by a soap context
        virtual ns3__ItemArrayType *soap_alloc(void) const { return SOAP_NEW(ns3__ItemArrayType); }
      public:
        /// Constructor with initializations
        ns3__ItemArrayType() : Item(), soap() { }
        virtual ~ns3__ItemArrayType() { }
        /// Friend allocator used by soap_new_ns3__ItemArrayType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ItemArrayType * SOAP_FMAC2 soap_instantiate_ns3__ItemArrayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:832 */
#ifndef SOAP_TYPE_ns3__CategoryArrayType
#define SOAP_TYPE_ns3__CategoryArrayType (232)
/* complex XSD type 'ns3:CategoryArrayType': */
class SOAP_CMAC ns3__CategoryArrayType {
      public:
        /// Optional element 'ns3:Category' of XSD type 'ns3:CategoryType'
        std::vector<ns3__CategoryType *> Category;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CategoryArrayType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CategoryArrayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CategoryArrayType, default initialized and not managed by a soap context
        virtual ns3__CategoryArrayType *soap_alloc(void) const { return SOAP_NEW(ns3__CategoryArrayType); }
      public:
        /// Constructor with initializations
        ns3__CategoryArrayType() : Category(), soap() { }
        virtual ~ns3__CategoryArrayType() { }
        /// Friend allocator used by soap_new_ns3__CategoryArrayType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CategoryArrayType * SOAP_FMAC2 soap_instantiate_ns3__CategoryArrayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:835 */
#ifndef SOAP_TYPE_ns3__PaginationType
#define SOAP_TYPE_ns3__PaginationType (233)
/* complex XSD type 'ns3:PaginationType': */
class SOAP_CMAC ns3__PaginationType {
      public:
        /// Optional element 'ns3:EntriesPerPage' of XSD type 'xsd:int'
        int *EntriesPerPage;
        /// Optional element 'ns3:PageNumber' of XSD type 'xsd:int'
        int *PageNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaginationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaginationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaginationType, default initialized and not managed by a soap context
        virtual ns3__PaginationType *soap_alloc(void) const { return SOAP_NEW(ns3__PaginationType); }
      public:
        /// Constructor with initializations
        ns3__PaginationType() : EntriesPerPage(), PageNumber(), soap() { }
        virtual ~ns3__PaginationType() { }
        /// Friend allocator used by soap_new_ns3__PaginationType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaginationType * SOAP_FMAC2 soap_instantiate_ns3__PaginationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:838 */
#ifndef SOAP_TYPE_ns3__ModifiedFieldType
#define SOAP_TYPE_ns3__ModifiedFieldType (234)
/* complex XSD type 'ns3:ModifiedFieldType': */
class SOAP_CMAC ns3__ModifiedFieldType {
      public:
        /// Optional element 'ns3:Field' of XSD type 'xsd:string'
        std::string *Field;
        /// Optional element 'ns3:ModifyType' of XSD type 'ns3:ModifyCodeType'
        enum ns3__ModifyCodeType *ModifyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ModifiedFieldType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ModifiedFieldType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ModifiedFieldType, default initialized and not managed by a soap context
        virtual ns3__ModifiedFieldType *soap_alloc(void) const { return SOAP_NEW(ns3__ModifiedFieldType); }
      public:
        /// Constructor with initializations
        ns3__ModifiedFieldType() : Field(), ModifyType(), soap() { }
        virtual ~ns3__ModifiedFieldType() { }
        /// Friend allocator used by soap_new_ns3__ModifiedFieldType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ModifiedFieldType * SOAP_FMAC2 soap_instantiate_ns3__ModifiedFieldType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:841 */
#ifndef SOAP_TYPE_ns3__PaginationResultType
#define SOAP_TYPE_ns3__PaginationResultType (235)
/* complex XSD type 'ns3:PaginationResultType': */
class SOAP_CMAC ns3__PaginationResultType {
      public:
        /// Optional element 'ns3:TotalNumberOfPages' of XSD type 'xsd:int'
        int *TotalNumberOfPages;
        /// Optional element 'ns3:TotalNumberOfEntries' of XSD type 'xsd:int'
        int *TotalNumberOfEntries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaginationResultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaginationResultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaginationResultType, default initialized and not managed by a soap context
        virtual ns3__PaginationResultType *soap_alloc(void) const { return SOAP_NEW(ns3__PaginationResultType); }
      public:
        /// Constructor with initializations
        ns3__PaginationResultType() : TotalNumberOfPages(), TotalNumberOfEntries(), soap() { }
        virtual ~ns3__PaginationResultType() { }
        /// Friend allocator used by soap_new_ns3__PaginationResultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaginationResultType * SOAP_FMAC2 soap_instantiate_ns3__PaginationResultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:844 */
#ifndef SOAP_TYPE_ns3__ErrorParameterType
#define SOAP_TYPE_ns3__ErrorParameterType (236)
/* complex XSD type 'ns3:ErrorParameterType': */
class SOAP_CMAC ns3__ErrorParameterType {
      public:
        /// Required element 'ns3:Value' of XSD type 'xsd:string'
        std::string Value;
        /// optional attribute 'ParamID' of XSD type 'xsd:string'
        std::string *ParamID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ErrorParameterType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ErrorParameterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ErrorParameterType, default initialized and not managed by a soap context
        virtual ns3__ErrorParameterType *soap_alloc(void) const { return SOAP_NEW(ns3__ErrorParameterType); }
      public:
        /// Constructor with initializations
        ns3__ErrorParameterType() : Value(), ParamID(), soap() { }
        virtual ~ns3__ErrorParameterType() { }
        /// Friend allocator used by soap_new_ns3__ErrorParameterType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ErrorParameterType * SOAP_FMAC2 soap_instantiate_ns3__ErrorParameterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:847 */
#ifndef SOAP_TYPE_ns3__ErrorType
#define SOAP_TYPE_ns3__ErrorType (237)
/* complex XSD type 'ns3:ErrorType': */
class SOAP_CMAC ns3__ErrorType {
      public:
        /// Required element 'ns3:ShortMessage' of XSD type 'xsd:string'
        std::string ShortMessage;
        /// Optional element 'ns3:LongMessage' of XSD type 'xsd:string'
        std::string *LongMessage;
        /// Required element 'ns3:ErrorCode' of XSD type 'xsd:token'
        std::string ErrorCode;
        /// Required element 'ns3:SeverityCode' of XSD type 'ns3:SeverityCodeType'
        enum ns3__SeverityCodeType SeverityCode;
        /// Optional element 'ns3:ErrorParameters' of XSD type 'ns3:ErrorParameterType'
        std::vector<ns3__ErrorParameterType *> ErrorParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ErrorType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ErrorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ErrorType, default initialized and not managed by a soap context
        virtual ns3__ErrorType *soap_alloc(void) const { return SOAP_NEW(ns3__ErrorType); }
      public:
        /// Constructor with initializations
        ns3__ErrorType() : ShortMessage(), LongMessage(), ErrorCode(), SeverityCode(), ErrorParameters(), soap() { }
        virtual ~ns3__ErrorType() { }
        /// Friend allocator used by soap_new_ns3__ErrorType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ErrorType * SOAP_FMAC2 soap_instantiate_ns3__ErrorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:850 */
#ifndef SOAP_TYPE_ns3__FaultDetailsType
#define SOAP_TYPE_ns3__FaultDetailsType (238)
/* complex XSD type 'ns3:FaultDetailsType': */
class SOAP_CMAC ns3__FaultDetailsType {
      public:
        /// Required element 'ns3:ErrorCode' of XSD type 'xsd:string'
        std::string ErrorCode;
        /// Required element 'ns3:Severity' of XSD type 'xsd:string'
        std::string Severity;
        /// Optional element 'ns3:DetailedMessage' of XSD type 'xsd:string'
        std::string *DetailedMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FaultDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FaultDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FaultDetailsType, default initialized and not managed by a soap context
        virtual ns3__FaultDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__FaultDetailsType); }
      public:
        /// Constructor with initializations
        ns3__FaultDetailsType() : ErrorCode(), Severity(), DetailedMessage(), soap() { }
        virtual ~ns3__FaultDetailsType() { }
        /// Friend allocator used by soap_new_ns3__FaultDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FaultDetailsType * SOAP_FMAC2 soap_instantiate_ns3__FaultDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:853 */
#ifndef SOAP_TYPE_ns3__AbstractRequestType
#define SOAP_TYPE_ns3__AbstractRequestType (239)
/* Type ns3__AbstractRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:AbstractRequestType': */
class SOAP_CMAC ns3__AbstractRequestType {
      public:
        /// Optional element 'ns3:DetailLevel' of XSD type 'ns3:DetailLevelCodeType'
        std::vector<enum ns3__DetailLevelCodeType> DetailLevel;
        /// Optional element 'ns3:ErrorLanguage' of XSD type 'xsd:string'
        std::string *ErrorLanguage;
        /// Required element 'ns3:Version' of XSD type 'xsd:string'
        std::string Version;
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AbstractRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AbstractRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AbstractRequestType, default initialized and not managed by a soap context
        virtual ns3__AbstractRequestType *soap_alloc(void) const { return SOAP_NEW(ns3__AbstractRequestType); }
      public:
        /// Constructor with initializations
        ns3__AbstractRequestType() : DetailLevel(), ErrorLanguage(), Version(), __any(), soap() { }
        virtual ~ns3__AbstractRequestType() { }
        /// Friend allocator used by soap_new_ns3__AbstractRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AbstractRequestType * SOAP_FMAC2 soap_instantiate_ns3__AbstractRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:856 */
#ifndef SOAP_TYPE_ns3__AbstractResponseType
#define SOAP_TYPE_ns3__AbstractResponseType (240)
/* Type ns3__AbstractResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:AbstractResponseType': */
class SOAP_CMAC ns3__AbstractResponseType {
      public:
        /// Optional element 'ns3:Timestamp' of XSD type 'xsd:dateTime'
        time_t *Timestamp;
        /// Required element 'ns3:Ack' of XSD type 'ns3:AckCodeType'
        enum ns3__AckCodeType Ack;
        /// Optional element 'ns3:CorrelationID' of XSD type 'xsd:string'
        std::string *CorrelationID;
        /// Optional element 'ns3:Errors' of XSD type 'ns3:ErrorType'
        std::vector<ns3__ErrorType *> Errors;
        /// Required element 'ns3:Version' of XSD type 'xsd:string'
        std::string Version;
        /// Required element 'ns3:Build' of XSD type 'xsd:string'
        std::string Build;
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AbstractResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AbstractResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AbstractResponseType, default initialized and not managed by a soap context
        virtual ns3__AbstractResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__AbstractResponseType); }
      public:
        /// Constructor with initializations
        ns3__AbstractResponseType() : Timestamp(), Ack(), CorrelationID(), Errors(), Version(), Build(), __any(), soap() { }
        virtual ~ns3__AbstractResponseType() { }
        /// Friend allocator used by soap_new_ns3__AbstractResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AbstractResponseType * SOAP_FMAC2 soap_instantiate_ns3__AbstractResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:859 */
#ifndef SOAP_TYPE_ns3__PhoneNumberType
#define SOAP_TYPE_ns3__PhoneNumberType (241)
/* complex XSD type 'ns3:PhoneNumberType': */
class SOAP_CMAC ns3__PhoneNumberType {
      public:
        /// Optional element 'ns3:CountryCode' of XSD type 'xsd:string'
        std::string *CountryCode;
        /// Optional element 'ns3:PhoneNumber' of XSD type 'xsd:string'
        std::string *PhoneNumber;
        /// Optional element 'ns3:Extension' of XSD type 'xsd:string'
        std::string *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PhoneNumberType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PhoneNumberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PhoneNumberType, default initialized and not managed by a soap context
        virtual ns3__PhoneNumberType *soap_alloc(void) const { return SOAP_NEW(ns3__PhoneNumberType); }
      public:
        /// Constructor with initializations
        ns3__PhoneNumberType() : CountryCode(), PhoneNumber(), Extension(), soap() { }
        virtual ~ns3__PhoneNumberType() { }
        /// Friend allocator used by soap_new_ns3__PhoneNumberType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PhoneNumberType * SOAP_FMAC2 soap_instantiate_ns3__PhoneNumberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:862 */
#ifndef SOAP_TYPE_ns3__AddressType
#define SOAP_TYPE_ns3__AddressType (242)
/* complex XSD type 'ns3:AddressType': */
class SOAP_CMAC ns3__AddressType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Street1' of XSD type 'xsd:string'
        std::string *Street1;
        /// Optional element 'ns3:Street2' of XSD type 'xsd:string'
        std::string *Street2;
        /// Optional element 'ns3:CityName' of XSD type 'xsd:string'
        std::string *CityName;
        /// Optional element 'ns3:StateOrProvince' of XSD type 'xsd:string'
        std::string *StateOrProvince;
        /// Optional element 'ns3:Country' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *Country;
        /// Optional element 'ns3:CountryName' of XSD type 'xsd:string'
        std::string *CountryName;
        /// Optional element 'ns3:Phone' of XSD type 'xsd:string'
        std::string *Phone;
        /// Optional element 'ns3:PostalCode' of XSD type 'xsd:string'
        std::string *PostalCode;
        /// Optional element 'ns3:AddressID' of XSD type 'xsd:string'
        std::string *AddressID;
        /// Optional element 'ns3:AddressOwner' of XSD type 'ns3:AddressOwnerCodeType'
        enum ns3__AddressOwnerCodeType *AddressOwner;
        /// Optional element 'ns3:ExternalAddressID' of XSD type 'xsd:string'
        std::string *ExternalAddressID;
        /// Optional element 'ns3:InternationalName' of XSD type 'xsd:string'
        std::string *InternationalName;
        /// Optional element 'ns3:InternationalStateAndCity' of XSD type 'xsd:string'
        std::string *InternationalStateAndCity;
        /// Optional element 'ns3:InternationalStreet' of XSD type 'xsd:string'
        std::string *InternationalStreet;
        /// Optional element 'ns3:AddressStatus' of XSD type 'ns3:AddressStatusCodeType'
        enum ns3__AddressStatusCodeType *AddressStatus;
        /// Optional element 'ns3:AddressNormalizationStatus' of XSD type 'ns3:AddressNormalizationStatusCodeType'
        enum ns3__AddressNormalizationStatusCodeType *AddressNormalizationStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AddressType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AddressType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AddressType, default initialized and not managed by a soap context
        virtual ns3__AddressType *soap_alloc(void) const { return SOAP_NEW(ns3__AddressType); }
      public:
        /// Constructor with initializations
        ns3__AddressType() : Name(), Street1(), Street2(), CityName(), StateOrProvince(), Country(), CountryName(), Phone(), PostalCode(), AddressID(), AddressOwner(), ExternalAddressID(), InternationalName(), InternationalStateAndCity(), InternationalStreet(), AddressStatus(), AddressNormalizationStatus(), soap() { }
        virtual ~ns3__AddressType() { }
        /// Friend allocator used by soap_new_ns3__AddressType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AddressType * SOAP_FMAC2 soap_instantiate_ns3__AddressType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:865 */
#ifndef SOAP_TYPE_ns3__PersonNameType
#define SOAP_TYPE_ns3__PersonNameType (243)
/* complex XSD type 'ns3:PersonNameType': */
class SOAP_CMAC ns3__PersonNameType {
      public:
        /// Optional element 'ns3:Salutation' of XSD type 'ns3:SalutationType'
        std::string *Salutation;
        /// Optional element 'ns3:FirstName' of XSD type 'ns3:NameType'
        std::string *FirstName;
        /// Optional element 'ns3:MiddleName' of XSD type 'ns3:NameType'
        std::string *MiddleName;
        /// Optional element 'ns3:LastName' of XSD type 'ns3:NameType'
        std::string *LastName;
        /// Optional element 'ns3:Suffix' of XSD type 'ns3:SuffixType'
        std::string *Suffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PersonNameType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PersonNameType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PersonNameType, default initialized and not managed by a soap context
        virtual ns3__PersonNameType *soap_alloc(void) const { return SOAP_NEW(ns3__PersonNameType); }
      public:
        /// Constructor with initializations
        ns3__PersonNameType() : Salutation(), FirstName(), MiddleName(), LastName(), Suffix(), soap() { }
        virtual ~ns3__PersonNameType() { }
        /// Friend allocator used by soap_new_ns3__PersonNameType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PersonNameType * SOAP_FMAC2 soap_instantiate_ns3__PersonNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:868 */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedToType
#define SOAP_TYPE_ns3__IncentiveAppliedToType (244)
/* complex XSD type 'ns3:IncentiveAppliedToType': */
class SOAP_CMAC ns3__IncentiveAppliedToType {
      public:
        /// Optional element 'ns3:BucketId' of XSD type 'xsd:string'
        std::string *BucketId;
        /// Optional element 'ns3:ItemId' of XSD type 'xsd:string'
        std::string *ItemId;
        /// Optional element 'ns3:IncentiveAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *IncentiveAmount;
        /// Optional element 'ns3:SubType' of XSD type 'xsd:string'
        std::string *SubType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveAppliedToType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveAppliedToType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveAppliedToType, default initialized and not managed by a soap context
        virtual ns3__IncentiveAppliedToType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveAppliedToType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveAppliedToType() : BucketId(), ItemId(), IncentiveAmount(), SubType(), soap() { }
        virtual ~ns3__IncentiveAppliedToType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveAppliedToType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveAppliedToType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveAppliedToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:871 */
#ifndef SOAP_TYPE_ns3__IncentiveDetailType
#define SOAP_TYPE_ns3__IncentiveDetailType (245)
/* complex XSD type 'ns3:IncentiveDetailType': */
class SOAP_CMAC ns3__IncentiveDetailType {
      public:
        /// Optional element 'ns3:RedemptionCode' of XSD type 'xsd:string'
        std::string *RedemptionCode;
        /// Optional element 'ns3:DisplayCode' of XSD type 'xsd:string'
        std::string *DisplayCode;
        /// Optional element 'ns3:ProgramId' of XSD type 'xsd:string'
        std::string *ProgramId;
        /// Optional element 'ns3:IncentiveType' of XSD type 'ns3:IncentiveTypeCodeType'
        enum ns3__IncentiveTypeCodeType *IncentiveType;
        /// Optional element 'ns3:IncentiveDescription' of XSD type 'xsd:string'
        std::string *IncentiveDescription;
        /// Optional element 'ns3:AppliedTo' of XSD type 'ns3:IncentiveAppliedToType'
        std::vector<ns3__IncentiveAppliedToType *> AppliedTo;
        /// Optional element 'ns3:Status' of XSD type 'xsd:string'
        std::string *Status;
        /// Optional element 'ns3:ErrorCode' of XSD type 'xsd:string'
        std::string *ErrorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveDetailType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveDetailType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveDetailType, default initialized and not managed by a soap context
        virtual ns3__IncentiveDetailType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveDetailType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveDetailType() : RedemptionCode(), DisplayCode(), ProgramId(), IncentiveType(), IncentiveDescription(), AppliedTo(), Status(), ErrorCode(), soap() { }
        virtual ~ns3__IncentiveDetailType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveDetailType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveDetailType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveDetailType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:874 */
#ifndef SOAP_TYPE_ns3__IncentiveItemType
#define SOAP_TYPE_ns3__IncentiveItemType (246)
/* complex XSD type 'ns3:IncentiveItemType': */
class SOAP_CMAC ns3__IncentiveItemType {
      public:
        /// Optional element 'ns3:ItemId' of XSD type 'xsd:string'
        std::string *ItemId;
        /// Optional element 'ns3:PurchaseTime' of XSD type 'xsd:dateTime'
        time_t *PurchaseTime;
        /// Optional element 'ns3:ItemCategoryList' of XSD type 'xsd:string'
        std::string *ItemCategoryList;
        /// Optional element 'ns3:ItemPrice' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemPrice;
        /// Optional element 'ns3:ItemQuantity' of XSD type 'xsd:integer'
        std::string *ItemQuantity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveItemType, default initialized and not managed by a soap context
        virtual ns3__IncentiveItemType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveItemType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveItemType() : ItemId(), PurchaseTime(), ItemCategoryList(), ItemPrice(), ItemQuantity(), soap() { }
        virtual ~ns3__IncentiveItemType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveItemType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:877 */
#ifndef SOAP_TYPE_ns3__IncentiveBucketType
#define SOAP_TYPE_ns3__IncentiveBucketType (247)
/* complex XSD type 'ns3:IncentiveBucketType': */
class SOAP_CMAC ns3__IncentiveBucketType {
      public:
        /// Optional element 'ns3:Items' of XSD type 'ns3:IncentiveItemType'
        std::vector<ns3__IncentiveItemType *> Items;
        /// Optional element 'ns3:BucketId' of XSD type 'xsd:string'
        std::string *BucketId;
        /// Optional element 'ns3:SellerId' of XSD type 'xsd:string'
        std::string *SellerId;
        /// Optional element 'ns3:ExternalSellerId' of XSD type 'xsd:string'
        std::string *ExternalSellerId;
        /// Optional element 'ns3:BucketSubtotalAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BucketSubtotalAmt;
        /// Optional element 'ns3:BucketShippingAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BucketShippingAmt;
        /// Optional element 'ns3:BucketInsuranceAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BucketInsuranceAmt;
        /// Optional element 'ns3:BucketSalesTaxAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BucketSalesTaxAmt;
        /// Optional element 'ns3:BucketTotalAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BucketTotalAmt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveBucketType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveBucketType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveBucketType, default initialized and not managed by a soap context
        virtual ns3__IncentiveBucketType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveBucketType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveBucketType() : Items(), BucketId(), SellerId(), ExternalSellerId(), BucketSubtotalAmt(), BucketShippingAmt(), BucketInsuranceAmt(), BucketSalesTaxAmt(), BucketTotalAmt(), soap() { }
        virtual ~ns3__IncentiveBucketType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveBucketType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveBucketType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveBucketType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:880 */
#ifndef SOAP_TYPE_ns3__IncentiveRequestDetailsType
#define SOAP_TYPE_ns3__IncentiveRequestDetailsType (248)
/* complex XSD type 'ns3:IncentiveRequestDetailsType': */
class SOAP_CMAC ns3__IncentiveRequestDetailsType {
      public:
        /// Optional element 'ns3:RequestId' of XSD type 'xsd:string'
        std::string *RequestId;
        /// Optional element 'ns3:RequestType' of XSD type 'ns3:IncentiveRequestCodeType'
        enum ns3__IncentiveRequestCodeType *RequestType;
        /// Optional element 'ns3:RequestDetailLevel' of XSD type 'ns3:IncentiveRequestDetailLevelCodeType'
        enum ns3__IncentiveRequestDetailLevelCodeType *RequestDetailLevel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__IncentiveRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveRequestDetailsType() : RequestId(), RequestType(), RequestDetailLevel(), soap() { }
        virtual ~ns3__IncentiveRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:883 */
#ifndef SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType
#define SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType (249)
/* complex XSD type 'ns3:GetIncentiveEvaluationRequestDetailsType': */
class SOAP_CMAC ns3__GetIncentiveEvaluationRequestDetailsType {
      public:
        /// Optional element 'ns3:ExternalBuyerId' of XSD type 'xsd:string'
        std::string *ExternalBuyerId;
        /// Sequence of 0 to 1000 elements 'ns3:IncentiveCodes' of XSD type 'xsd:string'
        std::vector<std::string> IncentiveCodes;
        /// Sequence of 0 to 1000 elements 'ns3:ApplyIndication' of XSD type 'ns3:IncentiveApplyIndicationType'
        std::vector<ns3__IncentiveApplyIndicationType *> ApplyIndication;
        /// Sequence of 0 to 100 elements 'ns3:Buckets' of XSD type 'ns3:IncentiveBucketType'
        std::vector<ns3__IncentiveBucketType *> Buckets;
        /// Optional element 'ns3:CartTotalAmt' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *CartTotalAmt;
        /// Optional element 'ns3:RequestDetails' of XSD type 'ns3:IncentiveRequestDetailsType'
        ns3__IncentiveRequestDetailsType *RequestDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetIncentiveEvaluationRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetIncentiveEvaluationRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetIncentiveEvaluationRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetIncentiveEvaluationRequestDetailsType() : ExternalBuyerId(), IncentiveCodes(), ApplyIndication(), Buckets(), CartTotalAmt(), RequestDetails(), soap() { }
        virtual ~ns3__GetIncentiveEvaluationRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetIncentiveEvaluationRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetIncentiveEvaluationRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetIncentiveEvaluationRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:886 */
#ifndef SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType
#define SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType (250)
/* complex XSD type 'ns3:GetIncentiveEvaluationResponseDetailsType': */
class SOAP_CMAC ns3__GetIncentiveEvaluationResponseDetailsType {
      public:
        /// Sequence of 0 to 1000 elements 'ns3:IncentiveDetails' of XSD type 'ns3:IncentiveDetailType'
        std::vector<ns3__IncentiveDetailType *> IncentiveDetails;
        /// Optional element 'ns3:RequestId' of XSD type 'xsd:string'
        std::string *RequestId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetIncentiveEvaluationResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetIncentiveEvaluationResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetIncentiveEvaluationResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetIncentiveEvaluationResponseDetailsType() : IncentiveDetails(), RequestId(), soap() { }
        virtual ~ns3__GetIncentiveEvaluationResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetIncentiveEvaluationResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetIncentiveEvaluationResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetIncentiveEvaluationResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:889 */
#ifndef SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType (251)
/* complex XSD type 'ns3:SetExpressCheckoutRequestDetailsType': */
class SOAP_CMAC ns3__SetExpressCheckoutRequestDetailsType {
      public:
        /// Optional element 'ns3:OrderTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *OrderTotal;
        /// Required element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string ReturnURL;
        /// Required element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string CancelURL;
        /// Optional element 'ns3:TrackingImageURL' of XSD type 'xsd:string'
        std::string *TrackingImageURL;
        /// Optional element 'ns3:giropaySuccessURL' of XSD type 'xsd:string'
        std::string *giropaySuccessURL;
        /// Optional element 'ns3:giropayCancelURL' of XSD type 'xsd:string'
        std::string *giropayCancelURL;
        /// Optional element 'ns3:BanktxnPendingURL' of XSD type 'xsd:string'
        std::string *BanktxnPendingURL;
        /// Optional element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string *Token;
        /// Optional element 'ns3:MaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *MaxAmount;
        /// Optional element 'ns3:OrderDescription' of XSD type 'xsd:string'
        std::string *OrderDescription;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns3:ReqConfirmShipping' of XSD type 'xsd:string'
        std::string *ReqConfirmShipping;
        /// Optional element 'ns3:ReqBillingAddress' of XSD type 'xsd:string'
        std::string *ReqBillingAddress;
        /// Optional element 'ns3:BillingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *BillingAddress;
        /// Optional element 'ns3:NoShipping' of XSD type 'xsd:string'
        std::string *NoShipping;
        /// Optional element 'ns3:AddressOverride' of XSD type 'xsd:string'
        std::string *AddressOverride;
        /// Optional element 'ns3:LocaleCode' of XSD type 'xsd:string'
        std::string *LocaleCode;
        /// Optional element 'ns3:PageStyle' of XSD type 'xsd:string'
        std::string *PageStyle;
        /// Optional element 'ns3:cpp-header-image' of XSD type 'xsd:string'
        std::string *cpp_header_image;
        /// Optional element 'ns3:cpp-header-border-color' of XSD type 'xsd:string'
        std::string *cpp_header_border_color;
        /// Optional element 'ns3:cpp-header-back-color' of XSD type 'xsd:string'
        std::string *cpp_header_back_color;
        /// Optional element 'ns3:cpp-payflow-color' of XSD type 'xsd:string'
        std::string *cpp_payflow_color;
        /// Optional element 'ns3:cpp-cart-border-color' of XSD type 'xsd:string'
        std::string *cpp_cart_border_color;
        /// Optional element 'ns3:cpp-logo-image' of XSD type 'xsd:string'
        std::string *cpp_logo_image;
        /// Optional element 'ns3:Address' of XSD type 'ns3:AddressType'
        ns3__AddressType *Address;
        /// Optional element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType *PaymentAction;
        /// Optional element 'ns3:SolutionType' of XSD type 'ns3:SolutionTypeType'
        enum ns3__SolutionTypeType *SolutionType;
        /// Optional element 'ns3:LandingPage' of XSD type 'ns3:LandingPageType'
        enum ns3__LandingPageType *LandingPage;
        /// Optional element 'ns3:BuyerEmail' of XSD type 'ns3:EmailAddressType'
        std::string *BuyerEmail;
        /// Optional element 'ns3:ChannelType' of XSD type 'ns3:ChannelType'
        enum ns3__ChannelType *ChannelType;
        /// Optional element 'ns3:BillingAgreementDetails' of XSD type 'ns3:BillingAgreementDetailsType'
        std::vector<ns3__BillingAgreementDetailsType *> BillingAgreementDetails;
        /// Optional element 'ns3:PromoCodes' of XSD type 'xsd:string'
        std::vector<std::string> PromoCodes;
        /// Optional element 'ns3:PayPalCheckOutBtnType' of XSD type 'xsd:string'
        std::string *PayPalCheckOutBtnType;
        /// Optional element 'ns3:ProductCategory' of XSD type 'ns3:ProductCategoryType'
        enum ns3__ProductCategoryType *ProductCategory;
        /// Optional element 'ns3:ShippingMethod' of XSD type 'ns3:ShippingServiceCodeType'
        enum ns3__ShippingServiceCodeType *ShippingMethod;
        /// Optional element 'ns3:ProfileAddressChangeDate' of XSD type 'xsd:dateTime'
        time_t *ProfileAddressChangeDate;
        /// Optional element 'ns3:AllowNote' of XSD type 'xsd:string'
        std::string *AllowNote;
        /// Optional element 'ns3:FundingSourceDetails' of XSD type 'ns3:FundingSourceDetailsType'
        ns3__FundingSourceDetailsType *FundingSourceDetails;
        /// Optional element 'ns3:BrandName' of XSD type 'xsd:string'
        std::string *BrandName;
        /// Optional element 'ns3:CallbackURL' of XSD type 'xsd:string'
        std::string *CallbackURL;
        /// Optional element 'ns3:EnhancedCheckoutData' of XSD type 'ns4:EnhancedCheckoutDataType'
        ns4__EnhancedCheckoutDataType *EnhancedCheckoutData;
        /// Optional element 'ns3:OtherPaymentMethods' of XSD type 'ns3:OtherPaymentMethodDetailsType'
        std::vector<ns3__OtherPaymentMethodDetailsType *> OtherPaymentMethods;
        /// Optional element 'ns3:BuyerDetails' of XSD type 'ns3:BuyerDetailsType'
        ns3__BuyerDetailsType *BuyerDetails;
        /// Sequence of 0 to 10 elements 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        std::vector<ns3__PaymentDetailsType *> PaymentDetails;
        /// Optional element 'ns3:FlatRateShippingOptions' of XSD type 'ns3:ShippingOptionType'
        std::vector<ns3__ShippingOptionType *> FlatRateShippingOptions;
        /// Optional element 'ns3:CallbackTimeout' of XSD type 'xsd:string'
        std::string *CallbackTimeout;
        /// Optional element 'ns3:CallbackVersion' of XSD type 'xsd:string'
        std::string *CallbackVersion;
        /// Optional element 'ns3:CustomerServiceNumber' of XSD type 'xsd:string'
        std::string *CustomerServiceNumber;
        /// Optional element 'ns3:GiftMessageEnable' of XSD type 'xsd:string'
        std::string *GiftMessageEnable;
        /// Optional element 'ns3:GiftReceiptEnable' of XSD type 'xsd:string'
        std::string *GiftReceiptEnable;
        /// Optional element 'ns3:GiftWrapEnable' of XSD type 'xsd:string'
        std::string *GiftWrapEnable;
        /// Optional element 'ns3:GiftWrapName' of XSD type 'xsd:string'
        std::string *GiftWrapName;
        /// Optional element 'ns3:GiftWrapAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GiftWrapAmount;
        /// Optional element 'ns3:BuyerEmailOptInEnable' of XSD type 'xsd:string'
        std::string *BuyerEmailOptInEnable;
        /// Optional element 'ns3:SurveyEnable' of XSD type 'xsd:string'
        std::string *SurveyEnable;
        /// Optional element 'ns3:SurveyQuestion' of XSD type 'xsd:string'
        std::string *SurveyQuestion;
        /// Optional element 'ns3:SurveyChoice' of XSD type 'xsd:string'
        std::vector<std::string> SurveyChoice;
        /// Optional element 'ns3:TotalType' of XSD type 'ns3:TotalType'
        enum ns3__TotalType *TotalType;
        /// Optional element 'ns3:NoteToBuyer' of XSD type 'xsd:string'
        std::string *NoteToBuyer;
        /// Optional element 'ns3:Incentives' of XSD type 'ns3:IncentiveInfoType'
        std::vector<ns3__IncentiveInfoType *> Incentives;
        /// Optional element 'ns3:ReqInstrumentDetails' of XSD type 'xsd:string'
        std::string *ReqInstrumentDetails;
        /// Optional element 'ns3:ExternalRememberMeOptInDetails' of XSD type 'ns3:ExternalRememberMeOptInDetailsType'
        ns3__ExternalRememberMeOptInDetailsType *ExternalRememberMeOptInDetails;
        /// Optional element 'ns3:FlowControlDetails' of XSD type 'ns3:FlowControlDetailsType'
        ns3__FlowControlDetailsType *FlowControlDetails;
        /// Optional element 'ns3:DisplayControlDetails' of XSD type 'ns3:DisplayControlDetailsType'
        ns3__DisplayControlDetailsType *DisplayControlDetails;
        /// Optional element 'ns3:ExternalPartnerTrackingDetails' of XSD type 'ns3:ExternalPartnerTrackingDetailsType'
        ns3__ExternalPartnerTrackingDetailsType *ExternalPartnerTrackingDetails;
        /// Sequence of 0 to 5 elements 'ns3:CoupledBuckets' of XSD type 'ns3:CoupledBucketsType'
        std::vector<ns3__CoupledBucketsType *> CoupledBuckets;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetExpressCheckoutRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetExpressCheckoutRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetExpressCheckoutRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetExpressCheckoutRequestDetailsType() : OrderTotal(), ReturnURL(), CancelURL(), TrackingImageURL(), giropaySuccessURL(), giropayCancelURL(), BanktxnPendingURL(), Token(), MaxAmount(), OrderDescription(), Custom(), InvoiceID(), ReqConfirmShipping(), ReqBillingAddress(), BillingAddress(), NoShipping(), AddressOverride(), LocaleCode(), PageStyle(), cpp_header_image(), cpp_header_border_color(), cpp_header_back_color(), cpp_payflow_color(), cpp_cart_border_color(), cpp_logo_image(), Address(), PaymentAction(), SolutionType(), LandingPage(), BuyerEmail(), ChannelType(), BillingAgreementDetails(), PromoCodes(), PayPalCheckOutBtnType(), ProductCategory(), ShippingMethod(), ProfileAddressChangeDate(), AllowNote(), FundingSourceDetails(), BrandName(), CallbackURL(), EnhancedCheckoutData(), OtherPaymentMethods(), BuyerDetails(), PaymentDetails(), FlatRateShippingOptions(), CallbackTimeout(), CallbackVersion(), CustomerServiceNumber(), GiftMessageEnable(), GiftReceiptEnable(), GiftWrapEnable(), GiftWrapName(), GiftWrapAmount(), BuyerEmailOptInEnable(), SurveyEnable(), SurveyQuestion(), SurveyChoice(), TotalType(), NoteToBuyer(), Incentives(), ReqInstrumentDetails(), ExternalRememberMeOptInDetails(), FlowControlDetails(), DisplayControlDetails(), ExternalPartnerTrackingDetails(), CoupledBuckets(), soap() { }
        virtual ~ns3__SetExpressCheckoutRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetExpressCheckoutRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetExpressCheckoutRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetExpressCheckoutRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:892 */
#ifndef SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType
#define SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType (252)
/* complex XSD type 'ns3:ExecuteCheckoutOperationsRequestDetailsType': */
class SOAP_CMAC ns3__ExecuteCheckoutOperationsRequestDetailsType {
      public:
        /// Optional element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string *Token;
        /// Required element 'ns3:SetDataRequest' of XSD type 'ns3:SetDataRequestType'
        ns3__SetDataRequestType *SetDataRequest;
        /// Optional element 'ns3:AuthorizationRequest' of XSD type 'ns3:AuthorizationRequestType'
        ns3__AuthorizationRequestType *AuthorizationRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExecuteCheckoutOperationsRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExecuteCheckoutOperationsRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExecuteCheckoutOperationsRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExecuteCheckoutOperationsRequestDetailsType() : Token(), SetDataRequest(), AuthorizationRequest(), soap() { }
        virtual ~ns3__ExecuteCheckoutOperationsRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExecuteCheckoutOperationsRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExecuteCheckoutOperationsRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExecuteCheckoutOperationsRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:895 */
#ifndef SOAP_TYPE_ns3__SetDataRequestType
#define SOAP_TYPE_ns3__SetDataRequestType (253)
/* complex XSD type 'ns3:SetDataRequestType': */
class SOAP_CMAC ns3__SetDataRequestType {
      public:
        /// Optional element 'ns3:BillingApprovalDetails' of XSD type 'ns3:BillingApprovalDetailsType'
        std::vector<ns3__BillingApprovalDetailsType *> BillingApprovalDetails;
        /// Optional element 'ns3:BuyerDetail' of XSD type 'ns3:BuyerDetailType'
        ns3__BuyerDetailType *BuyerDetail;
        /// Optional element 'ns3:InfoSharingDirectives' of XSD type 'ns3:InfoSharingDirectivesType'
        ns3__InfoSharingDirectivesType *InfoSharingDirectives;
        /// Optional element 'ns3:RetrieveShippingAddress' of XSD type 'xsd:boolean'
        bool *RetrieveShippingAddress;
        /// Optional element 'ns3:UserChannel' of XSD type 'ns3:UserChannelCodeType'
        enum ns3__UserChannelCodeType *UserChannel;
        /// Optional element 'ns3:ReqConfirmShipping' of XSD type 'xsd:boolean'
        bool *ReqConfirmShipping;
        /// Sequence of 0 to 10 elements 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        std::vector<ns3__PaymentDetailsType *> PaymentDetails;
        /// Optional element 'ns3:ExternalPartnerTrackingDetails' of XSD type 'ns3:ExternalPartnerTrackingDetailsType'
        ns3__ExternalPartnerTrackingDetailsType *ExternalPartnerTrackingDetails;
        /// Optional element 'ns3:URI' of XSD type 'xsd:string'
        std::string *URI;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetDataRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetDataRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetDataRequestType, default initialized and not managed by a soap context
        virtual ns3__SetDataRequestType *soap_alloc(void) const { return SOAP_NEW(ns3__SetDataRequestType); }
      public:
        /// Constructor with initializations
        ns3__SetDataRequestType() : BillingApprovalDetails(), BuyerDetail(), InfoSharingDirectives(), RetrieveShippingAddress(), UserChannel(), ReqConfirmShipping(), PaymentDetails(), ExternalPartnerTrackingDetails(), URI(), soap() { }
        virtual ~ns3__SetDataRequestType() { }
        /// Friend allocator used by soap_new_ns3__SetDataRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetDataRequestType * SOAP_FMAC2 soap_instantiate_ns3__SetDataRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:898 */
#ifndef SOAP_TYPE_ns3__AuthorizationRequestType
#define SOAP_TYPE_ns3__AuthorizationRequestType (254)
/* complex XSD type 'ns3:AuthorizationRequestType': */
class SOAP_CMAC ns3__AuthorizationRequestType {
      public:
        /// Required element 'ns3:IsRequested' of XSD type 'xsd:boolean'
        bool IsRequested;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AuthorizationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AuthorizationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AuthorizationRequestType, default initialized and not managed by a soap context
        virtual ns3__AuthorizationRequestType *soap_alloc(void) const { return SOAP_NEW(ns3__AuthorizationRequestType); }
      public:
        /// Constructor with initializations
        ns3__AuthorizationRequestType() : IsRequested(), soap() { }
        virtual ~ns3__AuthorizationRequestType() { }
        /// Friend allocator used by soap_new_ns3__AuthorizationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AuthorizationRequestType * SOAP_FMAC2 soap_instantiate_ns3__AuthorizationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:901 */
#ifndef SOAP_TYPE_ns3__BillingApprovalDetailsType
#define SOAP_TYPE_ns3__BillingApprovalDetailsType (255)
/* complex XSD type 'ns3:BillingApprovalDetailsType': */
class SOAP_CMAC ns3__BillingApprovalDetailsType {
      public:
        /// Required element 'ns3:ApprovalType' of XSD type 'ns3:ApprovalTypeType'
        enum ns3__ApprovalTypeType ApprovalType;
        /// Optional element 'ns3:ApprovalSubType' of XSD type 'ns3:ApprovalSubTypeType'
        enum ns3__ApprovalSubTypeType *ApprovalSubType;
        /// Optional element 'ns3:OrderDetails' of XSD type 'ns3:OrderDetailsType'
        ns3__OrderDetailsType *OrderDetails;
        /// Optional element 'ns3:PaymentDirectives' of XSD type 'ns3:PaymentDirectivesType'
        ns3__PaymentDirectivesType *PaymentDirectives;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillingApprovalDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillingApprovalDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillingApprovalDetailsType, default initialized and not managed by a soap context
        virtual ns3__BillingApprovalDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BillingApprovalDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BillingApprovalDetailsType() : ApprovalType(), ApprovalSubType(), OrderDetails(), PaymentDirectives(), Custom(), soap() { }
        virtual ~ns3__BillingApprovalDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BillingApprovalDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillingApprovalDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BillingApprovalDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:904 */
#ifndef SOAP_TYPE_ns3__InfoSharingDirectivesType
#define SOAP_TYPE_ns3__InfoSharingDirectivesType (256)
/* complex XSD type 'ns3:InfoSharingDirectivesType': */
class SOAP_CMAC ns3__InfoSharingDirectivesType {
      public:
        /// Optional element 'ns3:ReqBillingAddress' of XSD type 'xsd:string'
        std::string *ReqBillingAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__InfoSharingDirectivesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InfoSharingDirectivesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InfoSharingDirectivesType, default initialized and not managed by a soap context
        virtual ns3__InfoSharingDirectivesType *soap_alloc(void) const { return SOAP_NEW(ns3__InfoSharingDirectivesType); }
      public:
        /// Constructor with initializations
        ns3__InfoSharingDirectivesType() : ReqBillingAddress(), soap() { }
        virtual ~ns3__InfoSharingDirectivesType() { }
        /// Friend allocator used by soap_new_ns3__InfoSharingDirectivesType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InfoSharingDirectivesType * SOAP_FMAC2 soap_instantiate_ns3__InfoSharingDirectivesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:907 */
#ifndef SOAP_TYPE_ns3__OrderDetailsType
#define SOAP_TYPE_ns3__OrderDetailsType (257)
/* complex XSD type 'ns3:OrderDetailsType': */
class SOAP_CMAC ns3__OrderDetailsType {
      public:
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:MaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *MaxAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OrderDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OrderDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OrderDetailsType, default initialized and not managed by a soap context
        virtual ns3__OrderDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__OrderDetailsType); }
      public:
        /// Constructor with initializations
        ns3__OrderDetailsType() : Description(), MaxAmount(), soap() { }
        virtual ~ns3__OrderDetailsType() { }
        /// Friend allocator used by soap_new_ns3__OrderDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OrderDetailsType * SOAP_FMAC2 soap_instantiate_ns3__OrderDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:910 */
#ifndef SOAP_TYPE_ns3__PaymentDirectivesType
#define SOAP_TYPE_ns3__PaymentDirectivesType (258)
/* complex XSD type 'ns3:PaymentDirectivesType': */
class SOAP_CMAC ns3__PaymentDirectivesType {
      public:
        /// Optional element 'ns3:PaymentType' of XSD type 'ns3:MerchantPullPaymentCodeType'
        enum ns3__MerchantPullPaymentCodeType *PaymentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentDirectivesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentDirectivesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentDirectivesType, default initialized and not managed by a soap context
        virtual ns3__PaymentDirectivesType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentDirectivesType); }
      public:
        /// Constructor with initializations
        ns3__PaymentDirectivesType() : PaymentType(), soap() { }
        virtual ~ns3__PaymentDirectivesType() { }
        /// Friend allocator used by soap_new_ns3__PaymentDirectivesType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentDirectivesType * SOAP_FMAC2 soap_instantiate_ns3__PaymentDirectivesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:913 */
#ifndef SOAP_TYPE_ns3__BuyerDetailType
#define SOAP_TYPE_ns3__BuyerDetailType (259)
/* complex XSD type 'ns3:BuyerDetailType': */
class SOAP_CMAC ns3__BuyerDetailType {
      public:
        /// Optional element 'ns3:IdentificationInfo' of XSD type 'ns3:IdentificationInfoType'
        ns3__IdentificationInfoType *IdentificationInfo;
        /// Optional element 'ns3:RiskSessionCorrelationID' of XSD type 'xsd:string'
        std::string *RiskSessionCorrelationID;
        /// Optional element 'ns3:BuyerIPAddress' of XSD type 'xsd:string'
        std::string *BuyerIPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BuyerDetailType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BuyerDetailType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BuyerDetailType, default initialized and not managed by a soap context
        virtual ns3__BuyerDetailType *soap_alloc(void) const { return SOAP_NEW(ns3__BuyerDetailType); }
      public:
        /// Constructor with initializations
        ns3__BuyerDetailType() : IdentificationInfo(), RiskSessionCorrelationID(), BuyerIPAddress(), soap() { }
        virtual ~ns3__BuyerDetailType() { }
        /// Friend allocator used by soap_new_ns3__BuyerDetailType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BuyerDetailType * SOAP_FMAC2 soap_instantiate_ns3__BuyerDetailType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:916 */
#ifndef SOAP_TYPE_ns3__IdentificationInfoType
#define SOAP_TYPE_ns3__IdentificationInfoType (260)
/* complex XSD type 'ns3:IdentificationInfoType': */
class SOAP_CMAC ns3__IdentificationInfoType {
      public:
        /// Optional element 'ns3:MobileIDInfo' of XSD type 'ns3:MobileIDInfoType'
        ns3__MobileIDInfoType *MobileIDInfo;
        /// Optional element 'ns3:RememberMeIDInfo' of XSD type 'ns3:RememberMeIDInfoType'
        ns3__RememberMeIDInfoType *RememberMeIDInfo;
        /// Optional element 'ns3:IdentityTokenInfo' of XSD type 'ns3:IdentityTokenInfoType'
        ns3__IdentityTokenInfoType *IdentityTokenInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IdentificationInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IdentificationInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IdentificationInfoType, default initialized and not managed by a soap context
        virtual ns3__IdentificationInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__IdentificationInfoType); }
      public:
        /// Constructor with initializations
        ns3__IdentificationInfoType() : MobileIDInfo(), RememberMeIDInfo(), IdentityTokenInfo(), soap() { }
        virtual ~ns3__IdentificationInfoType() { }
        /// Friend allocator used by soap_new_ns3__IdentificationInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IdentificationInfoType * SOAP_FMAC2 soap_instantiate_ns3__IdentificationInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:919 */
#ifndef SOAP_TYPE_ns3__MobileIDInfoType
#define SOAP_TYPE_ns3__MobileIDInfoType (261)
/* complex XSD type 'ns3:MobileIDInfoType': */
class SOAP_CMAC ns3__MobileIDInfoType {
      public:
        /// Required element 'ns3:SessionToken' of XSD type 'xsd:string'
        std::string SessionToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MobileIDInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MobileIDInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MobileIDInfoType, default initialized and not managed by a soap context
        virtual ns3__MobileIDInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__MobileIDInfoType); }
      public:
        /// Constructor with initializations
        ns3__MobileIDInfoType() : SessionToken(), soap() { }
        virtual ~ns3__MobileIDInfoType() { }
        /// Friend allocator used by soap_new_ns3__MobileIDInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MobileIDInfoType * SOAP_FMAC2 soap_instantiate_ns3__MobileIDInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:922 */
#ifndef SOAP_TYPE_ns3__RememberMeIDInfoType
#define SOAP_TYPE_ns3__RememberMeIDInfoType (262)
/* complex XSD type 'ns3:RememberMeIDInfoType': */
class SOAP_CMAC ns3__RememberMeIDInfoType {
      public:
        /// Optional element 'ns3:ExternalRememberMeID' of XSD type 'xsd:string'
        std::string *ExternalRememberMeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RememberMeIDInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RememberMeIDInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RememberMeIDInfoType, default initialized and not managed by a soap context
        virtual ns3__RememberMeIDInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__RememberMeIDInfoType); }
      public:
        /// Constructor with initializations
        ns3__RememberMeIDInfoType() : ExternalRememberMeID(), soap() { }
        virtual ~ns3__RememberMeIDInfoType() { }
        /// Friend allocator used by soap_new_ns3__RememberMeIDInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RememberMeIDInfoType * SOAP_FMAC2 soap_instantiate_ns3__RememberMeIDInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:925 */
#ifndef SOAP_TYPE_ns3__IdentityTokenInfoType
#define SOAP_TYPE_ns3__IdentityTokenInfoType (263)
/* complex XSD type 'ns3:IdentityTokenInfoType': */
class SOAP_CMAC ns3__IdentityTokenInfoType {
      public:
        /// Required element 'ns3:AccessToken' of XSD type 'xsd:string'
        std::string AccessToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IdentityTokenInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IdentityTokenInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IdentityTokenInfoType, default initialized and not managed by a soap context
        virtual ns3__IdentityTokenInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__IdentityTokenInfoType); }
      public:
        /// Constructor with initializations
        ns3__IdentityTokenInfoType() : AccessToken(), soap() { }
        virtual ~ns3__IdentityTokenInfoType() { }
        /// Friend allocator used by soap_new_ns3__IdentityTokenInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IdentityTokenInfoType * SOAP_FMAC2 soap_instantiate_ns3__IdentityTokenInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:928 */
#ifndef SOAP_TYPE_ns3__FundingSourceDetailsType
#define SOAP_TYPE_ns3__FundingSourceDetailsType (264)
/* complex XSD type 'ns3:FundingSourceDetailsType': */
class SOAP_CMAC ns3__FundingSourceDetailsType {
      public:
        /// Optional element 'ns3:AllowPushFunding' of XSD type 'xsd:string'
        std::string *AllowPushFunding;
        /// Optional element 'ns3:UserSelectedFundingSource' of XSD type 'ns3:UserSelectedFundingSourceType'
        enum ns3__UserSelectedFundingSourceType *UserSelectedFundingSource;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FundingSourceDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FundingSourceDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FundingSourceDetailsType, default initialized and not managed by a soap context
        virtual ns3__FundingSourceDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__FundingSourceDetailsType); }
      public:
        /// Constructor with initializations
        ns3__FundingSourceDetailsType() : AllowPushFunding(), UserSelectedFundingSource(), soap() { }
        virtual ~ns3__FundingSourceDetailsType() { }
        /// Friend allocator used by soap_new_ns3__FundingSourceDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FundingSourceDetailsType * SOAP_FMAC2 soap_instantiate_ns3__FundingSourceDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:931 */
#ifndef SOAP_TYPE_ns3__BillingAgreementDetailsType
#define SOAP_TYPE_ns3__BillingAgreementDetailsType (265)
/* complex XSD type 'ns3:BillingAgreementDetailsType': */
class SOAP_CMAC ns3__BillingAgreementDetailsType {
      public:
        /// Required element 'ns3:BillingType' of XSD type 'ns3:BillingCodeType'
        enum ns3__BillingCodeType BillingType;
        /// Optional element 'ns3:BillingAgreementDescription' of XSD type 'xsd:string'
        std::string *BillingAgreementDescription;
        /// Optional element 'ns3:PaymentType' of XSD type 'ns3:MerchantPullPaymentCodeType'
        enum ns3__MerchantPullPaymentCodeType *PaymentType;
        /// Optional element 'ns3:BillingAgreementCustom' of XSD type 'xsd:string'
        std::string *BillingAgreementCustom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillingAgreementDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillingAgreementDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillingAgreementDetailsType, default initialized and not managed by a soap context
        virtual ns3__BillingAgreementDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BillingAgreementDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BillingAgreementDetailsType() : BillingType(), BillingAgreementDescription(), PaymentType(), BillingAgreementCustom(), soap() { }
        virtual ~ns3__BillingAgreementDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BillingAgreementDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillingAgreementDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BillingAgreementDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:934 */
#ifndef SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType (266)
/* complex XSD type 'ns3:GetExpressCheckoutDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetExpressCheckoutDetailsResponseDetailsType {
      public:
        /// Required element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns3:ContactPhone' of XSD type 'xsd:string'
        std::string *ContactPhone;
        /// Optional element 'ns3:BillingAgreementAcceptedStatus' of XSD type 'xsd:boolean'
        bool *BillingAgreementAcceptedStatus;
        /// Optional element 'ns3:RedirectRequired' of XSD type 'xsd:string'
        std::string *RedirectRequired;
        /// Optional element 'ns3:BillingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *BillingAddress;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns3:CheckoutStatus' of XSD type 'xsd:string'
        std::string *CheckoutStatus;
        /// Optional element 'ns3:PayPalAdjustment' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *PayPalAdjustment;
        /// Sequence of 0 to 10 elements 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        std::vector<ns3__PaymentDetailsType *> PaymentDetails;
        /// Optional element 'ns3:UserSelectedOptions' of XSD type 'ns3:UserSelectedOptionType'
        ns3__UserSelectedOptionType *UserSelectedOptions;
        /// Optional element 'ns3:IncentiveDetails' of XSD type 'ns3:IncentiveDetailsType'
        std::vector<ns3__IncentiveDetailsType *> IncentiveDetails;
        /// Optional element 'ns3:GiftMessage' of XSD type 'xsd:string'
        std::string *GiftMessage;
        /// Optional element 'ns3:GiftReceiptEnable' of XSD type 'xsd:string'
        std::string *GiftReceiptEnable;
        /// Optional element 'ns3:GiftWrapName' of XSD type 'xsd:string'
        std::string *GiftWrapName;
        /// Optional element 'ns3:GiftWrapAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GiftWrapAmount;
        /// Optional element 'ns3:BuyerMarketingEmail' of XSD type 'xsd:string'
        std::string *BuyerMarketingEmail;
        /// Optional element 'ns3:SurveyQuestion' of XSD type 'xsd:string'
        std::string *SurveyQuestion;
        /// Optional element 'ns3:SurveyChoiceSelected' of XSD type 'xsd:string'
        std::vector<std::string> SurveyChoiceSelected;
        /// Sequence of 0 to 10 elements 'ns3:PaymentRequestInfo' of XSD type 'ns3:PaymentRequestInfoType'
        std::vector<ns3__PaymentRequestInfoType *> PaymentRequestInfo;
        /// Optional element 'ns3:ExternalRememberMeStatusDetails' of XSD type 'ns3:ExternalRememberMeStatusDetailsType'
        ns3__ExternalRememberMeStatusDetailsType *ExternalRememberMeStatusDetails;
        /// Optional element 'ns3:RefreshTokenStatusDetails' of XSD type 'ns3:RefreshTokenStatusDetailsType'
        ns3__RefreshTokenStatusDetailsType *RefreshTokenStatusDetails;
        /// Sequence of 0 to 10 elements 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        std::vector<ns3__PaymentInfoType *> PaymentInfo;
        /// Optional element 'ns3:CartChangeTolerance' of XSD type 'xsd:string'
        std::string *CartChangeTolerance;
        /// Optional element 'ns3:InstrumentDetails' of XSD type 'ns3:InstrumentDetailsType'
        ns3__InstrumentDetailsType *InstrumentDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetExpressCheckoutDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetExpressCheckoutDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetExpressCheckoutDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetExpressCheckoutDetailsResponseDetailsType() : Token(), PayerInfo(), Custom(), InvoiceID(), ContactPhone(), BillingAgreementAcceptedStatus(), RedirectRequired(), BillingAddress(), Note(), CheckoutStatus(), PayPalAdjustment(), PaymentDetails(), UserSelectedOptions(), IncentiveDetails(), GiftMessage(), GiftReceiptEnable(), GiftWrapName(), GiftWrapAmount(), BuyerMarketingEmail(), SurveyQuestion(), SurveyChoiceSelected(), PaymentRequestInfo(), ExternalRememberMeStatusDetails(), RefreshTokenStatusDetails(), PaymentInfo(), CartChangeTolerance(), InstrumentDetails(), soap() { }
        virtual ~ns3__GetExpressCheckoutDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetExpressCheckoutDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetExpressCheckoutDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetExpressCheckoutDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:937 */
#ifndef SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType
#define SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType (267)
/* complex XSD type 'ns3:ExecuteCheckoutOperationsResponseDetailsType': */
class SOAP_CMAC ns3__ExecuteCheckoutOperationsResponseDetailsType {
      public:
        /// Required element 'ns3:SetDataResponse' of XSD type 'ns3:SetDataResponseType'
        ns3__SetDataResponseType *SetDataResponse;
        /// Optional element 'ns3:AuthorizationResponse' of XSD type 'ns3:AuthorizationResponseType'
        ns3__AuthorizationResponseType *AuthorizationResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExecuteCheckoutOperationsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExecuteCheckoutOperationsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExecuteCheckoutOperationsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExecuteCheckoutOperationsResponseDetailsType() : SetDataResponse(), AuthorizationResponse(), soap() { }
        virtual ~ns3__ExecuteCheckoutOperationsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExecuteCheckoutOperationsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExecuteCheckoutOperationsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExecuteCheckoutOperationsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:940 */
#ifndef SOAP_TYPE_ns3__SetDataResponseType
#define SOAP_TYPE_ns3__SetDataResponseType (268)
/* complex XSD type 'ns3:SetDataResponseType': */
class SOAP_CMAC ns3__SetDataResponseType {
      public:
        /// Optional element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string *Token;
        /// Optional element 'ns3:ShippingAddresses' of XSD type 'ns3:AddressType'
        std::vector<ns3__AddressType *> ShippingAddresses;
        /// Optional element 'ns3:SetDataError' of XSD type 'ns3:ErrorType'
        std::vector<ns3__ErrorType *> SetDataError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetDataResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetDataResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetDataResponseType, default initialized and not managed by a soap context
        virtual ns3__SetDataResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__SetDataResponseType); }
      public:
        /// Constructor with initializations
        ns3__SetDataResponseType() : Token(), ShippingAddresses(), SetDataError(), soap() { }
        virtual ~ns3__SetDataResponseType() { }
        /// Friend allocator used by soap_new_ns3__SetDataResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetDataResponseType * SOAP_FMAC2 soap_instantiate_ns3__SetDataResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:943 */
#ifndef SOAP_TYPE_ns3__AuthorizationResponseType
#define SOAP_TYPE_ns3__AuthorizationResponseType (269)
/* complex XSD type 'ns3:AuthorizationResponseType': */
class SOAP_CMAC ns3__AuthorizationResponseType {
      public:
        /// Required element 'ns3:Status' of XSD type 'ns3:AckCodeType'
        enum ns3__AckCodeType Status;
        /// Optional element 'ns3:AuthorizationError' of XSD type 'ns3:ErrorType'
        std::vector<ns3__ErrorType *> AuthorizationError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AuthorizationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AuthorizationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AuthorizationResponseType, default initialized and not managed by a soap context
        virtual ns3__AuthorizationResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__AuthorizationResponseType); }
      public:
        /// Constructor with initializations
        ns3__AuthorizationResponseType() : Status(), AuthorizationError(), soap() { }
        virtual ~ns3__AuthorizationResponseType() { }
        /// Friend allocator used by soap_new_ns3__AuthorizationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AuthorizationResponseType * SOAP_FMAC2 soap_instantiate_ns3__AuthorizationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:946 */
#ifndef SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType
#define SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType (270)
/* complex XSD type 'ns3:DoExpressCheckoutPaymentRequestDetailsType': */
class SOAP_CMAC ns3__DoExpressCheckoutPaymentRequestDetailsType {
      public:
        /// Optional element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType *PaymentAction;
        /// Required element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
        /// Required element 'ns3:PayerID' of XSD type 'ns3:UserIDType'
        std::string PayerID;
        /// Optional element 'ns3:OrderURL' of XSD type 'xsd:string'
        std::string *OrderURL;
        /// Optional element 'ns3:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Sequence of 0 to 10 elements 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        std::vector<ns3__PaymentDetailsType *> PaymentDetails;
        /// Optional element 'ns3:PromoOverrideFlag' of XSD type 'xsd:string'
        std::string *PromoOverrideFlag;
        /// Optional element 'ns3:PromoCode' of XSD type 'xsd:string'
        std::string *PromoCode;
        /// Optional element 'ns3:EnhancedData' of XSD type 'ns3:EnhancedDataType'
        ns3__EnhancedDataType *EnhancedData;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:UserSelectedOptions' of XSD type 'ns3:UserSelectedOptionType'
        ns3__UserSelectedOptionType *UserSelectedOptions;
        /// Optional element 'ns3:GiftMessage' of XSD type 'xsd:string'
        std::string *GiftMessage;
        /// Optional element 'ns3:GiftReceiptEnable' of XSD type 'xsd:string'
        std::string *GiftReceiptEnable;
        /// Optional element 'ns3:GiftWrapName' of XSD type 'xsd:string'
        std::string *GiftWrapName;
        /// Optional element 'ns3:GiftWrapAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GiftWrapAmount;
        /// Optional element 'ns3:BuyerMarketingEmail' of XSD type 'xsd:string'
        std::string *BuyerMarketingEmail;
        /// Optional element 'ns3:SurveyQuestion' of XSD type 'xsd:string'
        std::string *SurveyQuestion;
        /// Optional element 'ns3:SurveyChoiceSelected' of XSD type 'xsd:string'
        std::vector<std::string> SurveyChoiceSelected;
        /// Optional element 'ns3:ButtonSource' of XSD type 'xsd:string'
        std::string *ButtonSource;
        /// Optional element 'ns3:SkipBACreation' of XSD type 'xsd:boolean'
        bool *SkipBACreation;
        /// Optional element 'ns3:UseSessionPaymentDetails' of XSD type 'xsd:string'
        std::string *UseSessionPaymentDetails;
        /// Sequence of 0 to 5 elements 'ns3:CoupledBuckets' of XSD type 'ns3:CoupledBucketsType'
        std::vector<ns3__CoupledBucketsType *> CoupledBuckets;
        /// Optional element 'ns3:ClientID' of XSD type 'xsd:string'
        std::string *ClientID;
        /// Optional element 'ns3:ProductLine' of XSD type 'xsd:string'
        std::string *ProductLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoExpressCheckoutPaymentRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoExpressCheckoutPaymentRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoExpressCheckoutPaymentRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoExpressCheckoutPaymentRequestDetailsType() : PaymentAction(), Token(), PayerID(), OrderURL(), MsgSubID(), PaymentDetails(), PromoOverrideFlag(), PromoCode(), EnhancedData(), SoftDescriptor(), UserSelectedOptions(), GiftMessage(), GiftReceiptEnable(), GiftWrapName(), GiftWrapAmount(), BuyerMarketingEmail(), SurveyQuestion(), SurveyChoiceSelected(), ButtonSource(), SkipBACreation(), UseSessionPaymentDetails(), CoupledBuckets(), ClientID(), ProductLine(), soap() { }
        virtual ~ns3__DoExpressCheckoutPaymentRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoExpressCheckoutPaymentRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoExpressCheckoutPaymentRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoExpressCheckoutPaymentRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:949 */
#ifndef SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType (271)
/* complex XSD type 'ns3:DoExpressCheckoutPaymentResponseDetailsType': */
class SOAP_CMAC ns3__DoExpressCheckoutPaymentResponseDetailsType {
      public:
        /// Required element 'ns3:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
        /// Sequence of 0 to 10 elements 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        std::vector<ns3__PaymentInfoType *> PaymentInfo;
        /// Optional element 'ns3:BillingAgreementID' of XSD type 'xsd:string'
        std::string *BillingAgreementID;
        /// Optional element 'ns3:RedirectRequired' of XSD type 'xsd:string'
        std::string *RedirectRequired;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns3:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns3:SuccessPageRedirectRequested' of XSD type 'xsd:string'
        std::string *SuccessPageRedirectRequested;
        /// Optional element 'ns3:UserSelectedOptions' of XSD type 'ns3:UserSelectedOptionType'
        ns3__UserSelectedOptionType *UserSelectedOptions;
        /// Sequence of 0 to 5 elements 'ns3:CoupledPaymentInfo' of XSD type 'ns3:CoupledPaymentInfoType'
        std::vector<ns3__CoupledPaymentInfoType *> CoupledPaymentInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoExpressCheckoutPaymentResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoExpressCheckoutPaymentResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoExpressCheckoutPaymentResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoExpressCheckoutPaymentResponseDetailsType() : Token(), PaymentInfo(), BillingAgreementID(), RedirectRequired(), Note(), MsgSubID(), SuccessPageRedirectRequested(), UserSelectedOptions(), CoupledPaymentInfo(), soap() { }
        virtual ~ns3__DoExpressCheckoutPaymentResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoExpressCheckoutPaymentResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoExpressCheckoutPaymentResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoExpressCheckoutPaymentResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:952 */
#ifndef SOAP_TYPE_ns3__DoCaptureResponseDetailsType
#define SOAP_TYPE_ns3__DoCaptureResponseDetailsType (272)
/* complex XSD type 'ns3:DoCaptureResponseDetailsType': */
class SOAP_CMAC ns3__DoCaptureResponseDetailsType {
      public:
        /// Optional element 'ns3:AuthorizationID' of XSD type 'xsd:string'
        std::string *AuthorizationID;
        /// Required element 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        ns3__PaymentInfoType *PaymentInfo;
        /// Optional element 'ns3:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns3:PartnerFundingSourceID' of XSD type 'xsd:string'
        std::string *PartnerFundingSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoCaptureResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoCaptureResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoCaptureResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoCaptureResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoCaptureResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoCaptureResponseDetailsType() : AuthorizationID(), PaymentInfo(), MsgSubID(), PartnerFundingSourceID(), soap() { }
        virtual ~ns3__DoCaptureResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoCaptureResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoCaptureResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoCaptureResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:955 */
#ifndef SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType
#define SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType (273)
/* complex XSD type 'ns3:DoDirectPaymentRequestDetailsType': */
class SOAP_CMAC ns3__DoDirectPaymentRequestDetailsType {
      public:
        /// Required element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType PaymentAction;
        /// Required element 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        ns3__PaymentDetailsType *PaymentDetails;
        /// Required element 'ns3:CreditCard' of XSD type 'ns3:CreditCardDetailsType'
        ns3__CreditCardDetailsType *CreditCard;
        /// Required element 'ns3:IPAddress' of XSD type 'xsd:string'
        std::string IPAddress;
        /// Optional element 'ns3:MerchantSessionId' of XSD type 'xsd:string'
        std::string *MerchantSessionId;
        /// Optional element 'ns3:ReturnFMFDetails' of XSD type 'xsd:boolean'
        bool *ReturnFMFDetails;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:SoftDescriptorCity' of XSD type 'xsd:string'
        std::string *SoftDescriptorCity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoDirectPaymentRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoDirectPaymentRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoDirectPaymentRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoDirectPaymentRequestDetailsType() : PaymentAction(), PaymentDetails(), CreditCard(), IPAddress(), MerchantSessionId(), ReturnFMFDetails(), SoftDescriptor(), SoftDescriptorCity(), soap() { }
        virtual ~ns3__DoDirectPaymentRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoDirectPaymentRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoDirectPaymentRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoDirectPaymentRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:958 */
#ifndef SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType
#define SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType (274)
/* complex XSD type 'ns3:CreateMobilePaymentRequestDetailsType': */
class SOAP_CMAC ns3__CreateMobilePaymentRequestDetailsType {
      public:
        /// Required element 'ns3:PaymentType' of XSD type 'ns3:MobilePaymentCodeType'
        enum ns3__MobilePaymentCodeType PaymentType;
        /// Required element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType PaymentAction;
        /// Required element 'ns3:SenderPhone' of XSD type 'ns3:PhoneNumberType'
        ns3__PhoneNumberType *SenderPhone;
        /// Required element 'ns3:RecipientType' of XSD type 'ns3:MobileRecipientCodeType'
        enum ns3__MobileRecipientCodeType RecipientType;
        /// Optional element 'ns3:RecipientEmail' of XSD type 'xsd:string'
        std::string *RecipientEmail;
        /// Optional element 'ns3:RecipientPhone' of XSD type 'ns3:PhoneNumberType'
        ns3__PhoneNumberType *RecipientPhone;
        /// Required element 'ns3:ItemAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemAmount;
        /// Optional element 'ns3:Tax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Tax;
        /// Optional element 'ns3:Shipping' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Shipping;
        /// Optional element 'ns3:ItemName' of XSD type 'xsd:string'
        std::string *ItemName;
        /// Optional element 'ns3:ItemNumber' of XSD type 'xsd:string'
        std::string *ItemNumber;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns3:CustomID' of XSD type 'xsd:string'
        std::string *CustomID;
        /// Optional element 'ns3:SharePhoneNumber' of XSD type 'xsd:integer'
        std::string *SharePhoneNumber;
        /// Optional element 'ns3:ShareHomeAddress' of XSD type 'xsd:integer'
        std::string *ShareHomeAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CreateMobilePaymentRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__CreateMobilePaymentRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__CreateMobilePaymentRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__CreateMobilePaymentRequestDetailsType() : PaymentType(), PaymentAction(), SenderPhone(), RecipientType(), RecipientEmail(), RecipientPhone(), ItemAmount(), Tax(), Shipping(), ItemName(), ItemNumber(), Note(), CustomID(), SharePhoneNumber(), ShareHomeAddress(), soap() { }
        virtual ~ns3__CreateMobilePaymentRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__CreateMobilePaymentRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CreateMobilePaymentRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__CreateMobilePaymentRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:961 */
#ifndef SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType
#define SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType (275)
/* complex XSD type 'ns3:GetMobileStatusRequestDetailsType': */
class SOAP_CMAC ns3__GetMobileStatusRequestDetailsType {
      public:
        /// Required element 'ns3:Phone' of XSD type 'ns3:PhoneNumberType'
        ns3__PhoneNumberType *Phone;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetMobileStatusRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetMobileStatusRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetMobileStatusRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetMobileStatusRequestDetailsType() : Phone(), soap() { }
        virtual ~ns3__GetMobileStatusRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetMobileStatusRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetMobileStatusRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetMobileStatusRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:964 */
#ifndef SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType
#define SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType (276)
/* complex XSD type 'ns3:SetAuthFlowParamRequestDetailsType': */
class SOAP_CMAC ns3__SetAuthFlowParamRequestDetailsType {
      public:
        /// Required element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string ReturnURL;
        /// Required element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string CancelURL;
        /// Required element 'ns3:LogoutURL' of XSD type 'xsd:string'
        std::string LogoutURL;
        /// Optional element 'ns3:InitFlowType' of XSD type 'xsd:string'
        std::string *InitFlowType;
        /// Optional element 'ns3:SkipLoginPage' of XSD type 'xsd:string'
        std::string *SkipLoginPage;
        /// Optional element 'ns3:ServiceName1' of XSD type 'xsd:string'
        std::string *ServiceName1;
        /// Optional element 'ns3:ServiceDefReq1' of XSD type 'xsd:string'
        std::string *ServiceDefReq1;
        /// Optional element 'ns3:ServiceName2' of XSD type 'xsd:string'
        std::string *ServiceName2;
        /// Optional element 'ns3:ServiceDefReq2' of XSD type 'xsd:string'
        std::string *ServiceDefReq2;
        /// Optional element 'ns3:LocaleCode' of XSD type 'xsd:string'
        std::string *LocaleCode;
        /// Optional element 'ns3:PageStyle' of XSD type 'xsd:string'
        std::string *PageStyle;
        /// Optional element 'ns3:cpp-header-image' of XSD type 'xsd:string'
        std::string *cpp_header_image;
        /// Optional element 'ns3:cpp-header-border-color' of XSD type 'xsd:string'
        std::string *cpp_header_border_color;
        /// Optional element 'ns3:cpp-header-back-color' of XSD type 'xsd:string'
        std::string *cpp_header_back_color;
        /// Optional element 'ns3:cpp-payflow-color' of XSD type 'xsd:string'
        std::string *cpp_payflow_color;
        /// Optional element 'ns3:FirstName' of XSD type 'xsd:string'
        std::string *FirstName;
        /// Optional element 'ns3:LastName' of XSD type 'xsd:string'
        std::string *LastName;
        /// Optional element 'ns3:Address' of XSD type 'ns3:AddressType'
        ns3__AddressType *Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetAuthFlowParamRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetAuthFlowParamRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetAuthFlowParamRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetAuthFlowParamRequestDetailsType() : ReturnURL(), CancelURL(), LogoutURL(), InitFlowType(), SkipLoginPage(), ServiceName1(), ServiceDefReq1(), ServiceName2(), ServiceDefReq2(), LocaleCode(), PageStyle(), cpp_header_image(), cpp_header_border_color(), cpp_header_back_color(), cpp_payflow_color(), FirstName(), LastName(), Address(), soap() { }
        virtual ~ns3__SetAuthFlowParamRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetAuthFlowParamRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetAuthFlowParamRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetAuthFlowParamRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:967 */
#ifndef SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType (277)
/* complex XSD type 'ns3:GetAuthDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetAuthDetailsResponseDetailsType {
      public:
        /// Optional element 'ns3:FirstName' of XSD type 'xsd:string'
        std::string *FirstName;
        /// Optional element 'ns3:LastName' of XSD type 'xsd:string'
        std::string *LastName;
        /// Optional element 'ns3:Email' of XSD type 'xsd:string'
        std::string *Email;
        /// Required element 'ns3:PayerID' of XSD type 'ns3:UserIDType'
        std::string PayerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetAuthDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetAuthDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetAuthDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetAuthDetailsResponseDetailsType() : FirstName(), LastName(), Email(), PayerID(), soap() { }
        virtual ~ns3__GetAuthDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetAuthDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetAuthDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetAuthDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:970 */
#ifndef SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType
#define SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType (278)
/* complex XSD type 'ns3:SetAccessPermissionsRequestDetailsType': */
class SOAP_CMAC ns3__SetAccessPermissionsRequestDetailsType {
      public:
        /// Required element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string ReturnURL;
        /// Required element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string CancelURL;
        /// Required element 'ns3:LogoutURL' of XSD type 'xsd:string'
        std::string LogoutURL;
        /// Optional element 'ns3:InitFlowType' of XSD type 'xsd:string'
        std::string *InitFlowType;
        /// Optional element 'ns3:SkipLoginPage' of XSD type 'xsd:string'
        std::string *SkipLoginPage;
        /// Optional element 'ns3:RequiredAccessPermissions' of XSD type 'xsd:string'
        std::vector<std::string> RequiredAccessPermissions;
        /// Optional element 'ns3:OptionalAccessPermissions' of XSD type 'xsd:string'
        std::vector<std::string> OptionalAccessPermissions;
        /// Optional element 'ns3:LocaleCode' of XSD type 'xsd:string'
        std::string *LocaleCode;
        /// Optional element 'ns3:PageStyle' of XSD type 'xsd:string'
        std::string *PageStyle;
        /// Optional element 'ns3:cpp-header-image' of XSD type 'xsd:string'
        std::string *cpp_header_image;
        /// Optional element 'ns3:cpp-header-border-color' of XSD type 'xsd:string'
        std::string *cpp_header_border_color;
        /// Optional element 'ns3:cpp-header-back-color' of XSD type 'xsd:string'
        std::string *cpp_header_back_color;
        /// Optional element 'ns3:cpp-payflow-color' of XSD type 'xsd:string'
        std::string *cpp_payflow_color;
        /// Optional element 'ns3:FirstName' of XSD type 'xsd:string'
        std::string *FirstName;
        /// Optional element 'ns3:LastName' of XSD type 'xsd:string'
        std::string *LastName;
        /// Optional element 'ns3:Address' of XSD type 'ns3:AddressType'
        ns3__AddressType *Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetAccessPermissionsRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetAccessPermissionsRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetAccessPermissionsRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetAccessPermissionsRequestDetailsType() : ReturnURL(), CancelURL(), LogoutURL(), InitFlowType(), SkipLoginPage(), RequiredAccessPermissions(), OptionalAccessPermissions(), LocaleCode(), PageStyle(), cpp_header_image(), cpp_header_border_color(), cpp_header_back_color(), cpp_payflow_color(), FirstName(), LastName(), Address(), soap() { }
        virtual ~ns3__SetAccessPermissionsRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetAccessPermissionsRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetAccessPermissionsRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetAccessPermissionsRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:973 */
#ifndef SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType (279)
/* complex XSD type 'ns3:GetAccessPermissionDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetAccessPermissionDetailsResponseDetailsType {
      public:
        /// Optional element 'ns3:FirstName' of XSD type 'xsd:string'
        std::string *FirstName;
        /// Optional element 'ns3:LastName' of XSD type 'xsd:string'
        std::string *LastName;
        /// Optional element 'ns3:Email' of XSD type 'xsd:string'
        std::string *Email;
        /// Optional element 'ns3:AccessPermissionName' of XSD type 'xsd:string'
        std::vector<std::string> AccessPermissionName;
        /// Optional element 'ns3:AccessPermissionStatus' of XSD type 'xsd:string'
        std::vector<std::string> AccessPermissionStatus;
        /// Required element 'ns3:PayerID' of XSD type 'ns3:UserIDType'
        std::string PayerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetAccessPermissionDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetAccessPermissionDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetAccessPermissionDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetAccessPermissionDetailsResponseDetailsType() : FirstName(), LastName(), Email(), AccessPermissionName(), AccessPermissionStatus(), PayerID(), soap() { }
        virtual ~ns3__GetAccessPermissionDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetAccessPermissionDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetAccessPermissionDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetAccessPermissionDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:976 */
#ifndef SOAP_TYPE_ns3__BAUpdateResponseDetailsType
#define SOAP_TYPE_ns3__BAUpdateResponseDetailsType (280)
/* complex XSD type 'ns3:BAUpdateResponseDetailsType': */
class SOAP_CMAC ns3__BAUpdateResponseDetailsType {
      public:
        /// Required element 'ns3:BillingAgreementID' of XSD type 'xsd:string'
        std::string BillingAgreementID;
        /// Optional element 'ns3:BillingAgreementDescription' of XSD type 'xsd:string'
        std::string *BillingAgreementDescription;
        /// Required element 'ns3:BillingAgreementStatus' of XSD type 'ns3:MerchantPullStatusCodeType'
        enum ns3__MerchantPullStatusCodeType BillingAgreementStatus;
        /// Optional element 'ns3:BillingAgreementCustom' of XSD type 'xsd:string'
        std::string *BillingAgreementCustom;
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Optional element 'ns3:BillingAgreementMax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *BillingAgreementMax;
        /// Optional element 'ns3:BillingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *BillingAddress;
        /// Optional element 'ns3:PayeeInfo' of XSD type 'ns3:PayeeInfoType'
        ns3__PayeeInfoType *PayeeInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BAUpdateResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BAUpdateResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BAUpdateResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__BAUpdateResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BAUpdateResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BAUpdateResponseDetailsType() : BillingAgreementID(), BillingAgreementDescription(), BillingAgreementStatus(), BillingAgreementCustom(), PayerInfo(), BillingAgreementMax(), BillingAddress(), PayeeInfo(), soap() { }
        virtual ~ns3__BAUpdateResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BAUpdateResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BAUpdateResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BAUpdateResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:979 */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentResponseType
#define SOAP_TYPE_ns3__MerchantPullPaymentResponseType (281)
/* complex XSD type 'ns3:MerchantPullPaymentResponseType': */
class SOAP_CMAC ns3__MerchantPullPaymentResponseType {
      public:
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Required element 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        ns3__PaymentInfoType *PaymentInfo;
        /// Required element 'ns3:MerchantPullInfo' of XSD type 'ns3:MerchantPullInfoType'
        ns3__MerchantPullInfoType *MerchantPullInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MerchantPullPaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MerchantPullPaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MerchantPullPaymentResponseType, default initialized and not managed by a soap context
        virtual ns3__MerchantPullPaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__MerchantPullPaymentResponseType); }
      public:
        /// Constructor with initializations
        ns3__MerchantPullPaymentResponseType() : PayerInfo(), PaymentInfo(), MerchantPullInfo(), soap() { }
        virtual ~ns3__MerchantPullPaymentResponseType() { }
        /// Friend allocator used by soap_new_ns3__MerchantPullPaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MerchantPullPaymentResponseType * SOAP_FMAC2 soap_instantiate_ns3__MerchantPullPaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:982 */
#ifndef SOAP_TYPE_ns3__MerchantPullInfoType
#define SOAP_TYPE_ns3__MerchantPullInfoType (282)
/* complex XSD type 'ns3:MerchantPullInfoType': */
class SOAP_CMAC ns3__MerchantPullInfoType {
      public:
        /// Required element 'ns3:MpStatus' of XSD type 'ns3:MerchantPullStatusCodeType'
        enum ns3__MerchantPullStatusCodeType MpStatus;
        /// Required element 'ns3:MpMax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *MpMax;
        /// Optional element 'ns3:MpCustom' of XSD type 'xsd:string'
        std::string *MpCustom;
        /// Optional element 'ns3:Desc' of XSD type 'xsd:string'
        std::string *Desc;
        /// Optional element 'ns3:Invoice' of XSD type 'xsd:string'
        std::string *Invoice;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:PaymentSourceID' of XSD type 'xsd:string'
        std::string *PaymentSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MerchantPullInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MerchantPullInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MerchantPullInfoType, default initialized and not managed by a soap context
        virtual ns3__MerchantPullInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__MerchantPullInfoType); }
      public:
        /// Constructor with initializations
        ns3__MerchantPullInfoType() : MpStatus(), MpMax(), MpCustom(), Desc(), Invoice(), Custom(), PaymentSourceID(), soap() { }
        virtual ~ns3__MerchantPullInfoType() { }
        /// Friend allocator used by soap_new_ns3__MerchantPullInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MerchantPullInfoType * SOAP_FMAC2 soap_instantiate_ns3__MerchantPullInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:985 */
#ifndef SOAP_TYPE_ns3__PaymentTransactionSearchResultType
#define SOAP_TYPE_ns3__PaymentTransactionSearchResultType (283)
/* complex XSD type 'ns3:PaymentTransactionSearchResultType': */
class SOAP_CMAC ns3__PaymentTransactionSearchResultType {
      public:
        /// Required element 'ns3:Timestamp' of XSD type 'xsd:dateTime'
        time_t Timestamp;
        /// Required element 'ns3:Timezone' of XSD type 'xsd:string'
        std::string Timezone;
        /// Required element 'ns3:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Required element 'ns3:Payer' of XSD type 'ns3:EmailAddressType'
        std::string Payer;
        /// Required element 'ns3:PayerDisplayName' of XSD type 'xsd:string'
        std::string PayerDisplayName;
        /// Required element 'ns3:TransactionID' of XSD type 'xsd:string'
        std::string TransactionID;
        /// Required element 'ns3:Status' of XSD type 'xsd:string'
        std::string Status;
        /// Required element 'ns3:GrossAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GrossAmount;
        /// Required element 'ns3:FeeAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FeeAmount;
        /// Required element 'ns3:NetAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *NetAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentTransactionSearchResultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentTransactionSearchResultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentTransactionSearchResultType, default initialized and not managed by a soap context
        virtual ns3__PaymentTransactionSearchResultType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentTransactionSearchResultType); }
      public:
        /// Constructor with initializations
        ns3__PaymentTransactionSearchResultType() : Timestamp(), Timezone(), Type(), Payer(), PayerDisplayName(), TransactionID(), Status(), GrossAmount(), FeeAmount(), NetAmount(), soap() { }
        virtual ~ns3__PaymentTransactionSearchResultType() { }
        /// Friend allocator used by soap_new_ns3__PaymentTransactionSearchResultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentTransactionSearchResultType * SOAP_FMAC2 soap_instantiate_ns3__PaymentTransactionSearchResultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:988 */
#ifndef SOAP_TYPE_ns3__ShippingInfoType
#define SOAP_TYPE_ns3__ShippingInfoType (284)
/* complex XSD type 'ns3:ShippingInfoType': */
class SOAP_CMAC ns3__ShippingInfoType {
      public:
        /// Required element 'ns3:ShippingMethod' of XSD type 'xsd:string'
        std::string ShippingMethod;
        /// Required element 'ns3:ShippingCarrier' of XSD type 'xsd:string'
        std::string ShippingCarrier;
        /// Required element 'ns3:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Required element 'ns3:HandlingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *HandlingAmount;
        /// Required element 'ns3:InsuranceAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *InsuranceAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ShippingInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ShippingInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ShippingInfoType, default initialized and not managed by a soap context
        virtual ns3__ShippingInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__ShippingInfoType); }
      public:
        /// Constructor with initializations
        ns3__ShippingInfoType() : ShippingMethod(), ShippingCarrier(), ShippingAmount(), HandlingAmount(), InsuranceAmount(), soap() { }
        virtual ~ns3__ShippingInfoType() { }
        /// Friend allocator used by soap_new_ns3__ShippingInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ShippingInfoType * SOAP_FMAC2 soap_instantiate_ns3__ShippingInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:991 */
#ifndef SOAP_TYPE_ns3__TaxInfoType
#define SOAP_TYPE_ns3__TaxInfoType (285)
/* complex XSD type 'ns3:TaxInfoType': */
class SOAP_CMAC ns3__TaxInfoType {
      public:
        /// Required element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Required element 'ns3:SalesTaxPercentage' of XSD type 'xsd:string'
        std::string SalesTaxPercentage;
        /// Required element 'ns3:TaxState' of XSD type 'xsd:string'
        std::string TaxState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TaxInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TaxInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TaxInfoType, default initialized and not managed by a soap context
        virtual ns3__TaxInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__TaxInfoType); }
      public:
        /// Constructor with initializations
        ns3__TaxInfoType() : TaxAmount(), SalesTaxPercentage(), TaxState(), soap() { }
        virtual ~ns3__TaxInfoType() { }
        /// Friend allocator used by soap_new_ns3__TaxInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TaxInfoType * SOAP_FMAC2 soap_instantiate_ns3__TaxInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:994 */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentType
#define SOAP_TYPE_ns3__MerchantPullPaymentType (286)
/* complex XSD type 'ns3:MerchantPullPaymentType': */
class SOAP_CMAC ns3__MerchantPullPaymentType {
      public:
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Required element 'ns3:MpID' of XSD type 'ns3:MerchantPullIDType'
        std::string MpID;
        /// Optional element 'ns3:PaymentType' of XSD type 'ns3:MerchantPullPaymentCodeType'
        enum ns3__MerchantPullPaymentCodeType *PaymentType;
        /// Optional element 'ns3:Memo' of XSD type 'xsd:string'
        std::string *Memo;
        /// Optional element 'ns3:EmailSubject' of XSD type 'xsd:string'
        std::string *EmailSubject;
        /// Optional element 'ns3:Tax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Tax;
        /// Optional element 'ns3:Shipping' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Shipping;
        /// Optional element 'ns3:Handling' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Handling;
        /// Optional element 'ns3:ItemName' of XSD type 'xsd:string'
        std::string *ItemName;
        /// Optional element 'ns3:ItemNumber' of XSD type 'xsd:string'
        std::string *ItemNumber;
        /// Optional element 'ns3:Invoice' of XSD type 'xsd:string'
        std::string *Invoice;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:ButtonSource' of XSD type 'xsd:string'
        std::string *ButtonSource;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MerchantPullPaymentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MerchantPullPaymentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MerchantPullPaymentType, default initialized and not managed by a soap context
        virtual ns3__MerchantPullPaymentType *soap_alloc(void) const { return SOAP_NEW(ns3__MerchantPullPaymentType); }
      public:
        /// Constructor with initializations
        ns3__MerchantPullPaymentType() : Amount(), MpID(), PaymentType(), Memo(), EmailSubject(), Tax(), Shipping(), Handling(), ItemName(), ItemNumber(), Invoice(), Custom(), ButtonSource(), SoftDescriptor(), soap() { }
        virtual ~ns3__MerchantPullPaymentType() { }
        /// Friend allocator used by soap_new_ns3__MerchantPullPaymentType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MerchantPullPaymentType * SOAP_FMAC2 soap_instantiate_ns3__MerchantPullPaymentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:997 */
#ifndef SOAP_TYPE_ns3__PaymentTransactionType
#define SOAP_TYPE_ns3__PaymentTransactionType (287)
/* complex XSD type 'ns3:PaymentTransactionType': */
class SOAP_CMAC ns3__PaymentTransactionType {
      public:
        /// Required element 'ns3:ReceiverInfo' of XSD type 'ns3:ReceiverInfoType'
        ns3__ReceiverInfoType *ReceiverInfo;
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Optional element 'ns3:TPLReferenceID' of XSD type 'xsd:string'
        std::string *TPLReferenceID;
        /// Required element 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        ns3__PaymentInfoType *PaymentInfo;
        /// Optional element 'ns3:PaymentItemInfo' of XSD type 'ns3:PaymentItemInfoType'
        ns3__PaymentItemInfoType *PaymentItemInfo;
        /// Optional element 'ns3:OfferCouponInfo' of XSD type 'ns3:OfferCouponInfoType'
        ns3__OfferCouponInfoType *OfferCouponInfo;
        /// Optional element 'ns3:SecondaryAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *SecondaryAddress;
        /// Optional element 'ns3:UserSelectedOptions' of XSD type 'ns3:UserSelectedOptionType'
        ns3__UserSelectedOptionType *UserSelectedOptions;
        /// Optional element 'ns3:GiftMessage' of XSD type 'xsd:string'
        std::string *GiftMessage;
        /// Optional element 'ns3:GiftReceipt' of XSD type 'xsd:string'
        std::string *GiftReceipt;
        /// Optional element 'ns3:GiftWrapName' of XSD type 'xsd:string'
        std::string *GiftWrapName;
        /// Optional element 'ns3:GiftWrapAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GiftWrapAmount;
        /// Optional element 'ns3:BuyerEmailOptIn' of XSD type 'xsd:string'
        std::string *BuyerEmailOptIn;
        /// Optional element 'ns3:SurveyQuestion' of XSD type 'xsd:string'
        std::string *SurveyQuestion;
        /// Optional element 'ns3:SurveyChoiceSelected' of XSD type 'xsd:string'
        std::vector<std::string> SurveyChoiceSelected;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentTransactionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentTransactionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentTransactionType, default initialized and not managed by a soap context
        virtual ns3__PaymentTransactionType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentTransactionType); }
      public:
        /// Constructor with initializations
        ns3__PaymentTransactionType() : ReceiverInfo(), PayerInfo(), TPLReferenceID(), PaymentInfo(), PaymentItemInfo(), OfferCouponInfo(), SecondaryAddress(), UserSelectedOptions(), GiftMessage(), GiftReceipt(), GiftWrapName(), GiftWrapAmount(), BuyerEmailOptIn(), SurveyQuestion(), SurveyChoiceSelected(), soap() { }
        virtual ~ns3__PaymentTransactionType() { }
        /// Friend allocator used by soap_new_ns3__PaymentTransactionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentTransactionType * SOAP_FMAC2 soap_instantiate_ns3__PaymentTransactionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1000 */
#ifndef SOAP_TYPE_ns3__ReceiverInfoType
#define SOAP_TYPE_ns3__ReceiverInfoType (288)
/* complex XSD type 'ns3:ReceiverInfoType': */
class SOAP_CMAC ns3__ReceiverInfoType {
      public:
        /// Required element 'ns3:Business' of XSD type 'ns3:EmailAddressType'
        std::string Business;
        /// Required element 'ns3:Receiver' of XSD type 'ns3:EmailAddressType'
        std::string Receiver;
        /// Required element 'ns3:ReceiverID' of XSD type 'ns3:UserIDType'
        std::string ReceiverID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReceiverInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ReceiverInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReceiverInfoType, default initialized and not managed by a soap context
        virtual ns3__ReceiverInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__ReceiverInfoType); }
      public:
        /// Constructor with initializations
        ns3__ReceiverInfoType() : Business(), Receiver(), ReceiverID(), soap() { }
        virtual ~ns3__ReceiverInfoType() { }
        /// Friend allocator used by soap_new_ns3__ReceiverInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReceiverInfoType * SOAP_FMAC2 soap_instantiate_ns3__ReceiverInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1003 */
#ifndef SOAP_TYPE_ns3__PayerInfoType
#define SOAP_TYPE_ns3__PayerInfoType (289)
/* complex XSD type 'ns3:PayerInfoType': */
class SOAP_CMAC ns3__PayerInfoType {
      public:
        /// Optional element 'ns3:Payer' of XSD type 'ns3:EmailAddressType'
        std::string *Payer;
        /// Optional element 'ns3:PayerID' of XSD type 'ns3:UserIDType'
        std::string *PayerID;
        /// Optional element 'ns3:PayerStatus' of XSD type 'ns3:PayPalUserStatusCodeType'
        enum ns3__PayPalUserStatusCodeType *PayerStatus;
        /// Required element 'ns3:PayerName' of XSD type 'ns3:PersonNameType'
        ns3__PersonNameType *PayerName;
        /// Optional element 'ns3:PayerCountry' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *PayerCountry;
        /// Optional element 'ns3:PayerBusiness' of XSD type 'xsd:string'
        std::string *PayerBusiness;
        /// Optional element 'ns3:Address' of XSD type 'ns3:AddressType'
        ns3__AddressType *Address;
        /// Optional element 'ns3:ContactPhone' of XSD type 'xsd:string'
        std::string *ContactPhone;
        /// Optional element 'ns3:WalletItems' of XSD type 'ns3:WalletItemsType'
        std::vector<ns3__WalletItemsType *> WalletItems;
        /// Optional element 'ns3:TaxIdDetails' of XSD type 'ns3:TaxIdDetailsType'
        ns3__TaxIdDetailsType *TaxIdDetails;
        /// Optional element 'ns3:EnhancedPayerInfo' of XSD type 'ns4:EnhancedPayerInfoType'
        ns4__EnhancedPayerInfoType *EnhancedPayerInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PayerInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PayerInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PayerInfoType, default initialized and not managed by a soap context
        virtual ns3__PayerInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__PayerInfoType); }
      public:
        /// Constructor with initializations
        ns3__PayerInfoType() : Payer(), PayerID(), PayerStatus(), PayerName(), PayerCountry(), PayerBusiness(), Address(), ContactPhone(), WalletItems(), TaxIdDetails(), EnhancedPayerInfo(), soap() { }
        virtual ~ns3__PayerInfoType() { }
        /// Friend allocator used by soap_new_ns3__PayerInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PayerInfoType * SOAP_FMAC2 soap_instantiate_ns3__PayerInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1006 */
#ifndef SOAP_TYPE_ns3__PayeeInfoType
#define SOAP_TYPE_ns3__PayeeInfoType (290)
/* complex XSD type 'ns3:PayeeInfoType': */
class SOAP_CMAC ns3__PayeeInfoType {
      public:
        /// Optional element 'ns3:PayeeEmail' of XSD type 'ns3:EmailAddressType'
        std::string *PayeeEmail;
        /// Optional element 'ns3:PayeeID' of XSD type 'ns3:UserIDType'
        std::string *PayeeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PayeeInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PayeeInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PayeeInfoType, default initialized and not managed by a soap context
        virtual ns3__PayeeInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__PayeeInfoType); }
      public:
        /// Constructor with initializations
        ns3__PayeeInfoType() : PayeeEmail(), PayeeID(), soap() { }
        virtual ~ns3__PayeeInfoType() { }
        /// Friend allocator used by soap_new_ns3__PayeeInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PayeeInfoType * SOAP_FMAC2 soap_instantiate_ns3__PayeeInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1009 */
#ifndef SOAP_TYPE_ns3__InstrumentDetailsType
#define SOAP_TYPE_ns3__InstrumentDetailsType (291)
/* complex XSD type 'ns3:InstrumentDetailsType': */
class SOAP_CMAC ns3__InstrumentDetailsType {
      public:
        /// Optional element 'ns3:InstrumentCategory' of XSD type 'xsd:string'
        std::string *InstrumentCategory;
        /// Optional element 'ns3:InstrumentID' of XSD type 'xsd:string'
        std::string *InstrumentID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__InstrumentDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InstrumentDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InstrumentDetailsType, default initialized and not managed by a soap context
        virtual ns3__InstrumentDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__InstrumentDetailsType); }
      public:
        /// Constructor with initializations
        ns3__InstrumentDetailsType() : InstrumentCategory(), InstrumentID(), soap() { }
        virtual ~ns3__InstrumentDetailsType() { }
        /// Friend allocator used by soap_new_ns3__InstrumentDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InstrumentDetailsType * SOAP_FMAC2 soap_instantiate_ns3__InstrumentDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1012 */
#ifndef SOAP_TYPE_ns3__BMLOfferInfoType
#define SOAP_TYPE_ns3__BMLOfferInfoType (292)
/* complex XSD type 'ns3:BMLOfferInfoType': */
class SOAP_CMAC ns3__BMLOfferInfoType {
      public:
        /// Optional element 'ns3:OfferTrackingID' of XSD type 'xsd:string'
        std::string *OfferTrackingID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BMLOfferInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BMLOfferInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BMLOfferInfoType, default initialized and not managed by a soap context
        virtual ns3__BMLOfferInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__BMLOfferInfoType); }
      public:
        /// Constructor with initializations
        ns3__BMLOfferInfoType() : OfferTrackingID(), soap() { }
        virtual ~ns3__BMLOfferInfoType() { }
        /// Friend allocator used by soap_new_ns3__BMLOfferInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BMLOfferInfoType * SOAP_FMAC2 soap_instantiate_ns3__BMLOfferInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1015 */
#ifndef SOAP_TYPE_ns3__OfferDetailsType
#define SOAP_TYPE_ns3__OfferDetailsType (293)
/* complex XSD type 'ns3:OfferDetailsType': */
class SOAP_CMAC ns3__OfferDetailsType {
      public:
        /// Optional element 'ns3:OfferCode' of XSD type 'xsd:string'
        std::string *OfferCode;
        /// Optional element 'ns3:BMLOfferInfo' of XSD type 'ns3:BMLOfferInfoType'
        ns3__BMLOfferInfoType *BMLOfferInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OfferDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OfferDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OfferDetailsType, default initialized and not managed by a soap context
        virtual ns3__OfferDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__OfferDetailsType); }
      public:
        /// Constructor with initializations
        ns3__OfferDetailsType() : OfferCode(), BMLOfferInfo(), soap() { }
        virtual ~ns3__OfferDetailsType() { }
        /// Friend allocator used by soap_new_ns3__OfferDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OfferDetailsType * SOAP_FMAC2 soap_instantiate_ns3__OfferDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1018 */
#ifndef SOAP_TYPE_ns3__PaymentInfoType
#define SOAP_TYPE_ns3__PaymentInfoType (294)
/* complex XSD type 'ns3:PaymentInfoType': */
class SOAP_CMAC ns3__PaymentInfoType {
      public:
        /// Optional element 'ns3:TransactionID' of XSD type 'xsd:string'
        std::string *TransactionID;
        /// Optional element 'ns3:EbayTransactionID' of XSD type 'xsd:string'
        std::string *EbayTransactionID;
        /// Optional element 'ns3:ParentTransactionID' of XSD type 'ns3:TransactionId'
        std::string *ParentTransactionID;
        /// Optional element 'ns3:ReceiptID' of XSD type 'xsd:string'
        std::string *ReceiptID;
        /// Required element 'ns3:TransactionType' of XSD type 'ns3:PaymentTransactionCodeType'
        enum ns3__PaymentTransactionCodeType TransactionType;
        /// Optional element 'ns3:PaymentType' of XSD type 'ns3:PaymentCodeType'
        enum ns3__PaymentCodeType *PaymentType;
        /// Optional element 'ns3:RefundSourceCodeType' of XSD type 'ns3:RefundSourceCodeType'
        enum ns3__RefundSourceCodeType *RefundSourceCodeType;
        /// Optional element 'ns3:ExpectedeCheckClearDate' of XSD type 'xsd:dateTime'
        time_t *ExpectedeCheckClearDate;
        /// Optional element 'ns3:PaymentDate' of XSD type 'xsd:dateTime'
        time_t *PaymentDate;
        /// Optional element 'ns3:GrossAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GrossAmount;
        /// Optional element 'ns3:FeeAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FeeAmount;
        /// Optional element 'ns3:FinancingFeeAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FinancingFeeAmount;
        /// Optional element 'ns3:FinancingTotalCost' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FinancingTotalCost;
        /// Optional element 'ns3:FinancingMonthlyPayment' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FinancingMonthlyPayment;
        /// Optional element 'ns3:FinancingTerm' of XSD type 'xsd:string'
        std::string *FinancingTerm;
        /// Optional element 'ns3:IsFinancing' of XSD type 'xsd:string'
        std::string *IsFinancing;
        /// Optional element 'ns3:SettleAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *SettleAmount;
        /// Optional element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Optional element 'ns3:ExchangeRate' of XSD type 'xsd:string'
        std::string *ExchangeRate;
        /// Required element 'ns3:PaymentStatus' of XSD type 'ns3:PaymentStatusCodeType'
        enum ns3__PaymentStatusCodeType PaymentStatus;
        /// Optional element 'ns3:PendingReason' of XSD type 'ns3:PendingStatusCodeType'
        enum ns3__PendingStatusCodeType *PendingReason;
        /// Optional element 'ns3:ReasonCode' of XSD type 'ns3:ReversalReasonCodeType'
        enum ns3__ReversalReasonCodeType *ReasonCode;
        /// Optional element 'ns3:HoldDecision' of XSD type 'xsd:string'
        std::string *HoldDecision;
        /// Optional element 'ns3:ShippingMethod' of XSD type 'xsd:string'
        std::string *ShippingMethod;
        /// Optional element 'ns3:ProtectionEligibility' of XSD type 'xsd:string'
        std::string *ProtectionEligibility;
        /// Optional element 'ns3:ProtectionEligibilityType' of XSD type 'xsd:string'
        std::string *ProtectionEligibilityType;
        /// Optional element 'ns3:ReceiptReferenceNumber' of XSD type 'xsd:string'
        std::string *ReceiptReferenceNumber;
        /// Optional element 'ns3:POSTransactionType' of XSD type 'ns3:POSTransactionCodeType'
        enum ns3__POSTransactionCodeType *POSTransactionType;
        /// Optional element 'ns3:ShipAmount' of XSD type 'xsd:string'
        std::string *ShipAmount;
        /// Optional element 'ns3:ShipHandleAmount' of XSD type 'xsd:string'
        std::string *ShipHandleAmount;
        /// Optional element 'ns3:ShipDiscount' of XSD type 'xsd:string'
        std::string *ShipDiscount;
        /// Optional element 'ns3:InsuranceAmount' of XSD type 'xsd:string'
        std::string *InsuranceAmount;
        /// Optional element 'ns3:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'ns3:StoreID' of XSD type 'xsd:string'
        std::string *StoreID;
        /// Optional element 'ns3:TerminalID' of XSD type 'xsd:string'
        std::string *TerminalID;
        /// Optional element 'ns3:SellerDetails' of XSD type 'ns3:SellerDetailsType'
        ns3__SellerDetailsType *SellerDetails;
        /// Optional element 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::string *PaymentRequestID;
        /// Optional element 'ns3:FMFDetails' of XSD type 'ns3:FMFDetailsType'
        ns3__FMFDetailsType *FMFDetails;
        /// Optional element 'ns3:EnhancedPaymentInfo' of XSD type 'ns4:EnhancedPaymentInfoType'
        ns4__EnhancedPaymentInfoType *EnhancedPaymentInfo;
        /// Optional element 'ns3:PaymentError' of XSD type 'ns3:ErrorType'
        ns3__ErrorType *PaymentError;
        /// Optional element 'ns3:InstrumentDetails' of XSD type 'ns3:InstrumentDetailsType'
        ns3__InstrumentDetailsType *InstrumentDetails;
        /// Optional element 'ns3:OfferDetails' of XSD type 'ns3:OfferDetailsType'
        ns3__OfferDetailsType *OfferDetails;
        /// Optional element 'ns3:BinEligibility' of XSD type 'xsd:string'
        std::string *BinEligibility;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:SoftDescriptorCity' of XSD type 'xsd:string'
        std::string *SoftDescriptorCity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentInfoType, default initialized and not managed by a soap context
        virtual ns3__PaymentInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentInfoType); }
      public:
        /// Constructor with initializations
        ns3__PaymentInfoType() : TransactionID(), EbayTransactionID(), ParentTransactionID(), ReceiptID(), TransactionType(), PaymentType(), RefundSourceCodeType(), ExpectedeCheckClearDate(), PaymentDate(), GrossAmount(), FeeAmount(), FinancingFeeAmount(), FinancingTotalCost(), FinancingMonthlyPayment(), FinancingTerm(), IsFinancing(), SettleAmount(), TaxAmount(), ExchangeRate(), PaymentStatus(), PendingReason(), ReasonCode(), HoldDecision(), ShippingMethod(), ProtectionEligibility(), ProtectionEligibilityType(), ReceiptReferenceNumber(), POSTransactionType(), ShipAmount(), ShipHandleAmount(), ShipDiscount(), InsuranceAmount(), Subject(), StoreID(), TerminalID(), SellerDetails(), PaymentRequestID(), FMFDetails(), EnhancedPaymentInfo(), PaymentError(), InstrumentDetails(), OfferDetails(), BinEligibility(), SoftDescriptor(), SoftDescriptorCity(), soap() { }
        virtual ~ns3__PaymentInfoType() { }
        /// Friend allocator used by soap_new_ns3__PaymentInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentInfoType * SOAP_FMAC2 soap_instantiate_ns3__PaymentInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1021 */
#ifndef SOAP_TYPE_ns3__SubscriptionTermsType
#define SOAP_TYPE_ns3__SubscriptionTermsType (295)
/* complex XSD type 'ns3:SubscriptionTermsType': */
class SOAP_CMAC ns3__SubscriptionTermsType {
      public:
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// required attribute 'period' of XSD type 'xsd:string'
        std::string period;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscriptionTermsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubscriptionTermsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscriptionTermsType, default initialized and not managed by a soap context
        virtual ns3__SubscriptionTermsType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscriptionTermsType); }
      public:
        /// Constructor with initializations
        ns3__SubscriptionTermsType() : Amount(), period(), soap() { }
        virtual ~ns3__SubscriptionTermsType() { }
        /// Friend allocator used by soap_new_ns3__SubscriptionTermsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscriptionTermsType * SOAP_FMAC2 soap_instantiate_ns3__SubscriptionTermsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1024 */
#ifndef SOAP_TYPE_ns3__SubscriptionInfoType
#define SOAP_TYPE_ns3__SubscriptionInfoType (296)
/* complex XSD type 'ns3:SubscriptionInfoType': */
class SOAP_CMAC ns3__SubscriptionInfoType {
      public:
        /// Required element 'ns3:SubscriptionID' of XSD type 'xsd:string'
        std::string SubscriptionID;
        /// Optional element 'ns3:SubscriptionDate' of XSD type 'xsd:dateTime'
        time_t *SubscriptionDate;
        /// Optional element 'ns3:EffectiveDate' of XSD type 'xsd:dateTime'
        time_t *EffectiveDate;
        /// Optional element 'ns3:RetryTime' of XSD type 'xsd:dateTime'
        time_t *RetryTime;
        /// Optional element 'ns3:Username' of XSD type 'xsd:string'
        std::string *Username;
        /// Optional element 'ns3:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'ns3:Recurrences' of XSD type 'xsd:string'
        std::string *Recurrences;
        /// Optional element 'ns3:Terms' of XSD type 'ns3:SubscriptionTermsType'
        std::vector<ns3__SubscriptionTermsType *> Terms;
        /// required attribute 'reattempt' of XSD type 'xsd:string'
        std::string reattempt;
        /// required attribute 'recurring' of XSD type 'xsd:string'
        std::string recurring;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscriptionInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubscriptionInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscriptionInfoType, default initialized and not managed by a soap context
        virtual ns3__SubscriptionInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscriptionInfoType); }
      public:
        /// Constructor with initializations
        ns3__SubscriptionInfoType() : SubscriptionID(), SubscriptionDate(), EffectiveDate(), RetryTime(), Username(), Password(), Recurrences(), Terms(), reattempt(), recurring(), soap() { }
        virtual ~ns3__SubscriptionInfoType() { }
        /// Friend allocator used by soap_new_ns3__SubscriptionInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscriptionInfoType * SOAP_FMAC2 soap_instantiate_ns3__SubscriptionInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1027 */
#ifndef SOAP_TYPE_ns3__AuctionInfoType
#define SOAP_TYPE_ns3__AuctionInfoType (297)
/* complex XSD type 'ns3:AuctionInfoType': */
class SOAP_CMAC ns3__AuctionInfoType {
      public:
        /// Optional element 'ns3:BuyerID' of XSD type 'xsd:string'
        std::string *BuyerID;
        /// Optional element 'ns3:ClosingDate' of XSD type 'xsd:dateTime'
        time_t *ClosingDate;
        /// required attribute 'multiItem' of XSD type 'xsd:string'
        std::string multiItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AuctionInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AuctionInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AuctionInfoType, default initialized and not managed by a soap context
        virtual ns3__AuctionInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__AuctionInfoType); }
      public:
        /// Constructor with initializations
        ns3__AuctionInfoType() : BuyerID(), ClosingDate(), multiItem(), soap() { }
        virtual ~ns3__AuctionInfoType() { }
        /// Friend allocator used by soap_new_ns3__AuctionInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AuctionInfoType * SOAP_FMAC2 soap_instantiate_ns3__AuctionInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1030 */
#ifndef SOAP_TYPE_ns3__OptionType
#define SOAP_TYPE_ns3__OptionType (298)
/* complex XSD type 'ns3:OptionType': */
class SOAP_CMAC ns3__OptionType {
      public:
        /// required attribute 'name' of XSD type 'xsd:string'
        std::string name;
        /// required attribute 'value' of XSD type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OptionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OptionType, default initialized and not managed by a soap context
        virtual ns3__OptionType *soap_alloc(void) const { return SOAP_NEW(ns3__OptionType); }
      public:
        /// Constructor with initializations
        ns3__OptionType() : name(), value(), soap() { }
        virtual ~ns3__OptionType() { }
        /// Friend allocator used by soap_new_ns3__OptionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OptionType * SOAP_FMAC2 soap_instantiate_ns3__OptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1033 */
#ifndef SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType
#define SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType (299)
/* complex XSD type 'ns3:EbayItemPaymentDetailsItemType': */
class SOAP_CMAC ns3__EbayItemPaymentDetailsItemType {
      public:
        /// Optional element 'ns3:ItemNumber' of XSD type 'xsd:string'
        std::string *ItemNumber;
        /// Optional element 'ns3:AuctionTransactionId' of XSD type 'xsd:string'
        std::string *AuctionTransactionId;
        /// Optional element 'ns3:OrderId' of XSD type 'xsd:string'
        std::string *OrderId;
        /// Optional element 'ns3:CartID' of XSD type 'xsd:string'
        std::string *CartID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__EbayItemPaymentDetailsItemType, default initialized and not managed by a soap context
        virtual ns3__EbayItemPaymentDetailsItemType *soap_alloc(void) const { return SOAP_NEW(ns3__EbayItemPaymentDetailsItemType); }
      public:
        /// Constructor with initializations
        ns3__EbayItemPaymentDetailsItemType() : ItemNumber(), AuctionTransactionId(), OrderId(), CartID(), soap() { }
        virtual ~ns3__EbayItemPaymentDetailsItemType() { }
        /// Friend allocator used by soap_new_ns3__EbayItemPaymentDetailsItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__EbayItemPaymentDetailsItemType * SOAP_FMAC2 soap_instantiate_ns3__EbayItemPaymentDetailsItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1036 */
#ifndef SOAP_TYPE_ns3__PaymentDetailsItemType
#define SOAP_TYPE_ns3__PaymentDetailsItemType (300)
/* complex XSD type 'ns3:PaymentDetailsItemType': */
class SOAP_CMAC ns3__PaymentDetailsItemType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Number' of XSD type 'xsd:string'
        std::string *Number;
        /// Optional element 'ns3:Quantity' of XSD type 'xsd:integer'
        std::string *Quantity;
        /// Optional element 'ns3:Tax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Tax;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:EbayItemPaymentDetailsItem' of XSD type 'ns3:EbayItemPaymentDetailsItemType'
        ns3__EbayItemPaymentDetailsItemType *EbayItemPaymentDetailsItem;
        /// Optional element 'ns3:PromoCode' of XSD type 'xsd:string'
        std::string *PromoCode;
        /// Optional element 'ns3:ProductCategory' of XSD type 'ns3:ProductCategoryType'
        enum ns3__ProductCategoryType *ProductCategory;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:ItemWeight' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *ItemWeight;
        /// Optional element 'ns3:ItemLength' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *ItemLength;
        /// Optional element 'ns3:ItemWidth' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *ItemWidth;
        /// Optional element 'ns3:ItemHeight' of XSD type 'ns2:MeasureType'
        ns2__MeasureType *ItemHeight;
        /// Optional element 'ns3:ItemURL' of XSD type 'xsd:string'
        std::string *ItemURL;
        /// Optional element 'ns3:EnhancedItemData' of XSD type 'ns4:EnhancedItemDataType'
        ns4__EnhancedItemDataType *EnhancedItemData;
        /// Optional element 'ns3:ItemCategory' of XSD type 'ns3:ItemCategoryType'
        enum ns3__ItemCategoryType *ItemCategory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentDetailsItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentDetailsItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentDetailsItemType, default initialized and not managed by a soap context
        virtual ns3__PaymentDetailsItemType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentDetailsItemType); }
      public:
        /// Constructor with initializations
        ns3__PaymentDetailsItemType() : Name(), Number(), Quantity(), Tax(), Amount(), EbayItemPaymentDetailsItem(), PromoCode(), ProductCategory(), Description(), ItemWeight(), ItemLength(), ItemWidth(), ItemHeight(), ItemURL(), EnhancedItemData(), ItemCategory(), soap() { }
        virtual ~ns3__PaymentDetailsItemType() { }
        /// Friend allocator used by soap_new_ns3__PaymentDetailsItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentDetailsItemType * SOAP_FMAC2 soap_instantiate_ns3__PaymentDetailsItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1039 */
#ifndef SOAP_TYPE_ns3__PaymentItemType
#define SOAP_TYPE_ns3__PaymentItemType (301)
/* complex XSD type 'ns3:PaymentItemType': */
class SOAP_CMAC ns3__PaymentItemType {
      public:
        /// Optional element 'ns3:EbayItemTxnId' of XSD type 'xsd:string'
        std::string *EbayItemTxnId;
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Number' of XSD type 'xsd:string'
        std::string *Number;
        /// Optional element 'ns3:Quantity' of XSD type 'xsd:string'
        std::string *Quantity;
        /// Optional element 'ns3:SalesTax' of XSD type 'xsd:string'
        std::string *SalesTax;
        /// Optional element 'ns3:ShippingAmount' of XSD type 'xsd:string'
        std::string *ShippingAmount;
        /// Optional element 'ns3:HandlingAmount' of XSD type 'xsd:string'
        std::string *HandlingAmount;
        /// Optional element 'ns3:InvoiceItemDetails' of XSD type 'ns3:InvoiceItemType'
        ns3__InvoiceItemType *InvoiceItemDetails;
        /// Optional element 'ns3:CouponID' of XSD type 'xsd:string'
        std::string *CouponID;
        /// Optional element 'ns3:CouponAmount' of XSD type 'xsd:string'
        std::string *CouponAmount;
        /// Optional element 'ns3:CouponAmountCurrency' of XSD type 'xsd:string'
        std::string *CouponAmountCurrency;
        /// Optional element 'ns3:LoyaltyCardDiscountAmount' of XSD type 'xsd:string'
        std::string *LoyaltyCardDiscountAmount;
        /// Optional element 'ns3:LoyaltyCardDiscountCurrency' of XSD type 'xsd:string'
        std::string *LoyaltyCardDiscountCurrency;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:Options' of XSD type 'ns3:OptionType'
        std::vector<ns3__OptionType *> Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentItemType, default initialized and not managed by a soap context
        virtual ns3__PaymentItemType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentItemType); }
      public:
        /// Constructor with initializations
        ns3__PaymentItemType() : EbayItemTxnId(), Name(), Number(), Quantity(), SalesTax(), ShippingAmount(), HandlingAmount(), InvoiceItemDetails(), CouponID(), CouponAmount(), CouponAmountCurrency(), LoyaltyCardDiscountAmount(), LoyaltyCardDiscountCurrency(), Amount(), Options(), soap() { }
        virtual ~ns3__PaymentItemType() { }
        /// Friend allocator used by soap_new_ns3__PaymentItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentItemType * SOAP_FMAC2 soap_instantiate_ns3__PaymentItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1042 */
#ifndef SOAP_TYPE_ns3__PaymentItemInfoType
#define SOAP_TYPE_ns3__PaymentItemInfoType (302)
/* complex XSD type 'ns3:PaymentItemInfoType': */
class SOAP_CMAC ns3__PaymentItemInfoType {
      public:
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:Memo' of XSD type 'xsd:string'
        std::string *Memo;
        /// Optional element 'ns3:SalesTax' of XSD type 'xsd:string'
        std::string *SalesTax;
        /// Optional element 'ns3:PaymentItem' of XSD type 'ns3:PaymentItemType'
        std::vector<ns3__PaymentItemType *> PaymentItem;
        /// Optional element 'ns3:Subscription' of XSD type 'ns3:SubscriptionInfoType'
        ns3__SubscriptionInfoType *Subscription;
        /// Optional element 'ns3:Auction' of XSD type 'ns3:AuctionInfoType'
        ns3__AuctionInfoType *Auction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentItemInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentItemInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentItemInfoType, default initialized and not managed by a soap context
        virtual ns3__PaymentItemInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentItemInfoType); }
      public:
        /// Constructor with initializations
        ns3__PaymentItemInfoType() : InvoiceID(), Custom(), Memo(), SalesTax(), PaymentItem(), Subscription(), Auction(), soap() { }
        virtual ~ns3__PaymentItemInfoType() { }
        /// Friend allocator used by soap_new_ns3__PaymentItemInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentItemInfoType * SOAP_FMAC2 soap_instantiate_ns3__PaymentItemInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1045 */
#ifndef SOAP_TYPE_ns3__OfferCouponInfoType
#define SOAP_TYPE_ns3__OfferCouponInfoType (303)
/* complex XSD type 'ns3:OfferCouponInfoType': */
class SOAP_CMAC ns3__OfferCouponInfoType {
      public:
        /// Optional element 'ns3:Type' of XSD type 'xsd:string'
        std::string *Type;
        /// Optional element 'ns3:ID' of XSD type 'xsd:string'
        std::string *ID;
        /// Optional element 'ns3:Amount' of XSD type 'xsd:string'
        std::string *Amount;
        /// Optional element 'ns3:AmountCurrency' of XSD type 'xsd:string'
        std::string *AmountCurrency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OfferCouponInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OfferCouponInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OfferCouponInfoType, default initialized and not managed by a soap context
        virtual ns3__OfferCouponInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__OfferCouponInfoType); }
      public:
        /// Constructor with initializations
        ns3__OfferCouponInfoType() : Type(), ID(), Amount(), AmountCurrency(), soap() { }
        virtual ~ns3__OfferCouponInfoType() { }
        /// Friend allocator used by soap_new_ns3__OfferCouponInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OfferCouponInfoType * SOAP_FMAC2 soap_instantiate_ns3__OfferCouponInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1048 */
#ifndef SOAP_TYPE_ns3__PaymentDetailsType
#define SOAP_TYPE_ns3__PaymentDetailsType (304)
/* complex XSD type 'ns3:PaymentDetailsType': */
class SOAP_CMAC ns3__PaymentDetailsType {
      public:
        /// Optional element 'ns3:OrderTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *OrderTotal;
        /// Optional element 'ns3:ItemTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemTotal;
        /// Optional element 'ns3:ShippingTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingTotal;
        /// Optional element 'ns3:HandlingTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *HandlingTotal;
        /// Optional element 'ns3:TaxTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxTotal;
        /// Optional element 'ns3:OrderDescription' of XSD type 'xsd:string'
        std::string *OrderDescription;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns3:ButtonSource' of XSD type 'xsd:string'
        std::string *ButtonSource;
        /// Optional element 'ns3:NotifyURL' of XSD type 'xsd:string'
        std::string *NotifyURL;
        /// Optional element 'ns3:ShipToAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *ShipToAddress;
        /// Optional element 'ns3:MultiShipping' of XSD type 'xsd:string'
        std::string *MultiShipping;
        /// Optional element 'ns3:FulfillmentReferenceNumber' of XSD type 'xsd:string'
        std::string *FulfillmentReferenceNumber;
        /// Optional element 'ns3:FulfillmentAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *FulfillmentAddress;
        /// Optional element 'ns3:PaymentCategoryType' of XSD type 'ns3:PaymentCategoryType'
        enum ns3__PaymentCategoryType *PaymentCategoryType;
        /// Optional element 'ns3:LocationType' of XSD type 'ns3:LocationType'
        enum ns3__LocationType *LocationType;
        /// Optional element 'ns3:ShippingMethod' of XSD type 'ns3:ShippingServiceCodeType'
        enum ns3__ShippingServiceCodeType *ShippingMethod;
        /// Optional element 'ns3:ProfileAddressChangeDate' of XSD type 'xsd:dateTime'
        time_t *ProfileAddressChangeDate;
        /// Optional element 'ns3:PaymentDetailsItem' of XSD type 'ns3:PaymentDetailsItemType'
        std::vector<ns3__PaymentDetailsItemType *> PaymentDetailsItem;
        /// Optional element 'ns3:InsuranceTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *InsuranceTotal;
        /// Optional element 'ns3:ShippingDiscount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingDiscount;
        /// Optional element 'ns3:InsuranceOptionOffered' of XSD type 'xsd:string'
        std::string *InsuranceOptionOffered;
        /// Optional element 'ns3:AllowedPaymentMethod' of XSD type 'ns3:AllowedPaymentMethodType'
        enum ns3__AllowedPaymentMethodType *AllowedPaymentMethod;
        /// Optional element 'ns3:EnhancedPaymentData' of XSD type 'ns4:EnhancedPaymentDataType'
        ns4__EnhancedPaymentDataType *EnhancedPaymentData;
        /// Optional element 'ns3:SellerDetails' of XSD type 'ns3:SellerDetailsType'
        ns3__SellerDetailsType *SellerDetails;
        /// Optional element 'ns3:NoteText' of XSD type 'xsd:string'
        std::string *NoteText;
        /// Optional element 'ns3:TransactionId' of XSD type 'xsd:string'
        std::string *TransactionId;
        /// Optional element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType *PaymentAction;
        /// Optional element 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::string *PaymentRequestID;
        /// Optional element 'ns3:OrderURL' of XSD type 'xsd:string'
        std::string *OrderURL;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:BranchLevel' of XSD type 'xsd:integer'
        std::string *BranchLevel;
        /// Optional element 'ns3:OfferDetails' of XSD type 'ns3:OfferDetailsType'
        ns3__OfferDetailsType *OfferDetails;
        /// Optional element 'ns3:Recurring' of XSD type 'ns3:RecurringFlagType'
        enum ns3__RecurringFlagType *Recurring;
        /// Optional element 'ns3:PaymentReason' of XSD type 'ns3:PaymentReasonType'
        enum ns3__PaymentReasonType *PaymentReason;
        /// Optional element 'ns3:LocationID' of XSD type 'xsd:string'
        std::string *LocationID;
        /// Sequence of 0 to 100 elements 'ns3:RedeemedOffers' of XSD type 'ns3:DiscountInfoType'
        std::vector<ns3__DiscountInfoType *> RedeemedOffers;
        /// Sequence of 0 to 100 elements 'ns3:CummulativePoints' of XSD type 'ns3:DiscountInfoType'
        std::vector<ns3__DiscountInfoType *> CummulativePoints;
        /// Sequence of 0 to 16 elements 'ns3:MerchantData' of XSD type 'ns3:MerchantDataType'
        std::vector<ns3__MerchantDataType *> MerchantData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentDetailsType, default initialized and not managed by a soap context
        virtual ns3__PaymentDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentDetailsType); }
      public:
        /// Constructor with initializations
        ns3__PaymentDetailsType() : OrderTotal(), ItemTotal(), ShippingTotal(), HandlingTotal(), TaxTotal(), OrderDescription(), Custom(), InvoiceID(), ButtonSource(), NotifyURL(), ShipToAddress(), MultiShipping(), FulfillmentReferenceNumber(), FulfillmentAddress(), PaymentCategoryType(), LocationType(), ShippingMethod(), ProfileAddressChangeDate(), PaymentDetailsItem(), InsuranceTotal(), ShippingDiscount(), InsuranceOptionOffered(), AllowedPaymentMethod(), EnhancedPaymentData(), SellerDetails(), NoteText(), TransactionId(), PaymentAction(), PaymentRequestID(), OrderURL(), SoftDescriptor(), BranchLevel(), OfferDetails(), Recurring(), PaymentReason(), LocationID(), RedeemedOffers(), CummulativePoints(), MerchantData(), soap() { }
        virtual ~ns3__PaymentDetailsType() { }
        /// Friend allocator used by soap_new_ns3__PaymentDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentDetailsType * SOAP_FMAC2 soap_instantiate_ns3__PaymentDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1051 */
#ifndef SOAP_TYPE_ns3__IncentiveDetailsType
#define SOAP_TYPE_ns3__IncentiveDetailsType (305)
/* complex XSD type 'ns3:IncentiveDetailsType': */
class SOAP_CMAC ns3__IncentiveDetailsType {
      public:
        /// Optional element 'ns3:UniqueIdentifier' of XSD type 'xsd:string'
        std::string *UniqueIdentifier;
        /// Optional element 'ns3:SiteAppliedOn' of XSD type 'ns3:IncentiveSiteAppliedOnType'
        enum ns3__IncentiveSiteAppliedOnType *SiteAppliedOn;
        /// Optional element 'ns3:TotalDiscountAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TotalDiscountAmount;
        /// Optional element 'ns3:Status' of XSD type 'ns3:IncentiveAppliedStatusType'
        enum ns3__IncentiveAppliedStatusType *Status;
        /// Optional element 'ns3:ErrorCode' of XSD type 'xsd:integer'
        std::string *ErrorCode;
        /// Optional element 'ns3:IncentiveAppliedDetails' of XSD type 'ns3:IncentiveAppliedDetailsType'
        std::vector<ns3__IncentiveAppliedDetailsType *> IncentiveAppliedDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveDetailsType, default initialized and not managed by a soap context
        virtual ns3__IncentiveDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveDetailsType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveDetailsType() : UniqueIdentifier(), SiteAppliedOn(), TotalDiscountAmount(), Status(), ErrorCode(), IncentiveAppliedDetails(), soap() { }
        virtual ~ns3__IncentiveDetailsType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveDetailsType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1054 */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedDetailsType
#define SOAP_TYPE_ns3__IncentiveAppliedDetailsType (306)
/* complex XSD type 'ns3:IncentiveAppliedDetailsType': */
class SOAP_CMAC ns3__IncentiveAppliedDetailsType {
      public:
        /// Optional element 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::string *PaymentRequestID;
        /// Optional element 'ns3:ItemId' of XSD type 'xsd:string'
        std::string *ItemId;
        /// Optional element 'ns3:ExternalTxnId' of XSD type 'xsd:string'
        std::string *ExternalTxnId;
        /// Optional element 'ns3:DiscountAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *DiscountAmount;
        /// Optional element 'ns3:SubType' of XSD type 'xsd:string'
        std::string *SubType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveAppliedDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveAppliedDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveAppliedDetailsType, default initialized and not managed by a soap context
        virtual ns3__IncentiveAppliedDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveAppliedDetailsType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveAppliedDetailsType() : PaymentRequestID(), ItemId(), ExternalTxnId(), DiscountAmount(), SubType(), soap() { }
        virtual ~ns3__IncentiveAppliedDetailsType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveAppliedDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveAppliedDetailsType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveAppliedDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1057 */
#ifndef SOAP_TYPE_ns3__SellerDetailsType
#define SOAP_TYPE_ns3__SellerDetailsType (307)
/* complex XSD type 'ns3:SellerDetailsType': */
class SOAP_CMAC ns3__SellerDetailsType {
      public:
        /// Optional element 'ns3:SellerId' of XSD type 'xsd:string'
        std::string *SellerId;
        /// Optional element 'ns3:SellerUserName' of XSD type 'xsd:string'
        std::string *SellerUserName;
        /// Optional element 'ns3:SellerRegistrationDate' of XSD type 'xsd:dateTime'
        time_t *SellerRegistrationDate;
        /// Optional element 'ns3:PayPalAccountID' of XSD type 'xsd:string'
        std::string *PayPalAccountID;
        /// Optional element 'ns3:SecureMerchantAccountID' of XSD type 'ns3:UserIDType'
        std::string *SecureMerchantAccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SellerDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SellerDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SellerDetailsType, default initialized and not managed by a soap context
        virtual ns3__SellerDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SellerDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SellerDetailsType() : SellerId(), SellerUserName(), SellerRegistrationDate(), PayPalAccountID(), SecureMerchantAccountID(), soap() { }
        virtual ~ns3__SellerDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SellerDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SellerDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SellerDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1060 */
#ifndef SOAP_TYPE_ns3__OtherPaymentMethodDetailsType
#define SOAP_TYPE_ns3__OtherPaymentMethodDetailsType (308)
/* complex XSD type 'ns3:OtherPaymentMethodDetailsType': */
class SOAP_CMAC ns3__OtherPaymentMethodDetailsType {
      public:
        /// Optional element 'ns3:OtherPaymentMethodId' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodId;
        /// Optional element 'ns3:OtherPaymentMethodType' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodType;
        /// Optional element 'ns3:OtherPaymentMethodLabel' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodLabel;
        /// Optional element 'ns3:OtherPaymentMethodLabelDescription' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodLabelDescription;
        /// Optional element 'ns3:OtherPaymentMethodLongDescriptionTitle' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodLongDescriptionTitle;
        /// Optional element 'ns3:OtherPaymentMethodLongDescription' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodLongDescription;
        /// Optional element 'ns3:OtherPaymentMethodIcon' of XSD type 'xsd:string'
        std::string *OtherPaymentMethodIcon;
        /// Optional element 'ns3:OtherPaymentMethodHideLabel' of XSD type 'xsd:boolean'
        bool *OtherPaymentMethodHideLabel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OtherPaymentMethodDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OtherPaymentMethodDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OtherPaymentMethodDetailsType, default initialized and not managed by a soap context
        virtual ns3__OtherPaymentMethodDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__OtherPaymentMethodDetailsType); }
      public:
        /// Constructor with initializations
        ns3__OtherPaymentMethodDetailsType() : OtherPaymentMethodId(), OtherPaymentMethodType(), OtherPaymentMethodLabel(), OtherPaymentMethodLabelDescription(), OtherPaymentMethodLongDescriptionTitle(), OtherPaymentMethodLongDescription(), OtherPaymentMethodIcon(), OtherPaymentMethodHideLabel(), soap() { }
        virtual ~ns3__OtherPaymentMethodDetailsType() { }
        /// Friend allocator used by soap_new_ns3__OtherPaymentMethodDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OtherPaymentMethodDetailsType * SOAP_FMAC2 soap_instantiate_ns3__OtherPaymentMethodDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1063 */
#ifndef SOAP_TYPE_ns3__BuyerDetailsType
#define SOAP_TYPE_ns3__BuyerDetailsType (309)
/* complex XSD type 'ns3:BuyerDetailsType': */
class SOAP_CMAC ns3__BuyerDetailsType {
      public:
        /// Optional element 'ns3:BuyerId' of XSD type 'xsd:string'
        std::string *BuyerId;
        /// Optional element 'ns3:BuyerUserName' of XSD type 'xsd:string'
        std::string *BuyerUserName;
        /// Optional element 'ns3:BuyerRegistrationDate' of XSD type 'xsd:dateTime'
        time_t *BuyerRegistrationDate;
        /// Optional element 'ns3:TaxIdDetails' of XSD type 'ns3:TaxIdDetailsType'
        ns3__TaxIdDetailsType *TaxIdDetails;
        /// Optional element 'ns3:IdentificationInfo' of XSD type 'ns3:IdentificationInfoType'
        ns3__IdentificationInfoType *IdentificationInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BuyerDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BuyerDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BuyerDetailsType, default initialized and not managed by a soap context
        virtual ns3__BuyerDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BuyerDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BuyerDetailsType() : BuyerId(), BuyerUserName(), BuyerRegistrationDate(), TaxIdDetails(), IdentificationInfo(), soap() { }
        virtual ~ns3__BuyerDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BuyerDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BuyerDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BuyerDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1066 */
#ifndef SOAP_TYPE_ns3__TaxIdDetailsType
#define SOAP_TYPE_ns3__TaxIdDetailsType (310)
/* complex XSD type 'ns3:TaxIdDetailsType': */
class SOAP_CMAC ns3__TaxIdDetailsType {
      public:
        /// Optional element 'ns3:TaxIdType' of XSD type 'xsd:string'
        std::string *TaxIdType;
        /// Optional element 'ns3:TaxId' of XSD type 'xsd:string'
        std::string *TaxId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TaxIdDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TaxIdDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TaxIdDetailsType, default initialized and not managed by a soap context
        virtual ns3__TaxIdDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__TaxIdDetailsType); }
      public:
        /// Constructor with initializations
        ns3__TaxIdDetailsType() : TaxIdType(), TaxId(), soap() { }
        virtual ~ns3__TaxIdDetailsType() { }
        /// Friend allocator used by soap_new_ns3__TaxIdDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TaxIdDetailsType * SOAP_FMAC2 soap_instantiate_ns3__TaxIdDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1069 */
#ifndef SOAP_TYPE_ns3__ThreeDSecureRequestType
#define SOAP_TYPE_ns3__ThreeDSecureRequestType (311)
/* complex XSD type 'ns3:ThreeDSecureRequestType': */
class SOAP_CMAC ns3__ThreeDSecureRequestType {
      public:
        /// Optional element 'ns3:Eci3ds' of XSD type 'xsd:string'
        std::string *Eci3ds;
        /// Optional element 'ns3:Cavv' of XSD type 'xsd:string'
        std::string *Cavv;
        /// Optional element 'ns3:Xid' of XSD type 'xsd:string'
        std::string *Xid;
        /// Optional element 'ns3:MpiVendor3ds' of XSD type 'xsd:string'
        std::string *MpiVendor3ds;
        /// Optional element 'ns3:AuthStatus3ds' of XSD type 'xsd:string'
        std::string *AuthStatus3ds;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ThreeDSecureRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ThreeDSecureRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ThreeDSecureRequestType, default initialized and not managed by a soap context
        virtual ns3__ThreeDSecureRequestType *soap_alloc(void) const { return SOAP_NEW(ns3__ThreeDSecureRequestType); }
      public:
        /// Constructor with initializations
        ns3__ThreeDSecureRequestType() : Eci3ds(), Cavv(), Xid(), MpiVendor3ds(), AuthStatus3ds(), soap() { }
        virtual ~ns3__ThreeDSecureRequestType() { }
        /// Friend allocator used by soap_new_ns3__ThreeDSecureRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ThreeDSecureRequestType * SOAP_FMAC2 soap_instantiate_ns3__ThreeDSecureRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1072 */
#ifndef SOAP_TYPE_ns3__ThreeDSecureResponseType
#define SOAP_TYPE_ns3__ThreeDSecureResponseType (312)
/* complex XSD type 'ns3:ThreeDSecureResponseType': */
class SOAP_CMAC ns3__ThreeDSecureResponseType {
      public:
        /// Optional element 'ns3:Vpas' of XSD type 'xsd:string'
        std::string *Vpas;
        /// Optional element 'ns3:EciSubmitted3DS' of XSD type 'xsd:string'
        std::string *EciSubmitted3DS;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ThreeDSecureResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ThreeDSecureResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ThreeDSecureResponseType, default initialized and not managed by a soap context
        virtual ns3__ThreeDSecureResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__ThreeDSecureResponseType); }
      public:
        /// Constructor with initializations
        ns3__ThreeDSecureResponseType() : Vpas(), EciSubmitted3DS(), soap() { }
        virtual ~ns3__ThreeDSecureResponseType() { }
        /// Friend allocator used by soap_new_ns3__ThreeDSecureResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ThreeDSecureResponseType * SOAP_FMAC2 soap_instantiate_ns3__ThreeDSecureResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1075 */
#ifndef SOAP_TYPE_ns3__ThreeDSecureInfoType
#define SOAP_TYPE_ns3__ThreeDSecureInfoType (313)
/* complex XSD type 'ns3:ThreeDSecureInfoType': */
class SOAP_CMAC ns3__ThreeDSecureInfoType {
      public:
        /// Optional element 'ns3:ThreeDSecureRequest' of XSD type 'ns3:ThreeDSecureRequestType'
        ns3__ThreeDSecureRequestType *ThreeDSecureRequest;
        /// Optional element 'ns3:ThreeDSecureResponse' of XSD type 'ns3:ThreeDSecureResponseType'
        ns3__ThreeDSecureResponseType *ThreeDSecureResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ThreeDSecureInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ThreeDSecureInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ThreeDSecureInfoType, default initialized and not managed by a soap context
        virtual ns3__ThreeDSecureInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__ThreeDSecureInfoType); }
      public:
        /// Constructor with initializations
        ns3__ThreeDSecureInfoType() : ThreeDSecureRequest(), ThreeDSecureResponse(), soap() { }
        virtual ~ns3__ThreeDSecureInfoType() { }
        /// Friend allocator used by soap_new_ns3__ThreeDSecureInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ThreeDSecureInfoType * SOAP_FMAC2 soap_instantiate_ns3__ThreeDSecureInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1078 */
#ifndef SOAP_TYPE_ns3__CreditCardDetailsType
#define SOAP_TYPE_ns3__CreditCardDetailsType (314)
/* complex XSD type 'ns3:CreditCardDetailsType': */
class SOAP_CMAC ns3__CreditCardDetailsType {
      public:
        /// Optional element 'ns3:CreditCardType' of XSD type 'ns3:CreditCardTypeType'
        enum ns3__CreditCardTypeType *CreditCardType;
        /// Optional element 'ns3:CreditCardNumber' of XSD type 'xsd:string'
        std::string *CreditCardNumber;
        /// Optional element 'ns3:ExpMonth' of XSD type 'xsd:int'
        int *ExpMonth;
        /// Optional element 'ns3:ExpYear' of XSD type 'xsd:int'
        int *ExpYear;
        /// Optional element 'ns3:CardOwner' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *CardOwner;
        /// Optional element 'ns3:CVV2' of XSD type 'xsd:string'
        std::string *CVV2;
        /// Optional element 'ns3:StartMonth' of XSD type 'xsd:int'
        int *StartMonth;
        /// Optional element 'ns3:StartYear' of XSD type 'xsd:int'
        int *StartYear;
        /// Optional element 'ns3:IssueNumber' of XSD type 'xsd:string'
        std::string *IssueNumber;
        /// Optional element 'ns3:ThreeDSecureRequest' of XSD type 'ns3:ThreeDSecureRequestType'
        ns3__ThreeDSecureRequestType *ThreeDSecureRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CreditCardDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CreditCardDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CreditCardDetailsType, default initialized and not managed by a soap context
        virtual ns3__CreditCardDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__CreditCardDetailsType); }
      public:
        /// Constructor with initializations
        ns3__CreditCardDetailsType() : CreditCardType(), CreditCardNumber(), ExpMonth(), ExpYear(), CardOwner(), CVV2(), StartMonth(), StartYear(), IssueNumber(), ThreeDSecureRequest(), soap() { }
        virtual ~ns3__CreditCardDetailsType() { }
        /// Friend allocator used by soap_new_ns3__CreditCardDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CreditCardDetailsType * SOAP_FMAC2 soap_instantiate_ns3__CreditCardDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1081 */
#ifndef SOAP_TYPE_ns3__ShippingOptionType
#define SOAP_TYPE_ns3__ShippingOptionType (315)
/* complex XSD type 'ns3:ShippingOptionType': */
class SOAP_CMAC ns3__ShippingOptionType {
      public:
        /// Optional element 'ns3:ShippingOptionIsDefault' of XSD type 'xsd:string'
        std::string *ShippingOptionIsDefault;
        /// Optional element 'ns3:ShippingOptionAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingOptionAmount;
        /// Optional element 'ns3:ShippingOptionName' of XSD type 'xsd:string'
        std::string *ShippingOptionName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ShippingOptionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ShippingOptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ShippingOptionType, default initialized and not managed by a soap context
        virtual ns3__ShippingOptionType *soap_alloc(void) const { return SOAP_NEW(ns3__ShippingOptionType); }
      public:
        /// Constructor with initializations
        ns3__ShippingOptionType() : ShippingOptionIsDefault(), ShippingOptionAmount(), ShippingOptionName(), soap() { }
        virtual ~ns3__ShippingOptionType() { }
        /// Friend allocator used by soap_new_ns3__ShippingOptionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ShippingOptionType * SOAP_FMAC2 soap_instantiate_ns3__ShippingOptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1084 */
#ifndef SOAP_TYPE_ns3__UserSelectedOptionType
#define SOAP_TYPE_ns3__UserSelectedOptionType (316)
/* complex XSD type 'ns3:UserSelectedOptionType': */
class SOAP_CMAC ns3__UserSelectedOptionType {
      public:
        /// Optional element 'ns3:ShippingCalculationMode' of XSD type 'xsd:string'
        std::string *ShippingCalculationMode;
        /// Optional element 'ns3:InsuranceOptionSelected' of XSD type 'xsd:string'
        std::string *InsuranceOptionSelected;
        /// Optional element 'ns3:ShippingOptionIsDefault' of XSD type 'xsd:string'
        std::string *ShippingOptionIsDefault;
        /// Optional element 'ns3:ShippingOptionAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingOptionAmount;
        /// Optional element 'ns3:ShippingOptionName' of XSD type 'xsd:string'
        std::string *ShippingOptionName;
        /// Optional element 'ns3:ScheduledShippingDate' of XSD type 'xsd:string'
        std::string *ScheduledShippingDate;
        /// Optional element 'ns3:ScheduledShippingPeriod' of XSD type 'xsd:string'
        std::string *ScheduledShippingPeriod;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UserSelectedOptionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UserSelectedOptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UserSelectedOptionType, default initialized and not managed by a soap context
        virtual ns3__UserSelectedOptionType *soap_alloc(void) const { return SOAP_NEW(ns3__UserSelectedOptionType); }
      public:
        /// Constructor with initializations
        ns3__UserSelectedOptionType() : ShippingCalculationMode(), InsuranceOptionSelected(), ShippingOptionIsDefault(), ShippingOptionAmount(), ShippingOptionName(), ScheduledShippingDate(), ScheduledShippingPeriod(), soap() { }
        virtual ~ns3__UserSelectedOptionType() { }
        /// Friend allocator used by soap_new_ns3__UserSelectedOptionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UserSelectedOptionType * SOAP_FMAC2 soap_instantiate_ns3__UserSelectedOptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1087 */
#ifndef SOAP_TYPE_ns3__CreditCardNumberTypeType
#define SOAP_TYPE_ns3__CreditCardNumberTypeType (317)
/* complex XSD type 'ns3:CreditCardNumberTypeType': */
class SOAP_CMAC ns3__CreditCardNumberTypeType {
      public:
        /// Optional element 'ns3:CreditCardType' of XSD type 'ns3:CreditCardTypeType'
        enum ns3__CreditCardTypeType *CreditCardType;
        /// Optional element 'ns3:CreditCardNumber' of XSD type 'xsd:string'
        std::string *CreditCardNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CreditCardNumberTypeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CreditCardNumberTypeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CreditCardNumberTypeType, default initialized and not managed by a soap context
        virtual ns3__CreditCardNumberTypeType *soap_alloc(void) const { return SOAP_NEW(ns3__CreditCardNumberTypeType); }
      public:
        /// Constructor with initializations
        ns3__CreditCardNumberTypeType() : CreditCardType(), CreditCardNumber(), soap() { }
        virtual ~ns3__CreditCardNumberTypeType() { }
        /// Friend allocator used by soap_new_ns3__CreditCardNumberTypeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CreditCardNumberTypeType * SOAP_FMAC2 soap_instantiate_ns3__CreditCardNumberTypeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1090 */
#ifndef SOAP_TYPE_ns3__ReferenceCreditCardDetailsType
#define SOAP_TYPE_ns3__ReferenceCreditCardDetailsType (318)
/* complex XSD type 'ns3:ReferenceCreditCardDetailsType': */
class SOAP_CMAC ns3__ReferenceCreditCardDetailsType {
      public:
        /// Optional element 'ns3:CreditCardNumberType' of XSD type 'ns3:CreditCardNumberTypeType'
        ns3__CreditCardNumberTypeType *CreditCardNumberType;
        /// Optional element 'ns3:ExpMonth' of XSD type 'xsd:int'
        int *ExpMonth;
        /// Optional element 'ns3:ExpYear' of XSD type 'xsd:int'
        int *ExpYear;
        /// Optional element 'ns3:CardOwnerName' of XSD type 'ns3:PersonNameType'
        ns3__PersonNameType *CardOwnerName;
        /// Optional element 'ns3:BillingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *BillingAddress;
        /// Optional element 'ns3:CVV2' of XSD type 'xsd:string'
        std::string *CVV2;
        /// Optional element 'ns3:StartMonth' of XSD type 'xsd:int'
        int *StartMonth;
        /// Optional element 'ns3:StartYear' of XSD type 'xsd:int'
        int *StartYear;
        /// Optional element 'ns3:IssueNumber' of XSD type 'xsd:string'
        std::string *IssueNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReferenceCreditCardDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ReferenceCreditCardDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReferenceCreditCardDetailsType, default initialized and not managed by a soap context
        virtual ns3__ReferenceCreditCardDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ReferenceCreditCardDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ReferenceCreditCardDetailsType() : CreditCardNumberType(), ExpMonth(), ExpYear(), CardOwnerName(), BillingAddress(), CVV2(), StartMonth(), StartYear(), IssueNumber(), soap() { }
        virtual ~ns3__ReferenceCreditCardDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ReferenceCreditCardDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReferenceCreditCardDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ReferenceCreditCardDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1093 */
#ifndef SOAP_TYPE_ns3__CustomSecurityHeaderType
#define SOAP_TYPE_ns3__CustomSecurityHeaderType (319)
/* complex XSD type 'ns3:CustomSecurityHeaderType': */
class SOAP_CMAC ns3__CustomSecurityHeaderType {
      public:
        /// Optional element 'ns3:eBayAuthToken' of XSD type 'xsd:string'
        std::string *eBayAuthToken;
        /// Optional element 'ns3:HardExpirationWarning' of XSD type 'xsd:string'
        std::string *HardExpirationWarning;
        /// Optional element 'ns3:Credentials' of XSD type 'ns3:UserIdPasswordType'
        ns3__UserIdPasswordType *Credentials;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CustomSecurityHeaderType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CustomSecurityHeaderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CustomSecurityHeaderType, default initialized and not managed by a soap context
        virtual ns3__CustomSecurityHeaderType *soap_alloc(void) const { return SOAP_NEW(ns3__CustomSecurityHeaderType); }
      public:
        /// Constructor with initializations
        ns3__CustomSecurityHeaderType() : eBayAuthToken(), HardExpirationWarning(), Credentials(), soap() { }
        virtual ~ns3__CustomSecurityHeaderType() { }
        /// Friend allocator used by soap_new_ns3__CustomSecurityHeaderType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CustomSecurityHeaderType * SOAP_FMAC2 soap_instantiate_ns3__CustomSecurityHeaderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1096 */
#ifndef SOAP_TYPE_ns3__UserIdPasswordType
#define SOAP_TYPE_ns3__UserIdPasswordType (320)
/* complex XSD type 'ns3:UserIdPasswordType': */
class SOAP_CMAC ns3__UserIdPasswordType {
      public:
        /// Optional element 'ns3:AppId' of XSD type 'xsd:string'
        std::string *AppId;
        /// Optional element 'ns3:DevId' of XSD type 'xsd:string'
        std::string *DevId;
        /// Optional element 'ns3:AuthCert' of XSD type 'xsd:string'
        std::string *AuthCert;
        /// Required element 'ns3:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Required element 'ns3:Password' of XSD type 'xsd:string'
        std::string Password;
        /// Optional element 'ns3:Signature' of XSD type 'xsd:string'
        std::string *Signature;
        /// Optional element 'ns3:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'ns3:AuthToken' of XSD type 'xsd:string'
        std::string *AuthToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UserIdPasswordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UserIdPasswordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UserIdPasswordType, default initialized and not managed by a soap context
        virtual ns3__UserIdPasswordType *soap_alloc(void) const { return SOAP_NEW(ns3__UserIdPasswordType); }
      public:
        /// Constructor with initializations
        ns3__UserIdPasswordType() : AppId(), DevId(), AuthCert(), Username(), Password(), Signature(), Subject(), AuthToken(), soap() { }
        virtual ~ns3__UserIdPasswordType() { }
        /// Friend allocator used by soap_new_ns3__UserIdPasswordType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UserIdPasswordType * SOAP_FMAC2 soap_instantiate_ns3__UserIdPasswordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1099 */
#ifndef SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType
#define SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType (321)
/* complex XSD type 'ns3:SetCustomerBillingAgreementRequestDetailsType': */
class SOAP_CMAC ns3__SetCustomerBillingAgreementRequestDetailsType {
      public:
        /// Required element 'ns3:BillingAgreementDetails' of XSD type 'ns3:BillingAgreementDetailsType'
        ns3__BillingAgreementDetailsType *BillingAgreementDetails;
        /// Required element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string ReturnURL;
        /// Required element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string CancelURL;
        /// Optional element 'ns3:LocaleCode' of XSD type 'xsd:string'
        std::string *LocaleCode;
        /// Optional element 'ns3:PageStyle' of XSD type 'xsd:string'
        std::string *PageStyle;
        /// Optional element 'ns3:cpp-header-image' of XSD type 'xsd:string'
        std::string *cpp_header_image;
        /// Optional element 'ns3:cpp-header-border-color' of XSD type 'xsd:string'
        std::string *cpp_header_border_color;
        /// Optional element 'ns3:cpp-header-back-color' of XSD type 'xsd:string'
        std::string *cpp_header_back_color;
        /// Optional element 'ns3:cpp-payflow-color' of XSD type 'xsd:string'
        std::string *cpp_payflow_color;
        /// Optional element 'ns3:BuyerEmail' of XSD type 'ns3:EmailAddressType'
        std::string *BuyerEmail;
        /// Optional element 'ns3:ReqBillingAddress' of XSD type 'xsd:string'
        std::string *ReqBillingAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetCustomerBillingAgreementRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetCustomerBillingAgreementRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetCustomerBillingAgreementRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetCustomerBillingAgreementRequestDetailsType() : BillingAgreementDetails(), ReturnURL(), CancelURL(), LocaleCode(), PageStyle(), cpp_header_image(), cpp_header_border_color(), cpp_header_back_color(), cpp_payflow_color(), BuyerEmail(), ReqBillingAddress(), soap() { }
        virtual ~ns3__SetCustomerBillingAgreementRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetCustomerBillingAgreementRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetCustomerBillingAgreementRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetCustomerBillingAgreementRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1102 */
#ifndef SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType (322)
/* complex XSD type 'ns3:GetBillingAgreementCustomerDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetBillingAgreementCustomerDetailsResponseDetailsType {
      public:
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Optional element 'ns3:BillingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *BillingAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetBillingAgreementCustomerDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetBillingAgreementCustomerDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetBillingAgreementCustomerDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetBillingAgreementCustomerDetailsResponseDetailsType() : PayerInfo(), BillingAddress(), soap() { }
        virtual ~ns3__GetBillingAgreementCustomerDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetBillingAgreementCustomerDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1105 */
#ifndef SOAP_TYPE_ns3__DeviceDetailsType
#define SOAP_TYPE_ns3__DeviceDetailsType (323)
/* complex XSD type 'ns3:DeviceDetailsType': */
class SOAP_CMAC ns3__DeviceDetailsType {
      public:
        /// Optional element 'ns3:DeviceID' of XSD type 'xsd:string'
        std::string *DeviceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DeviceDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DeviceDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DeviceDetailsType, default initialized and not managed by a soap context
        virtual ns3__DeviceDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DeviceDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DeviceDetailsType() : DeviceID(), soap() { }
        virtual ~ns3__DeviceDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DeviceDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DeviceDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DeviceDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1108 */
#ifndef SOAP_TYPE_ns3__SenderDetailsType
#define SOAP_TYPE_ns3__SenderDetailsType (324)
/* complex XSD type 'ns3:SenderDetailsType': */
class SOAP_CMAC ns3__SenderDetailsType {
      public:
        /// Optional element 'ns3:DeviceDetails' of XSD type 'ns3:DeviceDetailsType'
        ns3__DeviceDetailsType *DeviceDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SenderDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SenderDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SenderDetailsType, default initialized and not managed by a soap context
        virtual ns3__SenderDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SenderDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SenderDetailsType() : DeviceDetails(), soap() { }
        virtual ~ns3__SenderDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SenderDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SenderDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SenderDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1111 */
#ifndef SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType
#define SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType (325)
/* complex XSD type 'ns3:DoReferenceTransactionRequestDetailsType': */
class SOAP_CMAC ns3__DoReferenceTransactionRequestDetailsType {
      public:
        /// Required element 'ns3:ReferenceID' of XSD type 'xsd:string'
        std::string ReferenceID;
        /// Required element 'ns3:PaymentAction' of XSD type 'ns3:PaymentActionCodeType'
        enum ns3__PaymentActionCodeType PaymentAction;
        /// Optional element 'ns3:PaymentType' of XSD type 'ns3:MerchantPullPaymentCodeType'
        enum ns3__MerchantPullPaymentCodeType *PaymentType;
        /// Required element 'ns3:PaymentDetails' of XSD type 'ns3:PaymentDetailsType'
        ns3__PaymentDetailsType *PaymentDetails;
        /// Optional element 'ns3:CreditCard' of XSD type 'ns3:ReferenceCreditCardDetailsType'
        ns3__ReferenceCreditCardDetailsType *CreditCard;
        /// Optional element 'ns3:IPAddress' of XSD type 'xsd:string'
        std::string *IPAddress;
        /// Optional element 'ns3:RiskSessionCorrelationID' of XSD type 'xsd:string'
        std::string *RiskSessionCorrelationID;
        /// Optional element 'ns3:MerchantSessionId' of XSD type 'xsd:string'
        std::string *MerchantSessionId;
        /// Optional element 'ns3:ReqConfirmShipping' of XSD type 'xsd:string'
        std::string *ReqConfirmShipping;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:SoftDescriptorCity' of XSD type 'xsd:string'
        std::string *SoftDescriptorCity;
        /// Optional element 'ns3:SenderDetails' of XSD type 'ns3:SenderDetailsType'
        ns3__SenderDetailsType *SenderDetails;
        /// Optional element 'ns3:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoReferenceTransactionRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoReferenceTransactionRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoReferenceTransactionRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoReferenceTransactionRequestDetailsType() : ReferenceID(), PaymentAction(), PaymentType(), PaymentDetails(), CreditCard(), IPAddress(), RiskSessionCorrelationID(), MerchantSessionId(), ReqConfirmShipping(), SoftDescriptor(), SoftDescriptorCity(), SenderDetails(), MsgSubID(), soap() { }
        virtual ~ns3__DoReferenceTransactionRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoReferenceTransactionRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoReferenceTransactionRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoReferenceTransactionRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1114 */
#ifndef SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType
#define SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType (326)
/* complex XSD type 'ns3:DoReferenceTransactionResponseDetailsType': */
class SOAP_CMAC ns3__DoReferenceTransactionResponseDetailsType {
      public:
        /// Optional element 'ns3:BillingAgreementID' of XSD type 'xsd:string'
        std::string *BillingAgreementID;
        /// Optional element 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        ns3__PaymentInfoType *PaymentInfo;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:AVSCode' of XSD type 'xsd:string'
        std::string *AVSCode;
        /// Optional element 'ns3:CVV2Code' of XSD type 'xsd:string'
        std::string *CVV2Code;
        /// Optional element 'ns3:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Optional element 'ns3:PaymentAdviceCode' of XSD type 'xsd:string'
        std::string *PaymentAdviceCode;
        /// Optional element 'ns3:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns3:PendingReason' of XSD type 'xsd:string'
        std::string *PendingReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoReferenceTransactionResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoReferenceTransactionResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoReferenceTransactionResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoReferenceTransactionResponseDetailsType() : BillingAgreementID(), PaymentInfo(), Amount(), AVSCode(), CVV2Code(), TransactionID(), PaymentAdviceCode(), MsgSubID(), PendingReason(), soap() { }
        virtual ~ns3__DoReferenceTransactionResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoReferenceTransactionResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoReferenceTransactionResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoReferenceTransactionResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1117 */
#ifndef SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType
#define SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType (327)
/* complex XSD type 'ns3:DoNonReferencedCreditRequestDetailsType': */
class SOAP_CMAC ns3__DoNonReferencedCreditRequestDetailsType {
      public:
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:NetAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *NetAmount;
        /// Optional element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Optional element 'ns3:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Required element 'ns3:CreditCard' of XSD type 'ns3:CreditCardDetailsType'
        ns3__CreditCardDetailsType *CreditCard;
        /// Optional element 'ns3:ReceiverEmail' of XSD type 'xsd:string'
        std::string *ReceiverEmail;
        /// Optional element 'ns3:Comment' of XSD type 'xsd:string'
        std::string *Comment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoNonReferencedCreditRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoNonReferencedCreditRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoNonReferencedCreditRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoNonReferencedCreditRequestDetailsType() : Amount(), NetAmount(), TaxAmount(), ShippingAmount(), CreditCard(), ReceiverEmail(), Comment(), soap() { }
        virtual ~ns3__DoNonReferencedCreditRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoNonReferencedCreditRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoNonReferencedCreditRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoNonReferencedCreditRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1120 */
#ifndef SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType
#define SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType (328)
/* complex XSD type 'ns3:DoNonReferencedCreditResponseDetailsType': */
class SOAP_CMAC ns3__DoNonReferencedCreditResponseDetailsType {
      public:
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Required element 'ns3:TransactionID' of XSD type 'ns3:TransactionId'
        std::string TransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoNonReferencedCreditResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoNonReferencedCreditResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoNonReferencedCreditResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoNonReferencedCreditResponseDetailsType() : Amount(), TransactionID(), soap() { }
        virtual ~ns3__DoNonReferencedCreditResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoNonReferencedCreditResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoNonReferencedCreditResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoNonReferencedCreditResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1123 */
#ifndef SOAP_TYPE_ns3__EnterBoardingRequestDetailsType
#define SOAP_TYPE_ns3__EnterBoardingRequestDetailsType (329)
/* complex XSD type 'ns3:EnterBoardingRequestDetailsType': */
class SOAP_CMAC ns3__EnterBoardingRequestDetailsType {
      public:
        /// Required element 'ns3:ProgramCode' of XSD type 'xsd:string'
        std::string ProgramCode;
        /// Required element 'ns3:ProductList' of XSD type 'xsd:string'
        std::string ProductList;
        /// Optional element 'ns3:PartnerCustom' of XSD type 'xsd:string'
        std::string *PartnerCustom;
        /// Optional element 'ns3:ImageUrl' of XSD type 'xsd:string'
        std::string *ImageUrl;
        /// Optional element 'ns3:MarketingCategory' of XSD type 'ns3:MarketingCategoryType'
        enum ns3__MarketingCategoryType *MarketingCategory;
        /// Optional element 'ns3:BusinessInfo' of XSD type 'ns3:BusinessInfoType'
        ns3__BusinessInfoType *BusinessInfo;
        /// Optional element 'ns3:OwnerInfo' of XSD type 'ns3:BusinessOwnerInfoType'
        ns3__BusinessOwnerInfoType *OwnerInfo;
        /// Optional element 'ns3:BankAccount' of XSD type 'ns3:BankAccountDetailsType'
        ns3__BankAccountDetailsType *BankAccount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__EnterBoardingRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__EnterBoardingRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__EnterBoardingRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__EnterBoardingRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__EnterBoardingRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__EnterBoardingRequestDetailsType() : ProgramCode(), ProductList(), PartnerCustom(), ImageUrl(), MarketingCategory(), BusinessInfo(), OwnerInfo(), BankAccount(), soap() { }
        virtual ~ns3__EnterBoardingRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__EnterBoardingRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__EnterBoardingRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__EnterBoardingRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1126 */
#ifndef SOAP_TYPE_ns3__BusinessInfoType
#define SOAP_TYPE_ns3__BusinessInfoType (330)
/* complex XSD type 'ns3:BusinessInfoType': */
class SOAP_CMAC ns3__BusinessInfoType {
      public:
        /// Optional element 'ns3:Type' of XSD type 'ns3:BusinessTypeType'
        enum ns3__BusinessTypeType *Type;
        /// Optional element 'ns3:Name' of XSD type 'ns3:NameType'
        std::string *Name;
        /// Optional element 'ns3:Address' of XSD type 'ns3:AddressType'
        ns3__AddressType *Address;
        /// Optional element 'ns3:WorkPhone' of XSD type 'xsd:string'
        std::string *WorkPhone;
        /// Optional element 'ns3:Category' of XSD type 'ns3:BusinessCategoryType'
        enum ns3__BusinessCategoryType *Category;
        /// Optional element 'ns3:SubCategory' of XSD type 'ns3:BusinessSubCategoryType'
        enum ns3__BusinessSubCategoryType *SubCategory;
        /// Optional element 'ns3:AveragePrice' of XSD type 'ns3:AverageTransactionPriceType'
        enum ns3__AverageTransactionPriceType *AveragePrice;
        /// Optional element 'ns3:AverageMonthlyVolume' of XSD type 'ns3:AverageMonthlyVolumeType'
        enum ns3__AverageMonthlyVolumeType *AverageMonthlyVolume;
        /// Optional element 'ns3:SalesVenue' of XSD type 'ns3:SalesVenueType'
        enum ns3__SalesVenueType *SalesVenue;
        /// Optional element 'ns3:Website' of XSD type 'xsd:string'
        std::string *Website;
        /// Optional element 'ns3:RevenueFromOnlineSales' of XSD type 'ns3:PercentageRevenueFromOnlineSalesType'
        enum ns3__PercentageRevenueFromOnlineSalesType *RevenueFromOnlineSales;
        /// Optional element 'ns3:BusinessEstablished' of XSD type 'xsd:dateTime'
        time_t *BusinessEstablished;
        /// Optional element 'ns3:CustomerServiceEmail' of XSD type 'ns3:EmailAddressType'
        std::string *CustomerServiceEmail;
        /// Optional element 'ns3:CustomerServicePhone' of XSD type 'xsd:string'
        std::string *CustomerServicePhone;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BusinessInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BusinessInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BusinessInfoType, default initialized and not managed by a soap context
        virtual ns3__BusinessInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__BusinessInfoType); }
      public:
        /// Constructor with initializations
        ns3__BusinessInfoType() : Type(), Name(), Address(), WorkPhone(), Category(), SubCategory(), AveragePrice(), AverageMonthlyVolume(), SalesVenue(), Website(), RevenueFromOnlineSales(), BusinessEstablished(), CustomerServiceEmail(), CustomerServicePhone(), soap() { }
        virtual ~ns3__BusinessInfoType() { }
        /// Friend allocator used by soap_new_ns3__BusinessInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BusinessInfoType * SOAP_FMAC2 soap_instantiate_ns3__BusinessInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1129 */
#ifndef SOAP_TYPE_ns3__BusinessOwnerInfoType
#define SOAP_TYPE_ns3__BusinessOwnerInfoType (331)
/* complex XSD type 'ns3:BusinessOwnerInfoType': */
class SOAP_CMAC ns3__BusinessOwnerInfoType {
      public:
        /// Optional element 'ns3:Owner' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *Owner;
        /// Optional element 'ns3:HomePhone' of XSD type 'xsd:string'
        std::string *HomePhone;
        /// Optional element 'ns3:MobilePhone' of XSD type 'xsd:string'
        std::string *MobilePhone;
        /// Optional element 'ns3:SSN' of XSD type 'xsd:string'
        std::string *SSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BusinessOwnerInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BusinessOwnerInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BusinessOwnerInfoType, default initialized and not managed by a soap context
        virtual ns3__BusinessOwnerInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__BusinessOwnerInfoType); }
      public:
        /// Constructor with initializations
        ns3__BusinessOwnerInfoType() : Owner(), HomePhone(), MobilePhone(), SSN(), soap() { }
        virtual ~ns3__BusinessOwnerInfoType() { }
        /// Friend allocator used by soap_new_ns3__BusinessOwnerInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BusinessOwnerInfoType * SOAP_FMAC2 soap_instantiate_ns3__BusinessOwnerInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1132 */
#ifndef SOAP_TYPE_ns3__BankAccountDetailsType
#define SOAP_TYPE_ns3__BankAccountDetailsType (332)
/* complex XSD type 'ns3:BankAccountDetailsType': */
class SOAP_CMAC ns3__BankAccountDetailsType {
      public:
        /// Required element 'ns3:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'ns3:Type' of XSD type 'ns3:BankAccountTypeType'
        enum ns3__BankAccountTypeType Type;
        /// Required element 'ns3:RoutingNumber' of XSD type 'xsd:string'
        std::string RoutingNumber;
        /// Required element 'ns3:AccountNumber' of XSD type 'xsd:string'
        std::string AccountNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BankAccountDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BankAccountDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BankAccountDetailsType, default initialized and not managed by a soap context
        virtual ns3__BankAccountDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BankAccountDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BankAccountDetailsType() : Name(), Type(), RoutingNumber(), AccountNumber(), soap() { }
        virtual ~ns3__BankAccountDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BankAccountDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BankAccountDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BankAccountDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1135 */
#ifndef SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType (333)
/* complex XSD type 'ns3:GetBoardingDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetBoardingDetailsResponseDetailsType {
      public:
        /// Required element 'ns3:Status' of XSD type 'ns3:BoardingStatusType'
        enum ns3__BoardingStatusType Status;
        /// Required element 'ns3:StartDate' of XSD type 'xsd:dateTime'
        time_t StartDate;
        /// Required element 'ns3:LastUpdated' of XSD type 'xsd:dateTime'
        time_t LastUpdated;
        /// Optional element 'ns3:Reason' of XSD type 'xsd:string'
        std::string *Reason;
        /// Required element 'ns3:ProgramName' of XSD type 'xsd:string'
        std::string ProgramName;
        /// Required element 'ns3:ProgramCode' of XSD type 'xsd:string'
        std::string ProgramCode;
        /// Optional element 'ns3:CampaignID' of XSD type 'xsd:string'
        std::string *CampaignID;
        /// Optional element 'ns3:UserWithdrawalLimit' of XSD type 'ns3:UserWithdrawalLimitTypeType'
        enum ns3__UserWithdrawalLimitTypeType *UserWithdrawalLimit;
        /// Optional element 'ns3:PartnerCustom' of XSD type 'xsd:string'
        std::string *PartnerCustom;
        /// Optional element 'ns3:AccountOwner' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *AccountOwner;
        /// Optional element 'ns3:Credentials' of XSD type 'ns3:APICredentialsType'
        ns3__APICredentialsType *Credentials;
        /// Optional element 'ns3:ConfigureAPIs' of XSD type 'xsd:string'
        std::string *ConfigureAPIs;
        /// Optional element 'ns3:EmailVerificationStatus' of XSD type 'xsd:string'
        std::string *EmailVerificationStatus;
        /// Optional element 'ns3:VettingStatus' of XSD type 'xsd:string'
        std::string *VettingStatus;
        /// Optional element 'ns3:BankAccountVerificationStatus' of XSD type 'xsd:string'
        std::string *BankAccountVerificationStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetBoardingDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetBoardingDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetBoardingDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetBoardingDetailsResponseDetailsType() : Status(), StartDate(), LastUpdated(), Reason(), ProgramName(), ProgramCode(), CampaignID(), UserWithdrawalLimit(), PartnerCustom(), AccountOwner(), Credentials(), ConfigureAPIs(), EmailVerificationStatus(), VettingStatus(), BankAccountVerificationStatus(), soap() { }
        virtual ~ns3__GetBoardingDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetBoardingDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetBoardingDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetBoardingDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1138 */
#ifndef SOAP_TYPE_ns3__APICredentialsType
#define SOAP_TYPE_ns3__APICredentialsType (334)
/* complex XSD type 'ns3:APICredentialsType': */
class SOAP_CMAC ns3__APICredentialsType {
      public:
        /// Required element 'ns3:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Required element 'ns3:Password' of XSD type 'xsd:string'
        std::string Password;
        /// Optional element 'ns3:Signature' of XSD type 'xsd:string'
        std::string *Signature;
        /// Optional element 'ns3:Certificate' of XSD type 'xsd:string'
        std::string *Certificate;
        /// Required element 'ns3:Type' of XSD type 'ns3:APIAuthenticationType'
        enum ns3__APIAuthenticationType Type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__APICredentialsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__APICredentialsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__APICredentialsType, default initialized and not managed by a soap context
        virtual ns3__APICredentialsType *soap_alloc(void) const { return SOAP_NEW(ns3__APICredentialsType); }
      public:
        /// Constructor with initializations
        ns3__APICredentialsType() : Username(), Password(), Signature(), Certificate(), Type(), soap() { }
        virtual ~ns3__APICredentialsType() { }
        /// Friend allocator used by soap_new_ns3__APICredentialsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__APICredentialsType * SOAP_FMAC2 soap_instantiate_ns3__APICredentialsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1141 */
#ifndef SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType (335)
/* complex XSD type 'ns3:SetMobileCheckoutRequestDetailsType': */
class SOAP_CMAC ns3__SetMobileCheckoutRequestDetailsType {
      public:
        /// Optional element 'ns3:BuyerPhone' of XSD type 'ns3:PhoneNumberType'
        ns3__PhoneNumberType *BuyerPhone;
        /// Required element 'ns3:ItemAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemAmount;
        /// Optional element 'ns3:Tax' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Tax;
        /// Optional element 'ns3:Shipping' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Shipping;
        /// Required element 'ns3:ItemName' of XSD type 'xsd:string'
        std::string ItemName;
        /// Optional element 'ns3:ItemNumber' of XSD type 'xsd:string'
        std::string *ItemNumber;
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Required element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string ReturnURL;
        /// Optional element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string *CancelURL;
        /// Optional element 'ns3:AddressDisplayOptions' of XSD type 'xsd:int'
        int *AddressDisplayOptions;
        /// Optional element 'ns3:SharePhone' of XSD type 'xsd:int'
        int *SharePhone;
        /// Optional element 'ns3:ShipToAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *ShipToAddress;
        /// Optional element 'ns3:BuyerEmail' of XSD type 'ns3:EmailAddressType'
        std::string *BuyerEmail;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetMobileCheckoutRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetMobileCheckoutRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetMobileCheckoutRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetMobileCheckoutRequestDetailsType() : BuyerPhone(), ItemAmount(), Tax(), Shipping(), ItemName(), ItemNumber(), Custom(), InvoiceID(), ReturnURL(), CancelURL(), AddressDisplayOptions(), SharePhone(), ShipToAddress(), BuyerEmail(), soap() { }
        virtual ~ns3__SetMobileCheckoutRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetMobileCheckoutRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetMobileCheckoutRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetMobileCheckoutRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1144 */
#ifndef SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType (336)
/* complex XSD type 'ns3:DoMobileCheckoutPaymentResponseDetailsType': */
class SOAP_CMAC ns3__DoMobileCheckoutPaymentResponseDetailsType {
      public:
        /// Optional element 'ns3:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns3:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Required element 'ns3:PayerInfo' of XSD type 'ns3:PayerInfoType'
        ns3__PayerInfoType *PayerInfo;
        /// Required element 'ns3:PaymentInfo' of XSD type 'ns3:PaymentInfoType'
        ns3__PaymentInfoType *PaymentInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DoMobileCheckoutPaymentResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__DoMobileCheckoutPaymentResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DoMobileCheckoutPaymentResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DoMobileCheckoutPaymentResponseDetailsType() : Custom(), InvoiceID(), PayerInfo(), PaymentInfo(), soap() { }
        virtual ~ns3__DoMobileCheckoutPaymentResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DoMobileCheckoutPaymentResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DoMobileCheckoutPaymentResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DoMobileCheckoutPaymentResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1147 */
#ifndef SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType (337)
/* complex XSD type 'ns3:SetEbayMobileCheckoutRequestDetailsType': */
class SOAP_CMAC ns3__SetEbayMobileCheckoutRequestDetailsType {
      public:
        /// Required element 'ns3:CheckoutType' of XSD type 'ns3:EbayCheckoutType'
        enum ns3__EbayCheckoutType CheckoutType;
        /// Required element 'ns3:ItemId' of XSD type 'xsd:string'
        std::string ItemId;
        /// Required element 'ns3:TransactionId' of XSD type 'xsd:string'
        std::string TransactionId;
        /// Required element 'ns3:SiteId' of XSD type 'xsd:string'
        std::string SiteId;
        /// Required element 'ns3:BuyerId' of XSD type 'xsd:string'
        std::string BuyerId;
        /// Required element 'ns3:ClientType' of XSD type 'ns3:DyneticClientType'
        enum ns3__DyneticClientType ClientType;
        /// Optional element 'ns3:BuyerPhone' of XSD type 'ns3:PhoneNumberType'
        ns3__PhoneNumberType *BuyerPhone;
        /// Optional element 'ns3:ReturnURL' of XSD type 'xsd:string'
        std::string *ReturnURL;
        /// Optional element 'ns3:CancelURL' of XSD type 'xsd:string'
        std::string *CancelURL;
        /// Optional element 'ns3:Quantity' of XSD type 'xsd:int'
        int *Quantity;
        /// Optional element 'ns3:ItemAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SetEbayMobileCheckoutRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__SetEbayMobileCheckoutRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__SetEbayMobileCheckoutRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__SetEbayMobileCheckoutRequestDetailsType() : CheckoutType(), ItemId(), TransactionId(), SiteId(), BuyerId(), ClientType(), BuyerPhone(), ReturnURL(), CancelURL(), Quantity(), ItemAmount(), soap() { }
        virtual ~ns3__SetEbayMobileCheckoutRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__SetEbayMobileCheckoutRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SetEbayMobileCheckoutRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__SetEbayMobileCheckoutRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1150 */
#ifndef SOAP_TYPE_ns3__UATPDetailsType
#define SOAP_TYPE_ns3__UATPDetailsType (338)
/* complex XSD type 'ns3:UATPDetailsType': */
class SOAP_CMAC ns3__UATPDetailsType {
      public:
        /// Required element 'ns3:UATPNumber' of XSD type 'xsd:string'
        std::string UATPNumber;
        /// Required element 'ns3:ExpMonth' of XSD type 'xsd:int'
        int ExpMonth;
        /// Required element 'ns3:ExpYear' of XSD type 'xsd:int'
        int ExpYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UATPDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UATPDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UATPDetailsType, default initialized and not managed by a soap context
        virtual ns3__UATPDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__UATPDetailsType); }
      public:
        /// Constructor with initializations
        ns3__UATPDetailsType() : UATPNumber(), ExpMonth(), ExpYear(), soap() { }
        virtual ~ns3__UATPDetailsType() { }
        /// Friend allocator used by soap_new_ns3__UATPDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UATPDetailsType * SOAP_FMAC2 soap_instantiate_ns3__UATPDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1153 */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsSummaryType
#define SOAP_TYPE_ns3__RecurringPaymentsSummaryType (339)
/* complex XSD type 'ns3:RecurringPaymentsSummaryType': */
class SOAP_CMAC ns3__RecurringPaymentsSummaryType {
      public:
        /// Optional element 'ns3:NextBillingDate' of XSD type 'xsd:dateTime'
        time_t *NextBillingDate;
        /// Required element 'ns3:NumberCyclesCompleted' of XSD type 'xsd:int'
        int NumberCyclesCompleted;
        /// Required element 'ns3:NumberCyclesRemaining' of XSD type 'xsd:int'
        int NumberCyclesRemaining;
        /// Required element 'ns3:OutstandingBalance' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *OutstandingBalance;
        /// Required element 'ns3:FailedPaymentCount' of XSD type 'xsd:int'
        int FailedPaymentCount;
        /// Optional element 'ns3:LastPaymentDate' of XSD type 'xsd:dateTime'
        time_t *LastPaymentDate;
        /// Optional element 'ns3:LastPaymentAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *LastPaymentAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RecurringPaymentsSummaryType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RecurringPaymentsSummaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RecurringPaymentsSummaryType, default initialized and not managed by a soap context
        virtual ns3__RecurringPaymentsSummaryType *soap_alloc(void) const { return SOAP_NEW(ns3__RecurringPaymentsSummaryType); }
      public:
        /// Constructor with initializations
        ns3__RecurringPaymentsSummaryType() : NextBillingDate(), NumberCyclesCompleted(), NumberCyclesRemaining(), OutstandingBalance(), FailedPaymentCount(), LastPaymentDate(), LastPaymentAmount(), soap() { }
        virtual ~ns3__RecurringPaymentsSummaryType() { }
        /// Friend allocator used by soap_new_ns3__RecurringPaymentsSummaryType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RecurringPaymentsSummaryType * SOAP_FMAC2 soap_instantiate_ns3__RecurringPaymentsSummaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1156 */
#ifndef SOAP_TYPE_ns3__ActivationDetailsType
#define SOAP_TYPE_ns3__ActivationDetailsType (340)
/* complex XSD type 'ns3:ActivationDetailsType': */
class SOAP_CMAC ns3__ActivationDetailsType {
      public:
        /// Required element 'ns3:InitialAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *InitialAmount;
        /// Optional element 'ns3:FailedInitialAmountAction' of XSD type 'ns3:FailedPaymentActionType'
        enum ns3__FailedPaymentActionType *FailedInitialAmountAction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ActivationDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ActivationDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ActivationDetailsType, default initialized and not managed by a soap context
        virtual ns3__ActivationDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ActivationDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ActivationDetailsType() : InitialAmount(), FailedInitialAmountAction(), soap() { }
        virtual ~ns3__ActivationDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ActivationDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ActivationDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ActivationDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1159 */
#ifndef SOAP_TYPE_ns3__BillingPeriodDetailsType
#define SOAP_TYPE_ns3__BillingPeriodDetailsType (341)
/* complex XSD type 'ns3:BillingPeriodDetailsType': */
class SOAP_CMAC ns3__BillingPeriodDetailsType {
      public:
        /// Required element 'ns3:BillingPeriod' of XSD type 'ns3:BillingPeriodType'
        enum ns3__BillingPeriodType BillingPeriod;
        /// Required element 'ns3:BillingFrequency' of XSD type 'xsd:int'
        int BillingFrequency;
        /// Optional element 'ns3:TotalBillingCycles' of XSD type 'xsd:int'
        int *TotalBillingCycles;
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Optional element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillingPeriodDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillingPeriodDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillingPeriodDetailsType, default initialized and not managed by a soap context
        virtual ns3__BillingPeriodDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BillingPeriodDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BillingPeriodDetailsType() : BillingPeriod(), BillingFrequency(), TotalBillingCycles(), Amount(), ShippingAmount(), TaxAmount(), soap() { }
        virtual ~ns3__BillingPeriodDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BillingPeriodDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillingPeriodDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BillingPeriodDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1162 */
#ifndef SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate
#define SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate (342)
/* complex XSD type 'ns3:BillingPeriodDetailsType_Update': */
class SOAP_CMAC ns3__BillingPeriodDetailsType_USCOREUpdate {
      public:
        /// Optional element 'ns3:BillingPeriod' of XSD type 'ns3:BillingPeriodType'
        enum ns3__BillingPeriodType *BillingPeriod;
        /// Optional element 'ns3:BillingFrequency' of XSD type 'xsd:int'
        int *BillingFrequency;
        /// Optional element 'ns3:TotalBillingCycles' of XSD type 'xsd:int'
        int *TotalBillingCycles;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Optional element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillingPeriodDetailsType_USCOREUpdate, default initialized and not managed by a soap context
        virtual ns3__BillingPeriodDetailsType_USCOREUpdate *soap_alloc(void) const { return SOAP_NEW(ns3__BillingPeriodDetailsType_USCOREUpdate); }
      public:
        /// Constructor with initializations
        ns3__BillingPeriodDetailsType_USCOREUpdate() : BillingPeriod(), BillingFrequency(), TotalBillingCycles(), Amount(), ShippingAmount(), TaxAmount(), soap() { }
        virtual ~ns3__BillingPeriodDetailsType_USCOREUpdate() { }
        /// Friend allocator used by soap_new_ns3__BillingPeriodDetailsType_USCOREUpdate(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillingPeriodDetailsType_USCOREUpdate * SOAP_FMAC2 soap_instantiate_ns3__BillingPeriodDetailsType_USCOREUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1165 */
#ifndef SOAP_TYPE_ns3__ScheduleDetailsType
#define SOAP_TYPE_ns3__ScheduleDetailsType (343)
/* complex XSD type 'ns3:ScheduleDetailsType': */
class SOAP_CMAC ns3__ScheduleDetailsType {
      public:
        /// Required element 'ns3:Description' of XSD type 'xsd:string'
        std::string Description;
        /// Optional element 'ns3:TrialPeriod' of XSD type 'ns3:BillingPeriodDetailsType'
        ns3__BillingPeriodDetailsType *TrialPeriod;
        /// Required element 'ns3:PaymentPeriod' of XSD type 'ns3:BillingPeriodDetailsType'
        ns3__BillingPeriodDetailsType *PaymentPeriod;
        /// Optional element 'ns3:MaxFailedPayments' of XSD type 'xsd:int'
        int *MaxFailedPayments;
        /// Optional element 'ns3:ActivationDetails' of XSD type 'ns3:ActivationDetailsType'
        ns3__ActivationDetailsType *ActivationDetails;
        /// Optional element 'ns3:AutoBillOutstandingAmount' of XSD type 'ns3:AutoBillType'
        enum ns3__AutoBillType *AutoBillOutstandingAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ScheduleDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ScheduleDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ScheduleDetailsType, default initialized and not managed by a soap context
        virtual ns3__ScheduleDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ScheduleDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ScheduleDetailsType() : Description(), TrialPeriod(), PaymentPeriod(), MaxFailedPayments(), ActivationDetails(), AutoBillOutstandingAmount(), soap() { }
        virtual ~ns3__ScheduleDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ScheduleDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ScheduleDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ScheduleDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1168 */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType
#define SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType (344)
/* complex XSD type 'ns3:RecurringPaymentsProfileDetailsType': */
class SOAP_CMAC ns3__RecurringPaymentsProfileDetailsType {
      public:
        /// Optional element 'ns3:SubscriberName' of XSD type 'xsd:string'
        std::string *SubscriberName;
        /// Optional element 'ns3:SubscriberShippingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *SubscriberShippingAddress;
        /// Required element 'ns3:BillingStartDate' of XSD type 'xsd:dateTime'
        time_t BillingStartDate;
        /// Optional element 'ns3:ProfileReference' of XSD type 'xsd:string'
        std::string *ProfileReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RecurringPaymentsProfileDetailsType, default initialized and not managed by a soap context
        virtual ns3__RecurringPaymentsProfileDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__RecurringPaymentsProfileDetailsType); }
      public:
        /// Constructor with initializations
        ns3__RecurringPaymentsProfileDetailsType() : SubscriberName(), SubscriberShippingAddress(), BillingStartDate(), ProfileReference(), soap() { }
        virtual ~ns3__RecurringPaymentsProfileDetailsType() { }
        /// Friend allocator used by soap_new_ns3__RecurringPaymentsProfileDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RecurringPaymentsProfileDetailsType * SOAP_FMAC2 soap_instantiate_ns3__RecurringPaymentsProfileDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1171 */
#ifndef SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType (345)
/* complex XSD type 'ns3:CreateRecurringPaymentsProfileRequestDetailsType': */
class SOAP_CMAC ns3__CreateRecurringPaymentsProfileRequestDetailsType {
      public:
        /// Optional element 'ns3:Token' of XSD type 'xsd:string'
        std::string *Token;
        /// Optional element 'ns3:CreditCard' of XSD type 'ns3:CreditCardDetailsType'
        ns3__CreditCardDetailsType *CreditCard;
        /// Required element 'ns3:RecurringPaymentsProfileDetails' of XSD type 'ns3:RecurringPaymentsProfileDetailsType'
        ns3__RecurringPaymentsProfileDetailsType *RecurringPaymentsProfileDetails;
        /// Required element 'ns3:ScheduleDetails' of XSD type 'ns3:ScheduleDetailsType'
        ns3__ScheduleDetailsType *ScheduleDetails;
        /// Optional element 'ns3:PaymentDetailsItem' of XSD type 'ns3:PaymentDetailsItemType'
        std::vector<ns3__PaymentDetailsItemType *> PaymentDetailsItem;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:SoftDescriptorCity' of XSD type 'xsd:string'
        std::string *SoftDescriptorCity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CreateRecurringPaymentsProfileRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__CreateRecurringPaymentsProfileRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__CreateRecurringPaymentsProfileRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__CreateRecurringPaymentsProfileRequestDetailsType() : Token(), CreditCard(), RecurringPaymentsProfileDetails(), ScheduleDetails(), PaymentDetailsItem(), SoftDescriptor(), SoftDescriptorCity(), soap() { }
        virtual ~ns3__CreateRecurringPaymentsProfileRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__CreateRecurringPaymentsProfileRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CreateRecurringPaymentsProfileRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__CreateRecurringPaymentsProfileRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1174 */
#ifndef SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType (346)
/* complex XSD type 'ns3:CreateRecurringPaymentsProfileResponseDetailsType': */
class SOAP_CMAC ns3__CreateRecurringPaymentsProfileResponseDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Optional element 'ns3:ProfileStatus' of XSD type 'ns3:RecurringPaymentsProfileStatusType'
        enum ns3__RecurringPaymentsProfileStatusType *ProfileStatus;
        /// Optional element 'ns3:TransactionID' of XSD type 'xsd:string'
        std::string *TransactionID;
        /// Optional element 'ns3:DCCProcessorResponse' of XSD type 'xsd:string'
        std::string *DCCProcessorResponse;
        /// Optional element 'ns3:DCCReturnCode' of XSD type 'xsd:string'
        std::string *DCCReturnCode;
        /// Optional element 'ns3:PendingReason' of XSD type 'xsd:string'
        std::string *PendingReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CreateRecurringPaymentsProfileResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__CreateRecurringPaymentsProfileResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__CreateRecurringPaymentsProfileResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__CreateRecurringPaymentsProfileResponseDetailsType() : ProfileID(), ProfileStatus(), TransactionID(), DCCProcessorResponse(), DCCReturnCode(), PendingReason(), soap() { }
        virtual ~ns3__CreateRecurringPaymentsProfileResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__CreateRecurringPaymentsProfileResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CreateRecurringPaymentsProfileResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__CreateRecurringPaymentsProfileResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1177 */
#ifndef SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType (347)
/* complex XSD type 'ns3:GetRecurringPaymentsProfileDetailsResponseDetailsType': */
class SOAP_CMAC ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Required element 'ns3:ProfileStatus' of XSD type 'ns3:RecurringPaymentsProfileStatusType'
        enum ns3__RecurringPaymentsProfileStatusType ProfileStatus;
        /// Required element 'ns3:Description' of XSD type 'xsd:string'
        std::string Description;
        /// Required element 'ns3:AutoBillOutstandingAmount' of XSD type 'ns3:AutoBillType'
        enum ns3__AutoBillType AutoBillOutstandingAmount;
        /// Required element 'ns3:MaxFailedPayments' of XSD type 'xsd:int'
        int MaxFailedPayments;
        /// Required element 'ns3:RecurringPaymentsProfileDetails' of XSD type 'ns3:RecurringPaymentsProfileDetailsType'
        ns3__RecurringPaymentsProfileDetailsType *RecurringPaymentsProfileDetails;
        /// Optional element 'ns3:CurrentRecurringPaymentsPeriod' of XSD type 'ns3:BillingPeriodDetailsType'
        ns3__BillingPeriodDetailsType *CurrentRecurringPaymentsPeriod;
        /// Required element 'ns3:RecurringPaymentsSummary' of XSD type 'ns3:RecurringPaymentsSummaryType'
        ns3__RecurringPaymentsSummaryType *RecurringPaymentsSummary;
        /// Optional element 'ns3:CreditCard' of XSD type 'ns3:CreditCardDetailsType'
        ns3__CreditCardDetailsType *CreditCard;
        /// Optional element 'ns3:TrialRecurringPaymentsPeriod' of XSD type 'ns3:BillingPeriodDetailsType'
        ns3__BillingPeriodDetailsType *TrialRecurringPaymentsPeriod;
        /// Optional element 'ns3:RegularRecurringPaymentsPeriod' of XSD type 'ns3:BillingPeriodDetailsType'
        ns3__BillingPeriodDetailsType *RegularRecurringPaymentsPeriod;
        /// Optional element 'ns3:TrialAmountPaid' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TrialAmountPaid;
        /// Optional element 'ns3:RegularAmountPaid' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *RegularAmountPaid;
        /// Optional element 'ns3:AggregateAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *AggregateAmount;
        /// Optional element 'ns3:AggregateOptionalAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *AggregateOptionalAmount;
        /// Optional element 'ns3:FinalPaymentDueDate' of XSD type 'xsd:dateTime'
        time_t *FinalPaymentDueDate;
        /// Optional element 'ns3:SoftDescriptor' of XSD type 'xsd:string'
        std::string *SoftDescriptor;
        /// Optional element 'ns3:SoftDescriptorCity' of XSD type 'xsd:string'
        std::string *SoftDescriptorCity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType() : ProfileID(), ProfileStatus(), Description(), AutoBillOutstandingAmount(), MaxFailedPayments(), RecurringPaymentsProfileDetails(), CurrentRecurringPaymentsPeriod(), RecurringPaymentsSummary(), CreditCard(), TrialRecurringPaymentsPeriod(), RegularRecurringPaymentsPeriod(), TrialAmountPaid(), RegularAmountPaid(), AggregateAmount(), AggregateOptionalAmount(), FinalPaymentDueDate(), SoftDescriptor(), SoftDescriptorCity(), soap() { }
        virtual ~ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1180 */
#ifndef SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType
#define SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType (348)
/* complex XSD type 'ns3:ManageRecurringPaymentsProfileStatusRequestDetailsType': */
class SOAP_CMAC ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Required element 'ns3:Action' of XSD type 'ns3:StatusChangeActionType'
        enum ns3__StatusChangeActionType Action;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType() : ProfileID(), Action(), Note(), soap() { }
        virtual ~ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1183 */
#ifndef SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType
#define SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType (349)
/* complex XSD type 'ns3:ManageRecurringPaymentsProfileStatusResponseDetailsType': */
class SOAP_CMAC ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType() : ProfileID(), soap() { }
        virtual ~ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1186 */
#ifndef SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType
#define SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType (350)
/* complex XSD type 'ns3:BillOutstandingAmountRequestDetailsType': */
class SOAP_CMAC ns3__BillOutstandingAmountRequestDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillOutstandingAmountRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__BillOutstandingAmountRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BillOutstandingAmountRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BillOutstandingAmountRequestDetailsType() : ProfileID(), Amount(), Note(), soap() { }
        virtual ~ns3__BillOutstandingAmountRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BillOutstandingAmountRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillOutstandingAmountRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BillOutstandingAmountRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1189 */
#ifndef SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType
#define SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType (351)
/* complex XSD type 'ns3:BillOutstandingAmountResponseDetailsType': */
class SOAP_CMAC ns3__BillOutstandingAmountResponseDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__BillOutstandingAmountResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__BillOutstandingAmountResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__BillOutstandingAmountResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__BillOutstandingAmountResponseDetailsType() : ProfileID(), soap() { }
        virtual ~ns3__BillOutstandingAmountResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__BillOutstandingAmountResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__BillOutstandingAmountResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__BillOutstandingAmountResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1192 */
#ifndef SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType (352)
/* complex XSD type 'ns3:UpdateRecurringPaymentsProfileRequestDetailsType': */
class SOAP_CMAC ns3__UpdateRecurringPaymentsProfileRequestDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Optional element 'ns3:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:SubscriberName' of XSD type 'xsd:string'
        std::string *SubscriberName;
        /// Optional element 'ns3:SubscriberShippingAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *SubscriberShippingAddress;
        /// Optional element 'ns3:ProfileReference' of XSD type 'xsd:string'
        std::string *ProfileReference;
        /// Optional element 'ns3:AdditionalBillingCycles' of XSD type 'xsd:int'
        int *AdditionalBillingCycles;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Optional element 'ns3:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Optional element 'ns3:OutstandingBalance' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *OutstandingBalance;
        /// Optional element 'ns3:AutoBillOutstandingAmount' of XSD type 'ns3:AutoBillType'
        enum ns3__AutoBillType *AutoBillOutstandingAmount;
        /// Optional element 'ns3:MaxFailedPayments' of XSD type 'xsd:int'
        int *MaxFailedPayments;
        /// Optional element 'ns3:CreditCard' of XSD type 'ns3:CreditCardDetailsType'
        ns3__CreditCardDetailsType *CreditCard;
        /// Optional element 'ns3:BillingStartDate' of XSD type 'xsd:dateTime'
        time_t *BillingStartDate;
        /// Optional element 'ns3:TrialPeriod' of XSD type 'ns3:BillingPeriodDetailsType_Update'
        ns3__BillingPeriodDetailsType_USCOREUpdate *TrialPeriod;
        /// Optional element 'ns3:PaymentPeriod' of XSD type 'ns3:BillingPeriodDetailsType_Update'
        ns3__BillingPeriodDetailsType_USCOREUpdate *PaymentPeriod;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UpdateRecurringPaymentsProfileRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__UpdateRecurringPaymentsProfileRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__UpdateRecurringPaymentsProfileRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__UpdateRecurringPaymentsProfileRequestDetailsType() : ProfileID(), Note(), Description(), SubscriberName(), SubscriberShippingAddress(), ProfileReference(), AdditionalBillingCycles(), Amount(), ShippingAmount(), TaxAmount(), OutstandingBalance(), AutoBillOutstandingAmount(), MaxFailedPayments(), CreditCard(), BillingStartDate(), TrialPeriod(), PaymentPeriod(), soap() { }
        virtual ~ns3__UpdateRecurringPaymentsProfileRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__UpdateRecurringPaymentsProfileRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UpdateRecurringPaymentsProfileRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__UpdateRecurringPaymentsProfileRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1195 */
#ifndef SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType (353)
/* complex XSD type 'ns3:UpdateRecurringPaymentsProfileResponseDetailsType': */
class SOAP_CMAC ns3__UpdateRecurringPaymentsProfileResponseDetailsType {
      public:
        /// Required element 'ns3:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UpdateRecurringPaymentsProfileResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__UpdateRecurringPaymentsProfileResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__UpdateRecurringPaymentsProfileResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__UpdateRecurringPaymentsProfileResponseDetailsType() : ProfileID(), soap() { }
        virtual ~ns3__UpdateRecurringPaymentsProfileResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__UpdateRecurringPaymentsProfileResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UpdateRecurringPaymentsProfileResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__UpdateRecurringPaymentsProfileResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1198 */
#ifndef SOAP_TYPE_ns3__RiskFilterDetailsType
#define SOAP_TYPE_ns3__RiskFilterDetailsType (354)
/* complex XSD type 'ns3:RiskFilterDetailsType': */
class SOAP_CMAC ns3__RiskFilterDetailsType {
      public:
        /// Required element 'ns3:Id' of XSD type 'xsd:int'
        int Id;
        /// Required element 'ns3:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'ns3:Description' of XSD type 'xsd:string'
        std::string Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RiskFilterDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RiskFilterDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RiskFilterDetailsType, default initialized and not managed by a soap context
        virtual ns3__RiskFilterDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__RiskFilterDetailsType); }
      public:
        /// Constructor with initializations
        ns3__RiskFilterDetailsType() : Id(), Name(), Description(), soap() { }
        virtual ~ns3__RiskFilterDetailsType() { }
        /// Friend allocator used by soap_new_ns3__RiskFilterDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RiskFilterDetailsType * SOAP_FMAC2 soap_instantiate_ns3__RiskFilterDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1201 */
#ifndef SOAP_TYPE_ns3__RiskFilterListType
#define SOAP_TYPE_ns3__RiskFilterListType (355)
/* complex XSD type 'ns3:RiskFilterListType': */
class SOAP_CMAC ns3__RiskFilterListType {
      public:
        /// Required element 'ns3:Filters' of XSD type 'ns3:RiskFilterDetailsType'
        std::vector<ns3__RiskFilterDetailsType *> Filters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RiskFilterListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RiskFilterListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RiskFilterListType, default initialized and not managed by a soap context
        virtual ns3__RiskFilterListType *soap_alloc(void) const { return SOAP_NEW(ns3__RiskFilterListType); }
      public:
        /// Constructor with initializations
        ns3__RiskFilterListType() : Filters(), soap() { }
        virtual ~ns3__RiskFilterListType() { }
        /// Friend allocator used by soap_new_ns3__RiskFilterListType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RiskFilterListType * SOAP_FMAC2 soap_instantiate_ns3__RiskFilterListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1204 */
#ifndef SOAP_TYPE_ns3__FMFDetailsType
#define SOAP_TYPE_ns3__FMFDetailsType (356)
/* complex XSD type 'ns3:FMFDetailsType': */
class SOAP_CMAC ns3__FMFDetailsType {
      public:
        /// Optional element 'ns3:AcceptFilters' of XSD type 'ns3:RiskFilterListType'
        ns3__RiskFilterListType *AcceptFilters;
        /// Optional element 'ns3:PendingFilters' of XSD type 'ns3:RiskFilterListType'
        ns3__RiskFilterListType *PendingFilters;
        /// Optional element 'ns3:DenyFilters' of XSD type 'ns3:RiskFilterListType'
        ns3__RiskFilterListType *DenyFilters;
        /// Optional element 'ns3:ReportFilters' of XSD type 'ns3:RiskFilterListType'
        ns3__RiskFilterListType *ReportFilters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FMFDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FMFDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FMFDetailsType, default initialized and not managed by a soap context
        virtual ns3__FMFDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__FMFDetailsType); }
      public:
        /// Constructor with initializations
        ns3__FMFDetailsType() : AcceptFilters(), PendingFilters(), DenyFilters(), ReportFilters(), soap() { }
        virtual ~ns3__FMFDetailsType() { }
        /// Friend allocator used by soap_new_ns3__FMFDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FMFDetailsType * SOAP_FMAC2 soap_instantiate_ns3__FMFDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1207 */
#ifndef SOAP_TYPE_ns3__EnhancedDataType
#define SOAP_TYPE_ns3__EnhancedDataType (357)
/* complex XSD type 'ns3:EnhancedDataType': */
class SOAP_CMAC ns3__EnhancedDataType {
      public:
        /// Optional element 'ns3:AirlineItinerary' of XSD type 'ns3:AirlineItineraryType'
        ns3__AirlineItineraryType *AirlineItinerary;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__EnhancedDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__EnhancedDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__EnhancedDataType, default initialized and not managed by a soap context
        virtual ns3__EnhancedDataType *soap_alloc(void) const { return SOAP_NEW(ns3__EnhancedDataType); }
      public:
        /// Constructor with initializations
        ns3__EnhancedDataType() : AirlineItinerary(), soap() { }
        virtual ~ns3__EnhancedDataType() { }
        /// Friend allocator used by soap_new_ns3__EnhancedDataType(struct soap*, int)
        friend SOAP_FMAC1 ns3__EnhancedDataType * SOAP_FMAC2 soap_instantiate_ns3__EnhancedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1210 */
#ifndef SOAP_TYPE_ns3__AirlineItineraryType
#define SOAP_TYPE_ns3__AirlineItineraryType (358)
/* complex XSD type 'ns3:AirlineItineraryType': */
class SOAP_CMAC ns3__AirlineItineraryType {
      public:
        /// Optional element 'ns3:PassengerName' of XSD type 'xsd:string'
        std::string *PassengerName;
        /// Optional element 'ns3:IssueDate' of XSD type 'xsd:string'
        std::string *IssueDate;
        /// Optional element 'ns3:TravelAgencyName' of XSD type 'xsd:string'
        std::string *TravelAgencyName;
        /// Optional element 'ns3:TravelAgencyCode' of XSD type 'xsd:string'
        std::string *TravelAgencyCode;
        /// Optional element 'ns3:TicketNumber' of XSD type 'xsd:string'
        std::string *TicketNumber;
        /// Optional element 'ns3:IssuingCarrierCode' of XSD type 'xsd:string'
        std::string *IssuingCarrierCode;
        /// Optional element 'ns3:CustomerCode' of XSD type 'xsd:string'
        std::string *CustomerCode;
        /// Optional element 'ns3:TotalFare' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TotalFare;
        /// Optional element 'ns3:TotalTaxes' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TotalTaxes;
        /// Optional element 'ns3:TotalFee' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TotalFee;
        /// Optional element 'ns3:RestrictedTicket' of XSD type 'xsd:string'
        std::string *RestrictedTicket;
        /// Optional element 'ns3:ClearingSequence' of XSD type 'xsd:string'
        std::string *ClearingSequence;
        /// Optional element 'ns3:ClearingCount' of XSD type 'xsd:string'
        std::string *ClearingCount;
        /// Optional element 'ns3:FlightDetails' of XSD type 'ns3:FlightDetailsType'
        std::vector<ns3__FlightDetailsType *> FlightDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AirlineItineraryType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AirlineItineraryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AirlineItineraryType, default initialized and not managed by a soap context
        virtual ns3__AirlineItineraryType *soap_alloc(void) const { return SOAP_NEW(ns3__AirlineItineraryType); }
      public:
        /// Constructor with initializations
        ns3__AirlineItineraryType() : PassengerName(), IssueDate(), TravelAgencyName(), TravelAgencyCode(), TicketNumber(), IssuingCarrierCode(), CustomerCode(), TotalFare(), TotalTaxes(), TotalFee(), RestrictedTicket(), ClearingSequence(), ClearingCount(), FlightDetails(), soap() { }
        virtual ~ns3__AirlineItineraryType() { }
        /// Friend allocator used by soap_new_ns3__AirlineItineraryType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AirlineItineraryType * SOAP_FMAC2 soap_instantiate_ns3__AirlineItineraryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1213 */
#ifndef SOAP_TYPE_ns3__FlightDetailsType
#define SOAP_TYPE_ns3__FlightDetailsType (359)
/* complex XSD type 'ns3:FlightDetailsType': */
class SOAP_CMAC ns3__FlightDetailsType {
      public:
        /// Optional element 'ns3:ConjuctionTicket' of XSD type 'xsd:string'
        std::string *ConjuctionTicket;
        /// Optional element 'ns3:ExchangeTicket' of XSD type 'xsd:string'
        std::string *ExchangeTicket;
        /// Optional element 'ns3:CouponNumber' of XSD type 'xsd:string'
        std::string *CouponNumber;
        /// Optional element 'ns3:ServiceClass' of XSD type 'xsd:string'
        std::string *ServiceClass;
        /// Optional element 'ns3:TravelDate' of XSD type 'xsd:string'
        std::string *TravelDate;
        /// Optional element 'ns3:CarrierCode' of XSD type 'xsd:string'
        std::string *CarrierCode;
        /// Optional element 'ns3:StopOverPermitted' of XSD type 'xsd:string'
        std::string *StopOverPermitted;
        /// Optional element 'ns3:DepartureAirport' of XSD type 'xsd:string'
        std::string *DepartureAirport;
        /// Optional element 'ns3:ArrivalAirport' of XSD type 'xsd:string'
        std::string *ArrivalAirport;
        /// Optional element 'ns3:FlightNumber' of XSD type 'xsd:string'
        std::string *FlightNumber;
        /// Optional element 'ns3:DepartureTime' of XSD type 'xsd:string'
        std::string *DepartureTime;
        /// Optional element 'ns3:ArrivalTime' of XSD type 'xsd:string'
        std::string *ArrivalTime;
        /// Optional element 'ns3:FareBasisCode' of XSD type 'xsd:string'
        std::string *FareBasisCode;
        /// Optional element 'ns3:Fare' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Fare;
        /// Optional element 'ns3:Taxes' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Taxes;
        /// Optional element 'ns3:Fee' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Fee;
        /// Optional element 'ns3:EndorsementOrRestrictions' of XSD type 'xsd:string'
        std::string *EndorsementOrRestrictions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FlightDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FlightDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FlightDetailsType, default initialized and not managed by a soap context
        virtual ns3__FlightDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__FlightDetailsType); }
      public:
        /// Constructor with initializations
        ns3__FlightDetailsType() : ConjuctionTicket(), ExchangeTicket(), CouponNumber(), ServiceClass(), TravelDate(), CarrierCode(), StopOverPermitted(), DepartureAirport(), ArrivalAirport(), FlightNumber(), DepartureTime(), ArrivalTime(), FareBasisCode(), Fare(), Taxes(), Fee(), EndorsementOrRestrictions(), soap() { }
        virtual ~ns3__FlightDetailsType() { }
        /// Friend allocator used by soap_new_ns3__FlightDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FlightDetailsType * SOAP_FMAC2 soap_instantiate_ns3__FlightDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1216 */
#ifndef SOAP_TYPE_ns3__AuthorizationInfoType
#define SOAP_TYPE_ns3__AuthorizationInfoType (360)
/* complex XSD type 'ns3:AuthorizationInfoType': */
class SOAP_CMAC ns3__AuthorizationInfoType {
      public:
        /// Required element 'ns3:PaymentStatus' of XSD type 'ns3:PaymentStatusCodeType'
        enum ns3__PaymentStatusCodeType PaymentStatus;
        /// Optional element 'ns3:PendingReason' of XSD type 'ns3:PendingStatusCodeType'
        enum ns3__PendingStatusCodeType *PendingReason;
        /// Optional element 'ns3:ProtectionEligibility' of XSD type 'xsd:string'
        std::string *ProtectionEligibility;
        /// Optional element 'ns3:ProtectionEligibilityType' of XSD type 'xsd:string'
        std::string *ProtectionEligibilityType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AuthorizationInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AuthorizationInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AuthorizationInfoType, default initialized and not managed by a soap context
        virtual ns3__AuthorizationInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__AuthorizationInfoType); }
      public:
        /// Constructor with initializations
        ns3__AuthorizationInfoType() : PaymentStatus(), PendingReason(), ProtectionEligibility(), ProtectionEligibilityType(), soap() { }
        virtual ~ns3__AuthorizationInfoType() { }
        /// Friend allocator used by soap_new_ns3__AuthorizationInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AuthorizationInfoType * SOAP_FMAC2 soap_instantiate_ns3__AuthorizationInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1219 */
#ifndef SOAP_TYPE_ns3__OptionTrackingDetailsType
#define SOAP_TYPE_ns3__OptionTrackingDetailsType (361)
/* complex XSD type 'ns3:OptionTrackingDetailsType': */
class SOAP_CMAC ns3__OptionTrackingDetailsType {
      public:
        /// Optional element 'ns3:OptionNumber' of XSD type 'xsd:string'
        std::string *OptionNumber;
        /// Optional element 'ns3:OptionQty' of XSD type 'xsd:string'
        std::string *OptionQty;
        /// Optional element 'ns3:OptionSelect' of XSD type 'xsd:string'
        std::string *OptionSelect;
        /// Optional element 'ns3:OptionQtyDelta' of XSD type 'xsd:string'
        std::string *OptionQtyDelta;
        /// Optional element 'ns3:OptionAlert' of XSD type 'xsd:string'
        std::string *OptionAlert;
        /// Optional element 'ns3:OptionCost' of XSD type 'xsd:string'
        std::string *OptionCost;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OptionTrackingDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__OptionTrackingDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OptionTrackingDetailsType, default initialized and not managed by a soap context
        virtual ns3__OptionTrackingDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__OptionTrackingDetailsType); }
      public:
        /// Constructor with initializations
        ns3__OptionTrackingDetailsType() : OptionNumber(), OptionQty(), OptionSelect(), OptionQtyDelta(), OptionAlert(), OptionCost(), soap() { }
        virtual ~ns3__OptionTrackingDetailsType() { }
        /// Friend allocator used by soap_new_ns3__OptionTrackingDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__OptionTrackingDetailsType * SOAP_FMAC2 soap_instantiate_ns3__OptionTrackingDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1222 */
#ifndef SOAP_TYPE_ns3__ItemTrackingDetailsType
#define SOAP_TYPE_ns3__ItemTrackingDetailsType (362)
/* complex XSD type 'ns3:ItemTrackingDetailsType': */
class SOAP_CMAC ns3__ItemTrackingDetailsType {
      public:
        /// Optional element 'ns3:ItemNumber' of XSD type 'xsd:string'
        std::string *ItemNumber;
        /// Optional element 'ns3:ItemQty' of XSD type 'xsd:string'
        std::string *ItemQty;
        /// Optional element 'ns3:ItemQtyDelta' of XSD type 'xsd:string'
        std::string *ItemQtyDelta;
        /// Optional element 'ns3:ItemAlert' of XSD type 'xsd:string'
        std::string *ItemAlert;
        /// Optional element 'ns3:ItemCost' of XSD type 'xsd:string'
        std::string *ItemCost;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ItemTrackingDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ItemTrackingDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ItemTrackingDetailsType, default initialized and not managed by a soap context
        virtual ns3__ItemTrackingDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ItemTrackingDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ItemTrackingDetailsType() : ItemNumber(), ItemQty(), ItemQtyDelta(), ItemAlert(), ItemCost(), soap() { }
        virtual ~ns3__ItemTrackingDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ItemTrackingDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ItemTrackingDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ItemTrackingDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1225 */
#ifndef SOAP_TYPE_ns3__ButtonSearchResultType
#define SOAP_TYPE_ns3__ButtonSearchResultType (363)
/* complex XSD type 'ns3:ButtonSearchResultType': */
class SOAP_CMAC ns3__ButtonSearchResultType {
      public:
        /// Optional element 'ns3:HostedButtonID' of XSD type 'xsd:string'
        std::string *HostedButtonID;
        /// Optional element 'ns3:ButtonType' of XSD type 'xsd:string'
        std::string *ButtonType;
        /// Optional element 'ns3:ItemName' of XSD type 'xsd:string'
        std::string *ItemName;
        /// Optional element 'ns3:ModifyDate' of XSD type 'xsd:dateTime'
        time_t *ModifyDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ButtonSearchResultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ButtonSearchResultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ButtonSearchResultType, default initialized and not managed by a soap context
        virtual ns3__ButtonSearchResultType *soap_alloc(void) const { return SOAP_NEW(ns3__ButtonSearchResultType); }
      public:
        /// Constructor with initializations
        ns3__ButtonSearchResultType() : HostedButtonID(), ButtonType(), ItemName(), ModifyDate(), soap() { }
        virtual ~ns3__ButtonSearchResultType() { }
        /// Friend allocator used by soap_new_ns3__ButtonSearchResultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ButtonSearchResultType * SOAP_FMAC2 soap_instantiate_ns3__ButtonSearchResultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1228 */
#ifndef SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType
#define SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType (364)
/* complex XSD type 'ns3:ReverseTransactionRequestDetailsType': */
class SOAP_CMAC ns3__ReverseTransactionRequestDetailsType {
      public:
        /// Optional element 'ns3:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReverseTransactionRequestDetailsType, default initialized and not managed by a soap context
        virtual ns3__ReverseTransactionRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ReverseTransactionRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ReverseTransactionRequestDetailsType() : TransactionID(), soap() { }
        virtual ~ns3__ReverseTransactionRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ReverseTransactionRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReverseTransactionRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ReverseTransactionRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1231 */
#ifndef SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType
#define SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType (365)
/* complex XSD type 'ns3:ReverseTransactionResponseDetailsType': */
class SOAP_CMAC ns3__ReverseTransactionResponseDetailsType {
      public:
        /// Optional element 'ns3:ReverseTransactionID' of XSD type 'ns3:TransactionId'
        std::string *ReverseTransactionID;
        /// Required element 'ns3:Status' of XSD type 'xsd:string'
        std::string Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReverseTransactionResponseDetailsType, default initialized and not managed by a soap context
        virtual ns3__ReverseTransactionResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ReverseTransactionResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ReverseTransactionResponseDetailsType() : ReverseTransactionID(), Status(), soap() { }
        virtual ~ns3__ReverseTransactionResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ReverseTransactionResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReverseTransactionResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ReverseTransactionResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1234 */
#ifndef SOAP_TYPE_ns3__IncentiveInfoType
#define SOAP_TYPE_ns3__IncentiveInfoType (366)
/* complex XSD type 'ns3:IncentiveInfoType': */
class SOAP_CMAC ns3__IncentiveInfoType {
      public:
        /// Optional element 'ns3:IncentiveCode' of XSD type 'xsd:string'
        std::string *IncentiveCode;
        /// Optional element 'ns3:ApplyIndication' of XSD type 'ns3:IncentiveApplyIndicationType'
        std::vector<ns3__IncentiveApplyIndicationType *> ApplyIndication;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveInfoType, default initialized and not managed by a soap context
        virtual ns3__IncentiveInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveInfoType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveInfoType() : IncentiveCode(), ApplyIndication(), soap() { }
        virtual ~ns3__IncentiveInfoType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveInfoType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1237 */
#ifndef SOAP_TYPE_ns3__IncentiveApplyIndicationType
#define SOAP_TYPE_ns3__IncentiveApplyIndicationType (367)
/* complex XSD type 'ns3:IncentiveApplyIndicationType': */
class SOAP_CMAC ns3__IncentiveApplyIndicationType {
      public:
        /// Optional element 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::string *PaymentRequestID;
        /// Optional element 'ns3:ItemId' of XSD type 'xsd:string'
        std::string *ItemId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__IncentiveApplyIndicationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__IncentiveApplyIndicationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__IncentiveApplyIndicationType, default initialized and not managed by a soap context
        virtual ns3__IncentiveApplyIndicationType *soap_alloc(void) const { return SOAP_NEW(ns3__IncentiveApplyIndicationType); }
      public:
        /// Constructor with initializations
        ns3__IncentiveApplyIndicationType() : PaymentRequestID(), ItemId(), soap() { }
        virtual ~ns3__IncentiveApplyIndicationType() { }
        /// Friend allocator used by soap_new_ns3__IncentiveApplyIndicationType(struct soap*, int)
        friend SOAP_FMAC1 ns3__IncentiveApplyIndicationType * SOAP_FMAC2 soap_instantiate_ns3__IncentiveApplyIndicationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1240 */
#ifndef SOAP_TYPE_ns3__PaymentRequestInfoType
#define SOAP_TYPE_ns3__PaymentRequestInfoType (368)
/* complex XSD type 'ns3:PaymentRequestInfoType': */
class SOAP_CMAC ns3__PaymentRequestInfoType {
      public:
        /// Optional element 'ns3:TransactionId' of XSD type 'xsd:string'
        std::string *TransactionId;
        /// Optional element 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::string *PaymentRequestID;
        /// Optional element 'ns3:PaymentError' of XSD type 'ns3:ErrorType'
        ns3__ErrorType *PaymentError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PaymentRequestInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PaymentRequestInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PaymentRequestInfoType, default initialized and not managed by a soap context
        virtual ns3__PaymentRequestInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__PaymentRequestInfoType); }
      public:
        /// Constructor with initializations
        ns3__PaymentRequestInfoType() : TransactionId(), PaymentRequestID(), PaymentError(), soap() { }
        virtual ~ns3__PaymentRequestInfoType() { }
        /// Friend allocator used by soap_new_ns3__PaymentRequestInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PaymentRequestInfoType * SOAP_FMAC2 soap_instantiate_ns3__PaymentRequestInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1243 */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType (369)
/* complex XSD type 'ns3:ExternalRememberMeOwnerDetailsType': */
class SOAP_CMAC ns3__ExternalRememberMeOwnerDetailsType {
      public:
        /// Optional element 'ns3:ExternalRememberMeOwnerIDType' of XSD type 'xsd:string'
        std::string *ExternalRememberMeOwnerIDType;
        /// Optional element 'ns3:ExternalRememberMeOwnerID' of XSD type 'xsd:string'
        std::string *ExternalRememberMeOwnerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExternalRememberMeOwnerDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExternalRememberMeOwnerDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExternalRememberMeOwnerDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExternalRememberMeOwnerDetailsType() : ExternalRememberMeOwnerIDType(), ExternalRememberMeOwnerID(), soap() { }
        virtual ~ns3__ExternalRememberMeOwnerDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExternalRememberMeOwnerDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExternalRememberMeOwnerDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExternalRememberMeOwnerDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1246 */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType (370)
/* complex XSD type 'ns3:ExternalRememberMeOptInDetailsType': */
class SOAP_CMAC ns3__ExternalRememberMeOptInDetailsType {
      public:
        /// Optional element 'ns3:ExternalRememberMeOptIn' of XSD type 'xsd:string'
        std::string *ExternalRememberMeOptIn;
        /// Optional element 'ns3:ExternalRememberMeOwnerDetails' of XSD type 'ns3:ExternalRememberMeOwnerDetailsType'
        ns3__ExternalRememberMeOwnerDetailsType *ExternalRememberMeOwnerDetails;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExternalRememberMeOptInDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExternalRememberMeOptInDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExternalRememberMeOptInDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExternalRememberMeOptInDetailsType() : ExternalRememberMeOptIn(), ExternalRememberMeOwnerDetails(), soap() { }
        virtual ~ns3__ExternalRememberMeOptInDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExternalRememberMeOptInDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExternalRememberMeOptInDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExternalRememberMeOptInDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1249 */
#ifndef SOAP_TYPE_ns3__FlowControlDetailsType
#define SOAP_TYPE_ns3__FlowControlDetailsType (371)
/* complex XSD type 'ns3:FlowControlDetailsType': */
class SOAP_CMAC ns3__FlowControlDetailsType {
      public:
        /// Optional element 'ns3:ErrorURL' of XSD type 'xsd:string'
        std::string *ErrorURL;
        /// Optional element 'ns3:InContextReturnURL' of XSD type 'xsd:string'
        std::string *InContextReturnURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FlowControlDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FlowControlDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FlowControlDetailsType, default initialized and not managed by a soap context
        virtual ns3__FlowControlDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__FlowControlDetailsType); }
      public:
        /// Constructor with initializations
        ns3__FlowControlDetailsType() : ErrorURL(), InContextReturnURL(), soap() { }
        virtual ~ns3__FlowControlDetailsType() { }
        /// Friend allocator used by soap_new_ns3__FlowControlDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FlowControlDetailsType * SOAP_FMAC2 soap_instantiate_ns3__FlowControlDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1252 */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType (372)
/* complex XSD type 'ns3:ExternalRememberMeStatusDetailsType': */
class SOAP_CMAC ns3__ExternalRememberMeStatusDetailsType {
      public:
        /// Required element 'ns3:ExternalRememberMeStatus' of XSD type 'xsd:integer'
        std::string ExternalRememberMeStatus;
        /// Optional element 'ns3:ExternalRememberMeID' of XSD type 'xsd:string'
        std::string *ExternalRememberMeID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExternalRememberMeStatusDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExternalRememberMeStatusDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExternalRememberMeStatusDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExternalRememberMeStatusDetailsType() : ExternalRememberMeStatus(), ExternalRememberMeID(), soap() { }
        virtual ~ns3__ExternalRememberMeStatusDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExternalRememberMeStatusDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExternalRememberMeStatusDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExternalRememberMeStatusDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1255 */
#ifndef SOAP_TYPE_ns3__RefreshTokenStatusDetailsType
#define SOAP_TYPE_ns3__RefreshTokenStatusDetailsType (373)
/* complex XSD type 'ns3:RefreshTokenStatusDetailsType': */
class SOAP_CMAC ns3__RefreshTokenStatusDetailsType {
      public:
        /// Required element 'ns3:RefreshTokenStatus' of XSD type 'xsd:integer'
        std::string RefreshTokenStatus;
        /// Optional element 'ns3:RefreshToken' of XSD type 'xsd:string'
        std::string *RefreshToken;
        /// Optional element 'ns3:ImmutableID' of XSD type 'xsd:string'
        std::string *ImmutableID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RefreshTokenStatusDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RefreshTokenStatusDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RefreshTokenStatusDetailsType, default initialized and not managed by a soap context
        virtual ns3__RefreshTokenStatusDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__RefreshTokenStatusDetailsType); }
      public:
        /// Constructor with initializations
        ns3__RefreshTokenStatusDetailsType() : RefreshTokenStatus(), RefreshToken(), ImmutableID(), soap() { }
        virtual ~ns3__RefreshTokenStatusDetailsType() { }
        /// Friend allocator used by soap_new_ns3__RefreshTokenStatusDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RefreshTokenStatusDetailsType * SOAP_FMAC2 soap_instantiate_ns3__RefreshTokenStatusDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1258 */
#ifndef SOAP_TYPE_ns3__DisplayControlDetailsType
#define SOAP_TYPE_ns3__DisplayControlDetailsType (374)
/* complex XSD type 'ns3:DisplayControlDetailsType': */
class SOAP_CMAC ns3__DisplayControlDetailsType {
      public:
        /// Optional element 'ns3:InContextPaymentButtonImage' of XSD type 'xsd:string'
        std::string *InContextPaymentButtonImage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DisplayControlDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DisplayControlDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DisplayControlDetailsType, default initialized and not managed by a soap context
        virtual ns3__DisplayControlDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__DisplayControlDetailsType); }
      public:
        /// Constructor with initializations
        ns3__DisplayControlDetailsType() : InContextPaymentButtonImage(), soap() { }
        virtual ~ns3__DisplayControlDetailsType() { }
        /// Friend allocator used by soap_new_ns3__DisplayControlDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DisplayControlDetailsType * SOAP_FMAC2 soap_instantiate_ns3__DisplayControlDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1261 */
#ifndef SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType
#define SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType (375)
/* complex XSD type 'ns3:ExternalPartnerTrackingDetailsType': */
class SOAP_CMAC ns3__ExternalPartnerTrackingDetailsType {
      public:
        /// Optional element 'ns3:ExternalPartnerSegmentID' of XSD type 'xsd:string'
        std::string *ExternalPartnerSegmentID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExternalPartnerTrackingDetailsType, default initialized and not managed by a soap context
        virtual ns3__ExternalPartnerTrackingDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__ExternalPartnerTrackingDetailsType); }
      public:
        /// Constructor with initializations
        ns3__ExternalPartnerTrackingDetailsType() : ExternalPartnerSegmentID(), soap() { }
        virtual ~ns3__ExternalPartnerTrackingDetailsType() { }
        /// Friend allocator used by soap_new_ns3__ExternalPartnerTrackingDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExternalPartnerTrackingDetailsType * SOAP_FMAC2 soap_instantiate_ns3__ExternalPartnerTrackingDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1264 */
#ifndef SOAP_TYPE_ns3__MerchantStoreDetailsType
#define SOAP_TYPE_ns3__MerchantStoreDetailsType (376)
/* complex XSD type 'ns3:MerchantStoreDetailsType': */
class SOAP_CMAC ns3__MerchantStoreDetailsType {
      public:
        /// Required element 'ns3:StoreID' of XSD type 'xsd:string'
        std::string StoreID;
        /// Optional element 'ns3:TerminalID' of XSD type 'xsd:string'
        std::string *TerminalID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MerchantStoreDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MerchantStoreDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MerchantStoreDetailsType, default initialized and not managed by a soap context
        virtual ns3__MerchantStoreDetailsType *soap_alloc(void) const { return SOAP_NEW(ns3__MerchantStoreDetailsType); }
      public:
        /// Constructor with initializations
        ns3__MerchantStoreDetailsType() : StoreID(), TerminalID(), soap() { }
        virtual ~ns3__MerchantStoreDetailsType() { }
        /// Friend allocator used by soap_new_ns3__MerchantStoreDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MerchantStoreDetailsType * SOAP_FMAC2 soap_instantiate_ns3__MerchantStoreDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1267 */
#ifndef SOAP_TYPE_ns3__AdditionalFeeType
#define SOAP_TYPE_ns3__AdditionalFeeType (377)
/* complex XSD type 'ns3:AdditionalFeeType': */
class SOAP_CMAC ns3__AdditionalFeeType {
      public:
        /// Optional element 'ns3:Type' of XSD type 'xsd:string'
        std::string *Type;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AdditionalFeeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AdditionalFeeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AdditionalFeeType, default initialized and not managed by a soap context
        virtual ns3__AdditionalFeeType *soap_alloc(void) const { return SOAP_NEW(ns3__AdditionalFeeType); }
      public:
        /// Constructor with initializations
        ns3__AdditionalFeeType() : Type(), Amount(), soap() { }
        virtual ~ns3__AdditionalFeeType() { }
        /// Friend allocator used by soap_new_ns3__AdditionalFeeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AdditionalFeeType * SOAP_FMAC2 soap_instantiate_ns3__AdditionalFeeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1270 */
#ifndef SOAP_TYPE_ns3__DiscountType
#define SOAP_TYPE_ns3__DiscountType (378)
/* complex XSD type 'ns3:DiscountType': */
class SOAP_CMAC ns3__DiscountType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:RedeemedOfferType' of XSD type 'ns3:RedeemedOfferType'
        enum ns3__RedeemedOfferType *RedeemedOfferType;
        /// Optional element 'ns3:RedeemedOfferID' of XSD type 'xsd:string'
        std::string *RedeemedOfferID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DiscountType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DiscountType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DiscountType, default initialized and not managed by a soap context
        virtual ns3__DiscountType *soap_alloc(void) const { return SOAP_NEW(ns3__DiscountType); }
      public:
        /// Constructor with initializations
        ns3__DiscountType() : Name(), Description(), Amount(), RedeemedOfferType(), RedeemedOfferID(), soap() { }
        virtual ~ns3__DiscountType() { }
        /// Friend allocator used by soap_new_ns3__DiscountType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DiscountType * SOAP_FMAC2 soap_instantiate_ns3__DiscountType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1273 */
#ifndef SOAP_TYPE_ns3__InvoiceItemType
#define SOAP_TYPE_ns3__InvoiceItemType (379)
/* complex XSD type 'ns3:InvoiceItemType': */
class SOAP_CMAC ns3__InvoiceItemType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:EAN' of XSD type 'xsd:string'
        std::string *EAN;
        /// Optional element 'ns3:SKU' of XSD type 'xsd:string'
        std::string *SKU;
        /// Optional element 'ns3:ReturnPolicyIdentifier' of XSD type 'xsd:string'
        std::string *ReturnPolicyIdentifier;
        /// Optional element 'ns3:Price' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Price;
        /// Optional element 'ns3:ItemPrice' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemPrice;
        /// Optional element 'ns3:ItemCount' of XSD type 'xsd:double'
        double *ItemCount;
        /// Optional element 'ns3:ItemCountUnit' of XSD type 'ns3:UnitOfMeasure'
        enum ns3__UnitOfMeasure *ItemCountUnit;
        /// Optional element 'ns3:Discount' of XSD type 'ns3:DiscountType'
        std::vector<ns3__DiscountType *> Discount;
        /// Optional element 'ns3:Taxable' of XSD type 'xsd:boolean'
        bool *Taxable;
        /// Optional element 'ns3:TaxRate' of XSD type 'xsd:double'
        double *TaxRate;
        /// Optional element 'ns3:AdditionalFees' of XSD type 'ns3:AdditionalFeeType'
        std::vector<ns3__AdditionalFeeType *> AdditionalFees;
        /// Optional element 'ns3:Reimbursable' of XSD type 'xsd:boolean'
        bool *Reimbursable;
        /// Optional element 'ns3:MPN' of XSD type 'xsd:string'
        std::string *MPN;
        /// Optional element 'ns3:ISBN' of XSD type 'xsd:string'
        std::string *ISBN;
        /// Optional element 'ns3:PLU' of XSD type 'xsd:string'
        std::string *PLU;
        /// Optional element 'ns3:ModelNumber' of XSD type 'xsd:string'
        std::string *ModelNumber;
        /// Optional element 'ns3:StyleNumber' of XSD type 'xsd:string'
        std::string *StyleNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvoiceItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InvoiceItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvoiceItemType, default initialized and not managed by a soap context
        virtual ns3__InvoiceItemType *soap_alloc(void) const { return SOAP_NEW(ns3__InvoiceItemType); }
      public:
        /// Constructor with initializations
        ns3__InvoiceItemType() : Name(), Description(), EAN(), SKU(), ReturnPolicyIdentifier(), Price(), ItemPrice(), ItemCount(), ItemCountUnit(), Discount(), Taxable(), TaxRate(), AdditionalFees(), Reimbursable(), MPN(), ISBN(), PLU(), ModelNumber(), StyleNumber(), soap() { }
        virtual ~ns3__InvoiceItemType() { }
        /// Friend allocator used by soap_new_ns3__InvoiceItemType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvoiceItemType * SOAP_FMAC2 soap_instantiate_ns3__InvoiceItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1276 */
#ifndef SOAP_TYPE_ns3__RefundInfoType
#define SOAP_TYPE_ns3__RefundInfoType (380)
/* complex XSD type 'ns3:RefundInfoType': */
class SOAP_CMAC ns3__RefundInfoType {
      public:
        /// Optional element 'ns3:RefundStatus' of XSD type 'ns3:PaymentStatusCodeType'
        enum ns3__PaymentStatusCodeType *RefundStatus;
        /// Optional element 'ns3:PendingReason' of XSD type 'ns3:PendingStatusCodeType'
        enum ns3__PendingStatusCodeType *PendingReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__RefundInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__RefundInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__RefundInfoType, default initialized and not managed by a soap context
        virtual ns3__RefundInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__RefundInfoType); }
      public:
        /// Constructor with initializations
        ns3__RefundInfoType() : RefundStatus(), PendingReason(), soap() { }
        virtual ~ns3__RefundInfoType() { }
        /// Friend allocator used by soap_new_ns3__RefundInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__RefundInfoType * SOAP_FMAC2 soap_instantiate_ns3__RefundInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1279 */
#ifndef SOAP_TYPE_ns3__CoupledBucketsType
#define SOAP_TYPE_ns3__CoupledBucketsType (381)
/* complex XSD type 'ns3:CoupledBucketsType': */
class SOAP_CMAC ns3__CoupledBucketsType {
      public:
        /// Optional element 'ns3:CoupleType' of XSD type 'ns3:CoupleType'
        enum ns3__CoupleType *CoupleType;
        /// Optional element 'ns3:CoupledPaymentRequestID' of XSD type 'xsd:string'
        std::string *CoupledPaymentRequestID;
        /// Sequence of 2 to 10 elements 'ns3:PaymentRequestID' of XSD type 'xsd:string'
        std::vector<std::string> PaymentRequestID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CoupledBucketsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CoupledBucketsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CoupledBucketsType, default initialized and not managed by a soap context
        virtual ns3__CoupledBucketsType *soap_alloc(void) const { return SOAP_NEW(ns3__CoupledBucketsType); }
      public:
        /// Constructor with initializations
        ns3__CoupledBucketsType() : CoupleType(), CoupledPaymentRequestID(), PaymentRequestID(), soap() { }
        virtual ~ns3__CoupledBucketsType() { }
        /// Friend allocator used by soap_new_ns3__CoupledBucketsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CoupledBucketsType * SOAP_FMAC2 soap_instantiate_ns3__CoupledBucketsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1282 */
#ifndef SOAP_TYPE_ns3__CoupledPaymentInfoType
#define SOAP_TYPE_ns3__CoupledPaymentInfoType (382)
/* complex XSD type 'ns3:CoupledPaymentInfoType': */
class SOAP_CMAC ns3__CoupledPaymentInfoType {
      public:
        /// Optional element 'ns3:CoupledPaymentRequestID' of XSD type 'xsd:string'
        std::string *CoupledPaymentRequestID;
        /// Required element 'ns3:CoupledPaymentID' of XSD type 'xsd:string'
        std::string CoupledPaymentID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CoupledPaymentInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CoupledPaymentInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CoupledPaymentInfoType, default initialized and not managed by a soap context
        virtual ns3__CoupledPaymentInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__CoupledPaymentInfoType); }
      public:
        /// Constructor with initializations
        ns3__CoupledPaymentInfoType() : CoupledPaymentRequestID(), CoupledPaymentID(), soap() { }
        virtual ~ns3__CoupledPaymentInfoType() { }
        /// Friend allocator used by soap_new_ns3__CoupledPaymentInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__CoupledPaymentInfoType * SOAP_FMAC2 soap_instantiate_ns3__CoupledPaymentInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1285 */
#ifndef SOAP_TYPE_ns3__TupleType
#define SOAP_TYPE_ns3__TupleType (383)
/* complex XSD type 'ns3:TupleType': */
class SOAP_CMAC ns3__TupleType {
      public:
        /// Required element 'ns3:Key' of XSD type 'xsd:string'
        std::string Key;
        /// Required element 'ns3:Value' of XSD type 'xsd:string'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TupleType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TupleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TupleType, default initialized and not managed by a soap context
        virtual ns3__TupleType *soap_alloc(void) const { return SOAP_NEW(ns3__TupleType); }
      public:
        /// Constructor with initializations
        ns3__TupleType() : Key(), Value(), soap() { }
        virtual ~ns3__TupleType() { }
        /// Friend allocator used by soap_new_ns3__TupleType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TupleType * SOAP_FMAC2 soap_instantiate_ns3__TupleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1288 */
#ifndef SOAP_TYPE_ns3__MerchantDataType
#define SOAP_TYPE_ns3__MerchantDataType (384)
/* complex XSD type 'ns3:MerchantDataType': */
class SOAP_CMAC ns3__MerchantDataType {
      public:
        /// Sequence of 0 to 16 elements 'ns3:MerchantDataTuple' of XSD type 'ns3:TupleType'
        std::vector<ns3__TupleType *> MerchantDataTuple;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MerchantDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MerchantDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MerchantDataType, default initialized and not managed by a soap context
        virtual ns3__MerchantDataType *soap_alloc(void) const { return SOAP_NEW(ns3__MerchantDataType); }
      public:
        /// Constructor with initializations
        ns3__MerchantDataType() : MerchantDataTuple(), soap() { }
        virtual ~ns3__MerchantDataType() { }
        /// Friend allocator used by soap_new_ns3__MerchantDataType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MerchantDataType * SOAP_FMAC2 soap_instantiate_ns3__MerchantDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1291 */
#ifndef SOAP_TYPE_ns3__WalletItemsType
#define SOAP_TYPE_ns3__WalletItemsType (385)
/* complex XSD type 'ns3:WalletItemsType': */
class SOAP_CMAC ns3__WalletItemsType {
      public:
        /// Optional element 'ns3:Type' of XSD type 'ns3:WalletItemType'
        enum ns3__WalletItemType *Type;
        /// Optional element 'ns3:Id' of XSD type 'xsd:string'
        std::string *Id;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__WalletItemsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__WalletItemsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__WalletItemsType, default initialized and not managed by a soap context
        virtual ns3__WalletItemsType *soap_alloc(void) const { return SOAP_NEW(ns3__WalletItemsType); }
      public:
        /// Constructor with initializations
        ns3__WalletItemsType() : Type(), Id(), Description(), soap() { }
        virtual ~ns3__WalletItemsType() { }
        /// Friend allocator used by soap_new_ns3__WalletItemsType(struct soap*, int)
        friend SOAP_FMAC1 ns3__WalletItemsType * SOAP_FMAC2 soap_instantiate_ns3__WalletItemsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1294 */
#ifndef SOAP_TYPE_ns3__DiscountInfoType
#define SOAP_TYPE_ns3__DiscountInfoType (386)
/* complex XSD type 'ns3:DiscountInfoType': */
class SOAP_CMAC ns3__DiscountInfoType {
      public:
        /// Optional element 'ns3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:RedeemedOfferType' of XSD type 'ns3:RedeemedOfferType'
        enum ns3__RedeemedOfferType *RedeemedOfferType;
        /// Optional element 'ns3:RedeemedOfferId' of XSD type 'xsd:string'
        std::string *RedeemedOfferId;
        /// Optional element 'ns3:PointsAccrued' of XSD type 'xsd:decimal'
        std::string *PointsAccrued;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__DiscountInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__DiscountInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__DiscountInfoType, default initialized and not managed by a soap context
        virtual ns3__DiscountInfoType *soap_alloc(void) const { return SOAP_NEW(ns3__DiscountInfoType); }
      public:
        /// Constructor with initializations
        ns3__DiscountInfoType() : Name(), Description(), Amount(), RedeemedOfferType(), RedeemedOfferId(), PointsAccrued(), soap() { }
        virtual ~ns3__DiscountInfoType() { }
        /// Friend allocator used by soap_new_ns3__DiscountInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns3__DiscountInfoType * SOAP_FMAC2 soap_instantiate_ns3__DiscountInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1297 */
#ifndef SOAP_TYPE_ns4__EnhancedCheckoutDataType
#define SOAP_TYPE_ns4__EnhancedCheckoutDataType (387)
/* complex XSD type 'ns4:EnhancedCheckoutDataType': */
class SOAP_CMAC ns4__EnhancedCheckoutDataType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedCheckoutDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedCheckoutDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedCheckoutDataType, default initialized and not managed by a soap context
        virtual ns4__EnhancedCheckoutDataType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedCheckoutDataType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedCheckoutDataType() : soap() { }
        virtual ~ns4__EnhancedCheckoutDataType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedCheckoutDataType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedCheckoutDataType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedCheckoutDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1300 */
#ifndef SOAP_TYPE_ns4__EnhancedPaymentDataType
#define SOAP_TYPE_ns4__EnhancedPaymentDataType (388)
/* complex XSD type 'ns4:EnhancedPaymentDataType': */
class SOAP_CMAC ns4__EnhancedPaymentDataType {
      public:
        /// Optional element 'ns3:AirlineItinerary' of XSD type 'ns3:AirlineItineraryType'
        ns3__AirlineItineraryType *ns3__AirlineItinerary;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedPaymentDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedPaymentDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedPaymentDataType, default initialized and not managed by a soap context
        virtual ns4__EnhancedPaymentDataType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedPaymentDataType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedPaymentDataType() : ns3__AirlineItinerary(), soap() { }
        virtual ~ns4__EnhancedPaymentDataType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedPaymentDataType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedPaymentDataType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedPaymentDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1303 */
#ifndef SOAP_TYPE_ns4__EnhancedPaymentInfoType
#define SOAP_TYPE_ns4__EnhancedPaymentInfoType (389)
/* complex XSD type 'ns4:EnhancedPaymentInfoType': */
class SOAP_CMAC ns4__EnhancedPaymentInfoType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedPaymentInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedPaymentInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedPaymentInfoType, default initialized and not managed by a soap context
        virtual ns4__EnhancedPaymentInfoType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedPaymentInfoType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedPaymentInfoType() : soap() { }
        virtual ~ns4__EnhancedPaymentInfoType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedPaymentInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedPaymentInfoType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedPaymentInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1306 */
#ifndef SOAP_TYPE_ns4__EnhancedItemDataType
#define SOAP_TYPE_ns4__EnhancedItemDataType (390)
/* complex XSD type 'ns4:EnhancedItemDataType': */
class SOAP_CMAC ns4__EnhancedItemDataType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedItemDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedItemDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedItemDataType, default initialized and not managed by a soap context
        virtual ns4__EnhancedItemDataType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedItemDataType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedItemDataType() : soap() { }
        virtual ~ns4__EnhancedItemDataType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedItemDataType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedItemDataType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedItemDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1309 */
#ifndef SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType (391)
/* complex XSD type 'ns4:EnhancedInitiateRecoupRequestDetailsType': */
class SOAP_CMAC ns4__EnhancedInitiateRecoupRequestDetailsType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedInitiateRecoupRequestDetailsType, default initialized and not managed by a soap context
        virtual ns4__EnhancedInitiateRecoupRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedInitiateRecoupRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedInitiateRecoupRequestDetailsType() : soap() { }
        virtual ~ns4__EnhancedInitiateRecoupRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedInitiateRecoupRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedInitiateRecoupRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedInitiateRecoupRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1312 */
#ifndef SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType (392)
/* complex XSD type 'ns4:EnhancedCompleteRecoupRequestDetailsType': */
class SOAP_CMAC ns4__EnhancedCompleteRecoupRequestDetailsType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedCompleteRecoupRequestDetailsType, default initialized and not managed by a soap context
        virtual ns4__EnhancedCompleteRecoupRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedCompleteRecoupRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedCompleteRecoupRequestDetailsType() : soap() { }
        virtual ~ns4__EnhancedCompleteRecoupRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedCompleteRecoupRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedCompleteRecoupRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedCompleteRecoupRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1315 */
#ifndef SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType
#define SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType (393)
/* complex XSD type 'ns4:EnhancedCompleteRecoupResponseDetailsType': */
class SOAP_CMAC ns4__EnhancedCompleteRecoupResponseDetailsType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedCompleteRecoupResponseDetailsType, default initialized and not managed by a soap context
        virtual ns4__EnhancedCompleteRecoupResponseDetailsType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedCompleteRecoupResponseDetailsType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedCompleteRecoupResponseDetailsType() : soap() { }
        virtual ~ns4__EnhancedCompleteRecoupResponseDetailsType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedCompleteRecoupResponseDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedCompleteRecoupResponseDetailsType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedCompleteRecoupResponseDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1318 */
#ifndef SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType (394)
/* complex XSD type 'ns4:EnhancedCancelRecoupRequestDetailsType': */
class SOAP_CMAC ns4__EnhancedCancelRecoupRequestDetailsType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedCancelRecoupRequestDetailsType, default initialized and not managed by a soap context
        virtual ns4__EnhancedCancelRecoupRequestDetailsType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedCancelRecoupRequestDetailsType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedCancelRecoupRequestDetailsType() : soap() { }
        virtual ~ns4__EnhancedCancelRecoupRequestDetailsType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedCancelRecoupRequestDetailsType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedCancelRecoupRequestDetailsType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedCancelRecoupRequestDetailsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:1321 */
#ifndef SOAP_TYPE_ns4__EnhancedPayerInfoType
#define SOAP_TYPE_ns4__EnhancedPayerInfoType (395)
/* complex XSD type 'ns4:EnhancedPayerInfoType': */
class SOAP_CMAC ns4__EnhancedPayerInfoType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__EnhancedPayerInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__EnhancedPayerInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__EnhancedPayerInfoType, default initialized and not managed by a soap context
        virtual ns4__EnhancedPayerInfoType *soap_alloc(void) const { return SOAP_NEW(ns4__EnhancedPayerInfoType); }
      public:
        /// Constructor with initializations
        ns4__EnhancedPayerInfoType() : soap() { }
        virtual ~ns4__EnhancedPayerInfoType() { }
        /// Friend allocator used by soap_new_ns4__EnhancedPayerInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns4__EnhancedPayerInfoType * SOAP_FMAC2 soap_instantiate_ns4__EnhancedPayerInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:193 */
#ifndef SOAP_TYPE_ns1__BMCreateButtonRequestType
#define SOAP_TYPE_ns1__BMCreateButtonRequestType (19)
/* Type ns1__BMCreateButtonRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMCreateButtonRequestType': */
class SOAP_CMAC ns1__BMCreateButtonRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:ButtonType' of XSD type 'ns3:ButtonTypeType'
        enum ns3__ButtonTypeType *ButtonType;
        /// Optional element 'ns1:ButtonCode' of XSD type 'ns3:ButtonCodeType'
        enum ns3__ButtonCodeType *ButtonCode;
        /// Optional element 'ns1:ButtonSubType' of XSD type 'ns3:ButtonSubTypeType'
        enum ns3__ButtonSubTypeType *ButtonSubType;
        /// Sequence of 0 to 1000 elements 'ns1:ButtonVar' of XSD type 'xsd:string'
        std::vector<std::string> ButtonVar;
        /// Sequence of 0 to 5 elements 'ns1:OptionDetails' of XSD type 'ns1:OptionDetailsType'
        std::vector<ns1__OptionDetailsType *> OptionDetails;
        /// Sequence of 0 to 2 elements 'ns1:TextBox' of XSD type 'xsd:string'
        std::vector<std::string> TextBox;
        /// Optional element 'ns1:ButtonImage' of XSD type 'ns3:ButtonImageType'
        enum ns3__ButtonImageType *ButtonImage;
        /// Optional element 'ns1:ButtonImageURL' of XSD type 'xsd:string'
        std::string *ButtonImageURL;
        /// Optional element 'ns1:BuyNowText' of XSD type 'ns3:BuyNowTextType'
        enum ns3__BuyNowTextType *BuyNowText;
        /// Optional element 'ns1:SubscribeText' of XSD type 'ns3:SubscribeTextType'
        enum ns3__SubscribeTextType *SubscribeText;
        /// Optional element 'ns1:ButtonCountry' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *ButtonCountry;
        /// Optional element 'ns1:ButtonLanguage' of XSD type 'xsd:string'
        std::string *ButtonLanguage;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMCreateButtonRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMCreateButtonRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMCreateButtonRequestType, default initialized and not managed by a soap context
        virtual ns1__BMCreateButtonRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMCreateButtonRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMCreateButtonRequestType() : ButtonType(), ButtonCode(), ButtonSubType(), ButtonVar(), OptionDetails(), TextBox(), ButtonImage(), ButtonImageURL(), BuyNowText(), SubscribeText(), ButtonCountry(), ButtonLanguage() { }
        virtual ~ns1__BMCreateButtonRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMCreateButtonRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMCreateButtonRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMCreateButtonRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:196 */
#ifndef SOAP_TYPE_ns1__BMCreateButtonResponseType
#define SOAP_TYPE_ns1__BMCreateButtonResponseType (20)
/* Type ns1__BMCreateButtonResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMCreateButtonResponseType': */
class SOAP_CMAC ns1__BMCreateButtonResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Website' of XSD type 'xsd:string'
        std::string Website;
        /// Optional element 'ns1:Email' of XSD type 'xsd:string'
        std::string *Email;
        /// Optional element 'ns1:Mobile' of XSD type 'xsd:string'
        std::string *Mobile;
        /// Optional element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string *HostedButtonID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMCreateButtonResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMCreateButtonResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMCreateButtonResponseType, default initialized and not managed by a soap context
        virtual ns1__BMCreateButtonResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMCreateButtonResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMCreateButtonResponseType() : Website(), Email(), Mobile(), HostedButtonID() { }
        virtual ~ns1__BMCreateButtonResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMCreateButtonResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMCreateButtonResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMCreateButtonResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:199 */
#ifndef SOAP_TYPE_ns1__BMUpdateButtonRequestType
#define SOAP_TYPE_ns1__BMUpdateButtonRequestType (21)
/* Type ns1__BMUpdateButtonRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMUpdateButtonRequestType': */
class SOAP_CMAC ns1__BMUpdateButtonRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string HostedButtonID;
        /// Optional element 'ns1:ButtonType' of XSD type 'ns3:ButtonTypeType'
        enum ns3__ButtonTypeType *ButtonType;
        /// Optional element 'ns1:ButtonCode' of XSD type 'ns3:ButtonCodeType'
        enum ns3__ButtonCodeType *ButtonCode;
        /// Optional element 'ns1:ButtonSubType' of XSD type 'ns3:ButtonSubTypeType'
        enum ns3__ButtonSubTypeType *ButtonSubType;
        /// Sequence of 0 to 1000 elements 'ns1:ButtonVar' of XSD type 'xsd:string'
        std::vector<std::string> ButtonVar;
        /// Sequence of 0 to 5 elements 'ns1:OptionDetails' of XSD type 'ns1:OptionDetailsType'
        std::vector<ns1__OptionDetailsType *> OptionDetails;
        /// Sequence of 0 to 2 elements 'ns1:TextBox' of XSD type 'xsd:string'
        std::vector<std::string> TextBox;
        /// Optional element 'ns1:ButtonImage' of XSD type 'ns3:ButtonImageType'
        enum ns3__ButtonImageType *ButtonImage;
        /// Optional element 'ns1:ButtonImageURL' of XSD type 'xsd:string'
        std::string *ButtonImageURL;
        /// Optional element 'ns1:BuyNowText' of XSD type 'ns3:BuyNowTextType'
        enum ns3__BuyNowTextType *BuyNowText;
        /// Optional element 'ns1:SubscribeText' of XSD type 'ns3:SubscribeTextType'
        enum ns3__SubscribeTextType *SubscribeText;
        /// Optional element 'ns1:ButtonCountry' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *ButtonCountry;
        /// Optional element 'ns1:ButtonLanguage' of XSD type 'xsd:string'
        std::string *ButtonLanguage;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMUpdateButtonRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMUpdateButtonRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMUpdateButtonRequestType, default initialized and not managed by a soap context
        virtual ns1__BMUpdateButtonRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMUpdateButtonRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMUpdateButtonRequestType() : HostedButtonID(), ButtonType(), ButtonCode(), ButtonSubType(), ButtonVar(), OptionDetails(), TextBox(), ButtonImage(), ButtonImageURL(), BuyNowText(), SubscribeText(), ButtonCountry(), ButtonLanguage() { }
        virtual ~ns1__BMUpdateButtonRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMUpdateButtonRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMUpdateButtonRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMUpdateButtonRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:202 */
#ifndef SOAP_TYPE_ns1__BMUpdateButtonResponseType
#define SOAP_TYPE_ns1__BMUpdateButtonResponseType (22)
/* Type ns1__BMUpdateButtonResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMUpdateButtonResponseType': */
class SOAP_CMAC ns1__BMUpdateButtonResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Website' of XSD type 'xsd:string'
        std::string Website;
        /// Optional element 'ns1:Email' of XSD type 'xsd:string'
        std::string *Email;
        /// Optional element 'ns1:Mobile' of XSD type 'xsd:string'
        std::string *Mobile;
        /// Optional element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string *HostedButtonID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMUpdateButtonResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMUpdateButtonResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMUpdateButtonResponseType, default initialized and not managed by a soap context
        virtual ns1__BMUpdateButtonResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMUpdateButtonResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMUpdateButtonResponseType() : Website(), Email(), Mobile(), HostedButtonID() { }
        virtual ~ns1__BMUpdateButtonResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMUpdateButtonResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMUpdateButtonResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMUpdateButtonResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:205 */
#ifndef SOAP_TYPE_ns1__BMManageButtonStatusRequestType
#define SOAP_TYPE_ns1__BMManageButtonStatusRequestType (23)
/* Type ns1__BMManageButtonStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMManageButtonStatusRequestType': */
class SOAP_CMAC ns1__BMManageButtonStatusRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string *HostedButtonID;
        /// Optional element 'ns1:ButtonStatus' of XSD type 'ns3:ButtonStatusType'
        enum ns3__ButtonStatusType *ButtonStatus;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMManageButtonStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMManageButtonStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMManageButtonStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__BMManageButtonStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMManageButtonStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMManageButtonStatusRequestType() : HostedButtonID(), ButtonStatus() { }
        virtual ~ns1__BMManageButtonStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMManageButtonStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMManageButtonStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMManageButtonStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:208 */
#ifndef SOAP_TYPE_ns1__BMManageButtonStatusResponseType
#define SOAP_TYPE_ns1__BMManageButtonStatusResponseType (24)
/* Type ns1__BMManageButtonStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMManageButtonStatusResponseType': */
class SOAP_CMAC ns1__BMManageButtonStatusResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMManageButtonStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMManageButtonStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMManageButtonStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__BMManageButtonStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMManageButtonStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMManageButtonStatusResponseType() { }
        virtual ~ns1__BMManageButtonStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMManageButtonStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMManageButtonStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMManageButtonStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:211 */
#ifndef SOAP_TYPE_ns1__BMGetButtonDetailsRequestType
#define SOAP_TYPE_ns1__BMGetButtonDetailsRequestType (25)
/* Type ns1__BMGetButtonDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMGetButtonDetailsRequestType': */
class SOAP_CMAC ns1__BMGetButtonDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string HostedButtonID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMGetButtonDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMGetButtonDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMGetButtonDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__BMGetButtonDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMGetButtonDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMGetButtonDetailsRequestType() : HostedButtonID() { }
        virtual ~ns1__BMGetButtonDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMGetButtonDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMGetButtonDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMGetButtonDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:214 */
#ifndef SOAP_TYPE_ns1__BMGetButtonDetailsResponseType
#define SOAP_TYPE_ns1__BMGetButtonDetailsResponseType (26)
/* Type ns1__BMGetButtonDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMGetButtonDetailsResponseType': */
class SOAP_CMAC ns1__BMGetButtonDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:Website' of XSD type 'xsd:string'
        std::string *Website;
        /// Optional element 'ns1:Email' of XSD type 'xsd:string'
        std::string *Email;
        /// Optional element 'ns1:Mobile' of XSD type 'xsd:string'
        std::string *Mobile;
        /// Optional element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string *HostedButtonID;
        /// Optional element 'ns1:ButtonType' of XSD type 'ns3:ButtonTypeType'
        enum ns3__ButtonTypeType *ButtonType;
        /// Optional element 'ns1:ButtonCode' of XSD type 'ns3:ButtonCodeType'
        enum ns3__ButtonCodeType *ButtonCode;
        /// Optional element 'ns1:ButtonSubType' of XSD type 'ns3:ButtonSubTypeType'
        enum ns3__ButtonSubTypeType *ButtonSubType;
        /// Sequence of 0 to 1000 elements 'ns1:ButtonVar' of XSD type 'xsd:string'
        std::vector<std::string> ButtonVar;
        /// Sequence of 0 to 5 elements 'ns1:OptionDetails' of XSD type 'ns1:OptionDetailsType'
        std::vector<ns1__OptionDetailsType *> OptionDetails;
        /// Sequence of 0 to 2 elements 'ns1:TextBox' of XSD type 'xsd:string'
        std::vector<std::string> TextBox;
        /// Optional element 'ns1:ButtonImage' of XSD type 'ns3:ButtonImageType'
        enum ns3__ButtonImageType *ButtonImage;
        /// Optional element 'ns1:ButtonImageURL' of XSD type 'xsd:string'
        std::string *ButtonImageURL;
        /// Optional element 'ns1:BuyNowText' of XSD type 'ns3:BuyNowTextType'
        enum ns3__BuyNowTextType *BuyNowText;
        /// Optional element 'ns1:SubscribeText' of XSD type 'ns3:SubscribeTextType'
        enum ns3__SubscribeTextType *SubscribeText;
        /// Optional element 'ns1:ButtonCountry' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *ButtonCountry;
        /// Optional element 'ns1:ButtonLanguage' of XSD type 'xsd:string'
        std::string *ButtonLanguage;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMGetButtonDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMGetButtonDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMGetButtonDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__BMGetButtonDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMGetButtonDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMGetButtonDetailsResponseType() : Website(), Email(), Mobile(), HostedButtonID(), ButtonType(), ButtonCode(), ButtonSubType(), ButtonVar(), OptionDetails(), TextBox(), ButtonImage(), ButtonImageURL(), BuyNowText(), SubscribeText(), ButtonCountry(), ButtonLanguage() { }
        virtual ~ns1__BMGetButtonDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMGetButtonDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMGetButtonDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMGetButtonDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:217 */
#ifndef SOAP_TYPE_ns1__BMSetInventoryRequestType
#define SOAP_TYPE_ns1__BMSetInventoryRequestType (27)
/* Type ns1__BMSetInventoryRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMSetInventoryRequestType': */
class SOAP_CMAC ns1__BMSetInventoryRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string HostedButtonID;
        /// Required element 'ns1:TrackInv' of XSD type 'xsd:string'
        std::string TrackInv;
        /// Required element 'ns1:TrackPnl' of XSD type 'xsd:string'
        std::string TrackPnl;
        /// Optional element 'ns3:ItemTrackingDetails' of XSD type 'ns3:ItemTrackingDetailsType'
        ns3__ItemTrackingDetailsType *ns3__ItemTrackingDetails;
        /// Optional element 'ns1:OptionIndex' of XSD type 'xsd:string'
        std::string *OptionIndex;
        /// Sequence of 0 to 10 elements 'ns3:OptionTrackingDetails' of XSD type 'ns3:OptionTrackingDetailsType'
        std::vector<ns3__OptionTrackingDetailsType *> ns3__OptionTrackingDetails;
        /// Optional element 'ns1:SoldoutURL' of XSD type 'xsd:string'
        std::string *SoldoutURL;
        /// Optional element 'ns1:ReuseDigitalDownloadKeys' of XSD type 'xsd:string'
        std::string *ReuseDigitalDownloadKeys;
        /// Optional element 'ns1:AppendDigitalDownloadKeys' of XSD type 'xsd:string'
        std::string *AppendDigitalDownloadKeys;
        /// Sequence of 0 to 1000 elements 'ns1:DigitalDownloadKeys' of XSD type 'xsd:string'
        std::vector<std::string> DigitalDownloadKeys;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMSetInventoryRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMSetInventoryRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMSetInventoryRequestType, default initialized and not managed by a soap context
        virtual ns1__BMSetInventoryRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMSetInventoryRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMSetInventoryRequestType() : HostedButtonID(), TrackInv(), TrackPnl(), ns3__ItemTrackingDetails(), OptionIndex(), ns3__OptionTrackingDetails(), SoldoutURL(), ReuseDigitalDownloadKeys(), AppendDigitalDownloadKeys(), DigitalDownloadKeys() { }
        virtual ~ns1__BMSetInventoryRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMSetInventoryRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMSetInventoryRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMSetInventoryRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:220 */
#ifndef SOAP_TYPE_ns1__BMSetInventoryResponseType
#define SOAP_TYPE_ns1__BMSetInventoryResponseType (28)
/* Type ns1__BMSetInventoryResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMSetInventoryResponseType': */
class SOAP_CMAC ns1__BMSetInventoryResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMSetInventoryResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMSetInventoryResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMSetInventoryResponseType, default initialized and not managed by a soap context
        virtual ns1__BMSetInventoryResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMSetInventoryResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMSetInventoryResponseType() { }
        virtual ~ns1__BMSetInventoryResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMSetInventoryResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMSetInventoryResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMSetInventoryResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:223 */
#ifndef SOAP_TYPE_ns1__BMGetInventoryRequestType
#define SOAP_TYPE_ns1__BMGetInventoryRequestType (29)
/* Type ns1__BMGetInventoryRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMGetInventoryRequestType': */
class SOAP_CMAC ns1__BMGetInventoryRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string HostedButtonID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMGetInventoryRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMGetInventoryRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMGetInventoryRequestType, default initialized and not managed by a soap context
        virtual ns1__BMGetInventoryRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMGetInventoryRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMGetInventoryRequestType() : HostedButtonID() { }
        virtual ~ns1__BMGetInventoryRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMGetInventoryRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMGetInventoryRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMGetInventoryRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:226 */
#ifndef SOAP_TYPE_ns1__BMGetInventoryResponseType
#define SOAP_TYPE_ns1__BMGetInventoryResponseType (30)
/* Type ns1__BMGetInventoryResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMGetInventoryResponseType': */
class SOAP_CMAC ns1__BMGetInventoryResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:HostedButtonID' of XSD type 'xsd:string'
        std::string HostedButtonID;
        /// Required element 'ns1:TrackInv' of XSD type 'xsd:string'
        std::string TrackInv;
        /// Required element 'ns1:TrackPnl' of XSD type 'xsd:string'
        std::string TrackPnl;
        /// Optional element 'ns3:ItemTrackingDetails' of XSD type 'ns3:ItemTrackingDetailsType'
        ns3__ItemTrackingDetailsType *ns3__ItemTrackingDetails;
        /// Optional element 'ns1:OptionIndex' of XSD type 'xsd:string'
        std::string *OptionIndex;
        /// Optional element 'ns1:OptionName' of XSD type 'xsd:string'
        std::string *OptionName;
        /// Sequence of 0 to 10 elements 'ns3:OptionTrackingDetails' of XSD type 'ns3:OptionTrackingDetailsType'
        std::vector<ns3__OptionTrackingDetailsType *> ns3__OptionTrackingDetails;
        /// Optional element 'ns1:SoldoutURL' of XSD type 'xsd:string'
        std::string *SoldoutURL;
        /// Sequence of 0 to 1000 elements 'ns1:DigitalDownloadKeys' of XSD type 'xsd:string'
        std::vector<std::string> DigitalDownloadKeys;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMGetInventoryResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMGetInventoryResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMGetInventoryResponseType, default initialized and not managed by a soap context
        virtual ns1__BMGetInventoryResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMGetInventoryResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMGetInventoryResponseType() : HostedButtonID(), TrackInv(), TrackPnl(), ns3__ItemTrackingDetails(), OptionIndex(), OptionName(), ns3__OptionTrackingDetails(), SoldoutURL(), DigitalDownloadKeys() { }
        virtual ~ns1__BMGetInventoryResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMGetInventoryResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMGetInventoryResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMGetInventoryResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:229 */
#ifndef SOAP_TYPE_ns1__BMButtonSearchRequestType
#define SOAP_TYPE_ns1__BMButtonSearchRequestType (31)
/* Type ns1__BMButtonSearchRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMButtonSearchRequestType': */
class SOAP_CMAC ns1__BMButtonSearchRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:StartDate' of XSD type 'xsd:dateTime'
        time_t *StartDate;
        /// Optional element 'ns1:EndDate' of XSD type 'xsd:dateTime'
        time_t *EndDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMButtonSearchRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMButtonSearchRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMButtonSearchRequestType, default initialized and not managed by a soap context
        virtual ns1__BMButtonSearchRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BMButtonSearchRequestType); }
      public:
        /// Constructor with initializations
        ns1__BMButtonSearchRequestType() : StartDate(), EndDate() { }
        virtual ~ns1__BMButtonSearchRequestType() { }
        /// Friend allocator used by soap_new_ns1__BMButtonSearchRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMButtonSearchRequestType * SOAP_FMAC2 soap_instantiate_ns1__BMButtonSearchRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:232 */
#ifndef SOAP_TYPE_ns1__BMButtonSearchResponseType
#define SOAP_TYPE_ns1__BMButtonSearchResponseType (32)
/* Type ns1__BMButtonSearchResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BMButtonSearchResponseType': */
class SOAP_CMAC ns1__BMButtonSearchResponseType : public ns3__AbstractResponseType {
      public:
        /// Sequence of 0 to 100 elements 'ns3:ButtonSearchResult' of XSD type 'ns3:ButtonSearchResultType'
        std::vector<ns3__ButtonSearchResultType *> ns3__ButtonSearchResult;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BMButtonSearchResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BMButtonSearchResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BMButtonSearchResponseType, default initialized and not managed by a soap context
        virtual ns1__BMButtonSearchResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BMButtonSearchResponseType); }
      public:
        /// Constructor with initializations
        ns1__BMButtonSearchResponseType() : ns3__ButtonSearchResult() { }
        virtual ~ns1__BMButtonSearchResponseType() { }
        /// Friend allocator used by soap_new_ns1__BMButtonSearchResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BMButtonSearchResponseType * SOAP_FMAC2 soap_instantiate_ns1__BMButtonSearchResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:235 */
#ifndef SOAP_TYPE_ns1__RefundTransactionRequestType
#define SOAP_TYPE_ns1__RefundTransactionRequestType (33)
/* Type ns1__RefundTransactionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RefundTransactionRequestType': */
class SOAP_CMAC ns1__RefundTransactionRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Optional element 'ns1:PayerID' of XSD type 'ns3:UserIDType'
        std::string *PayerID;
        /// Optional element 'ns1:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns1:RefundType' of XSD type 'ns3:RefundType'
        enum ns3__RefundType *RefundType;
        /// Optional element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns1:ShippingAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingAmount;
        /// Optional element 'ns1:TaxAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxAmount;
        /// Optional element 'ns1:Memo' of XSD type 'xsd:string'
        std::string *Memo;
        /// Optional element 'ns1:RetryUntil' of XSD type 'xsd:dateTime'
        time_t *RetryUntil;
        /// Optional element 'ns1:RefundSource' of XSD type 'ns3:RefundSourceCodeType'
        enum ns3__RefundSourceCodeType *RefundSource;
        /// Optional element 'ns1:RefundAdvice' of XSD type 'xsd:boolean'
        bool *RefundAdvice;
        /// Optional element 'ns3:MerchantStoreDetails' of XSD type 'ns3:MerchantStoreDetailsType'
        ns3__MerchantStoreDetailsType *ns3__MerchantStoreDetails;
        /// Optional element 'ns3:RefundItemDetails' of XSD type 'ns3:InvoiceItemType'
        std::vector<ns3__InvoiceItemType *> ns3__RefundItemDetails;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns3:MerchantData' of XSD type 'ns3:MerchantDataType'
        ns3__MerchantDataType *ns3__MerchantData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RefundTransactionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RefundTransactionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RefundTransactionRequestType, default initialized and not managed by a soap context
        virtual ns1__RefundTransactionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__RefundTransactionRequestType); }
      public:
        /// Constructor with initializations
        ns1__RefundTransactionRequestType() : TransactionID(), PayerID(), InvoiceID(), RefundType(), Amount(), ShippingAmount(), TaxAmount(), Memo(), RetryUntil(), RefundSource(), RefundAdvice(), ns3__MerchantStoreDetails(), ns3__RefundItemDetails(), MsgSubID(), ns3__MerchantData() { }
        virtual ~ns1__RefundTransactionRequestType() { }
        /// Friend allocator used by soap_new_ns1__RefundTransactionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RefundTransactionRequestType * SOAP_FMAC2 soap_instantiate_ns1__RefundTransactionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:238 */
#ifndef SOAP_TYPE_ns1__RefundTransactionResponseType
#define SOAP_TYPE_ns1__RefundTransactionResponseType (34)
/* Type ns1__RefundTransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RefundTransactionResponseType': */
class SOAP_CMAC ns1__RefundTransactionResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:RefundTransactionID' of XSD type 'ns3:TransactionId'
        std::string *RefundTransactionID;
        /// Optional element 'ns1:NetRefundAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *NetRefundAmount;
        /// Optional element 'ns1:FeeRefundAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *FeeRefundAmount;
        /// Optional element 'ns1:GrossRefundAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *GrossRefundAmount;
        /// Optional element 'ns1:TotalRefundedAmount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TotalRefundedAmount;
        /// Optional element 'ns3:RefundInfo' of XSD type 'ns3:RefundInfoType'
        ns3__RefundInfoType *ns3__RefundInfo;
        /// Optional element 'ns1:ReceiptData' of XSD type 'xsd:string'
        std::string *ReceiptData;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RefundTransactionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RefundTransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RefundTransactionResponseType, default initialized and not managed by a soap context
        virtual ns1__RefundTransactionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__RefundTransactionResponseType); }
      public:
        /// Constructor with initializations
        ns1__RefundTransactionResponseType() : RefundTransactionID(), NetRefundAmount(), FeeRefundAmount(), GrossRefundAmount(), TotalRefundedAmount(), ns3__RefundInfo(), ReceiptData(), MsgSubID() { }
        virtual ~ns1__RefundTransactionResponseType() { }
        /// Friend allocator used by soap_new_ns1__RefundTransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RefundTransactionResponseType * SOAP_FMAC2 soap_instantiate_ns1__RefundTransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:241 */
#ifndef SOAP_TYPE_ns1__InitiateRecoupRequestType
#define SOAP_TYPE_ns1__InitiateRecoupRequestType (35)
/* Type ns1__InitiateRecoupRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InitiateRecoupRequestType': */
class SOAP_CMAC ns1__InitiateRecoupRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns4:EnhancedInitiateRecoupRequestDetails' of XSD type 'ns4:EnhancedInitiateRecoupRequestDetailsType'
        ns4__EnhancedInitiateRecoupRequestDetailsType *ns4__EnhancedInitiateRecoupRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InitiateRecoupRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InitiateRecoupRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InitiateRecoupRequestType, default initialized and not managed by a soap context
        virtual ns1__InitiateRecoupRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__InitiateRecoupRequestType); }
      public:
        /// Constructor with initializations
        ns1__InitiateRecoupRequestType() : ns4__EnhancedInitiateRecoupRequestDetails() { }
        virtual ~ns1__InitiateRecoupRequestType() { }
        /// Friend allocator used by soap_new_ns1__InitiateRecoupRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InitiateRecoupRequestType * SOAP_FMAC2 soap_instantiate_ns1__InitiateRecoupRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:244 */
#ifndef SOAP_TYPE_ns1__InitiateRecoupResponseType
#define SOAP_TYPE_ns1__InitiateRecoupResponseType (36)
/* Type ns1__InitiateRecoupResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InitiateRecoupResponseType': */
class SOAP_CMAC ns1__InitiateRecoupResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__InitiateRecoupResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InitiateRecoupResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InitiateRecoupResponseType, default initialized and not managed by a soap context
        virtual ns1__InitiateRecoupResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__InitiateRecoupResponseType); }
      public:
        /// Constructor with initializations
        ns1__InitiateRecoupResponseType() { }
        virtual ~ns1__InitiateRecoupResponseType() { }
        /// Friend allocator used by soap_new_ns1__InitiateRecoupResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InitiateRecoupResponseType * SOAP_FMAC2 soap_instantiate_ns1__InitiateRecoupResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:247 */
#ifndef SOAP_TYPE_ns1__CompleteRecoupRequestType
#define SOAP_TYPE_ns1__CompleteRecoupRequestType (37)
/* Type ns1__CompleteRecoupRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CompleteRecoupRequestType': */
class SOAP_CMAC ns1__CompleteRecoupRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns4:EnhancedCompleteRecoupRequestDetails' of XSD type 'ns4:EnhancedCompleteRecoupRequestDetailsType'
        ns4__EnhancedCompleteRecoupRequestDetailsType *ns4__EnhancedCompleteRecoupRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CompleteRecoupRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CompleteRecoupRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CompleteRecoupRequestType, default initialized and not managed by a soap context
        virtual ns1__CompleteRecoupRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__CompleteRecoupRequestType); }
      public:
        /// Constructor with initializations
        ns1__CompleteRecoupRequestType() : ns4__EnhancedCompleteRecoupRequestDetails() { }
        virtual ~ns1__CompleteRecoupRequestType() { }
        /// Friend allocator used by soap_new_ns1__CompleteRecoupRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CompleteRecoupRequestType * SOAP_FMAC2 soap_instantiate_ns1__CompleteRecoupRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:250 */
#ifndef SOAP_TYPE_ns1__CompleteRecoupResponseType
#define SOAP_TYPE_ns1__CompleteRecoupResponseType (38)
/* Type ns1__CompleteRecoupResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CompleteRecoupResponseType': */
class SOAP_CMAC ns1__CompleteRecoupResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns4:EnhancedCompleteRecoupResponseDetails' of XSD type 'ns4:EnhancedCompleteRecoupResponseDetailsType'
        ns4__EnhancedCompleteRecoupResponseDetailsType *ns4__EnhancedCompleteRecoupResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CompleteRecoupResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CompleteRecoupResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CompleteRecoupResponseType, default initialized and not managed by a soap context
        virtual ns1__CompleteRecoupResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__CompleteRecoupResponseType); }
      public:
        /// Constructor with initializations
        ns1__CompleteRecoupResponseType() : ns4__EnhancedCompleteRecoupResponseDetails() { }
        virtual ~ns1__CompleteRecoupResponseType() { }
        /// Friend allocator used by soap_new_ns1__CompleteRecoupResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CompleteRecoupResponseType * SOAP_FMAC2 soap_instantiate_ns1__CompleteRecoupResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:253 */
#ifndef SOAP_TYPE_ns1__CancelRecoupRequestType
#define SOAP_TYPE_ns1__CancelRecoupRequestType (39)
/* Type ns1__CancelRecoupRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CancelRecoupRequestType': */
class SOAP_CMAC ns1__CancelRecoupRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns4:EnhancedCancelRecoupRequestDetails' of XSD type 'ns4:EnhancedCancelRecoupRequestDetailsType'
        ns4__EnhancedCancelRecoupRequestDetailsType *ns4__EnhancedCancelRecoupRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CancelRecoupRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CancelRecoupRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CancelRecoupRequestType, default initialized and not managed by a soap context
        virtual ns1__CancelRecoupRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__CancelRecoupRequestType); }
      public:
        /// Constructor with initializations
        ns1__CancelRecoupRequestType() : ns4__EnhancedCancelRecoupRequestDetails() { }
        virtual ~ns1__CancelRecoupRequestType() { }
        /// Friend allocator used by soap_new_ns1__CancelRecoupRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CancelRecoupRequestType * SOAP_FMAC2 soap_instantiate_ns1__CancelRecoupRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:256 */
#ifndef SOAP_TYPE_ns1__CancelRecoupResponseType
#define SOAP_TYPE_ns1__CancelRecoupResponseType (40)
/* Type ns1__CancelRecoupResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CancelRecoupResponseType': */
class SOAP_CMAC ns1__CancelRecoupResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__CancelRecoupResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CancelRecoupResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CancelRecoupResponseType, default initialized and not managed by a soap context
        virtual ns1__CancelRecoupResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__CancelRecoupResponseType); }
      public:
        /// Constructor with initializations
        ns1__CancelRecoupResponseType() { }
        virtual ~ns1__CancelRecoupResponseType() { }
        /// Friend allocator used by soap_new_ns1__CancelRecoupResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CancelRecoupResponseType * SOAP_FMAC2 soap_instantiate_ns1__CancelRecoupResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:259 */
#ifndef SOAP_TYPE_ns1__GetTransactionDetailsRequestType
#define SOAP_TYPE_ns1__GetTransactionDetailsRequestType (41)
/* Type ns1__GetTransactionDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetTransactionDetailsRequestType': */
class SOAP_CMAC ns1__GetTransactionDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string TransactionID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetTransactionDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetTransactionDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetTransactionDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetTransactionDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetTransactionDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetTransactionDetailsRequestType() : TransactionID() { }
        virtual ~ns1__GetTransactionDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetTransactionDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetTransactionDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetTransactionDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:262 */
#ifndef SOAP_TYPE_ns1__GetTransactionDetailsResponseType
#define SOAP_TYPE_ns1__GetTransactionDetailsResponseType (42)
/* Type ns1__GetTransactionDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetTransactionDetailsResponseType': */
class SOAP_CMAC ns1__GetTransactionDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:PaymentTransactionDetails' of XSD type 'ns3:PaymentTransactionType'
        ns3__PaymentTransactionType *ns3__PaymentTransactionDetails;
        /// Required element 'ns3:ThreeDSecureDetails' of XSD type 'ns3:ThreeDSecureInfoType'
        ns3__ThreeDSecureInfoType *ns3__ThreeDSecureDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetTransactionDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetTransactionDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetTransactionDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetTransactionDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetTransactionDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetTransactionDetailsResponseType() : ns3__PaymentTransactionDetails(), ns3__ThreeDSecureDetails() { }
        virtual ~ns1__GetTransactionDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetTransactionDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetTransactionDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetTransactionDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:265 */
#ifndef SOAP_TYPE_ns1__BillUserRequestType
#define SOAP_TYPE_ns1__BillUserRequestType (43)
/* Type ns1__BillUserRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BillUserRequestType': */
class SOAP_CMAC ns1__BillUserRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:MerchantPullPaymentDetails' of XSD type 'ns3:MerchantPullPaymentType'
        ns3__MerchantPullPaymentType *ns3__MerchantPullPaymentDetails;
        /// Optional element 'ns1:ReturnFMFDetails' of XSD type 'xsd:int'
        int *ReturnFMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BillUserRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BillUserRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BillUserRequestType, default initialized and not managed by a soap context
        virtual ns1__BillUserRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BillUserRequestType); }
      public:
        /// Constructor with initializations
        ns1__BillUserRequestType() : ns3__MerchantPullPaymentDetails(), ReturnFMFDetails() { }
        virtual ~ns1__BillUserRequestType() { }
        /// Friend allocator used by soap_new_ns1__BillUserRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BillUserRequestType * SOAP_FMAC2 soap_instantiate_ns1__BillUserRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:268 */
#ifndef SOAP_TYPE_ns1__BillUserResponseType
#define SOAP_TYPE_ns1__BillUserResponseType (44)
/* Type ns1__BillUserResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BillUserResponseType': */
class SOAP_CMAC ns1__BillUserResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:BillUserResponseDetails' of XSD type 'ns3:MerchantPullPaymentResponseType'
        ns3__MerchantPullPaymentResponseType *ns3__BillUserResponseDetails;
        /// Optional element 'ns1:FMFDetails' of XSD type 'ns3:FMFDetailsType'
        ns3__FMFDetailsType *FMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BillUserResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BillUserResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BillUserResponseType, default initialized and not managed by a soap context
        virtual ns1__BillUserResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BillUserResponseType); }
      public:
        /// Constructor with initializations
        ns1__BillUserResponseType() : ns3__BillUserResponseDetails(), FMFDetails() { }
        virtual ~ns1__BillUserResponseType() { }
        /// Friend allocator used by soap_new_ns1__BillUserResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BillUserResponseType * SOAP_FMAC2 soap_instantiate_ns1__BillUserResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:271 */
#ifndef SOAP_TYPE_ns1__TransactionSearchRequestType
#define SOAP_TYPE_ns1__TransactionSearchRequestType (45)
/* Type ns1__TransactionSearchRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionSearchRequestType': */
class SOAP_CMAC ns1__TransactionSearchRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:StartDate' of XSD type 'xsd:dateTime'
        time_t StartDate;
        /// Optional element 'ns1:EndDate' of XSD type 'xsd:dateTime'
        time_t *EndDate;
        /// Optional element 'ns1:Payer' of XSD type 'ns3:EmailAddressType'
        std::string *Payer;
        /// Optional element 'ns1:Receiver' of XSD type 'ns3:EmailAddressType'
        std::string *Receiver;
        /// Optional element 'ns1:ReceiptID' of XSD type 'xsd:string'
        std::string *ReceiptID;
        /// Optional element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Optional element 'ns1:ProfileID' of XSD type 'xsd:string'
        std::string *ProfileID;
        /// Optional element 'ns1:PayerName' of XSD type 'ns3:PersonNameType'
        ns3__PersonNameType *PayerName;
        /// Optional element 'ns1:AuctionItemNumber' of XSD type 'xsd:string'
        std::string *AuctionItemNumber;
        /// Optional element 'ns1:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns1:CardNumber' of XSD type 'xsd:string'
        std::string *CardNumber;
        /// Optional element 'ns1:TransactionClass' of XSD type 'ns3:PaymentTransactionClassCodeType'
        enum ns3__PaymentTransactionClassCodeType *TransactionClass;
        /// Optional element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns1:CurrencyCode' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType *CurrencyCode;
        /// Optional element 'ns1:Status' of XSD type 'ns3:PaymentTransactionStatusCodeType'
        enum ns3__PaymentTransactionStatusCodeType *Status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionSearchRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionSearchRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionSearchRequestType, default initialized and not managed by a soap context
        virtual ns1__TransactionSearchRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionSearchRequestType); }
      public:
        /// Constructor with initializations
        ns1__TransactionSearchRequestType() : StartDate(), EndDate(), Payer(), Receiver(), ReceiptID(), TransactionID(), ProfileID(), PayerName(), AuctionItemNumber(), InvoiceID(), CardNumber(), TransactionClass(), Amount(), CurrencyCode(), Status() { }
        virtual ~ns1__TransactionSearchRequestType() { }
        /// Friend allocator used by soap_new_ns1__TransactionSearchRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionSearchRequestType * SOAP_FMAC2 soap_instantiate_ns1__TransactionSearchRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:274 */
#ifndef SOAP_TYPE_ns1__TransactionSearchResponseType
#define SOAP_TYPE_ns1__TransactionSearchResponseType (46)
/* Type ns1__TransactionSearchResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionSearchResponseType': */
class SOAP_CMAC ns1__TransactionSearchResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns3:PaymentTransactions' of XSD type 'ns3:PaymentTransactionSearchResultType'
        std::vector<ns3__PaymentTransactionSearchResultType *> ns3__PaymentTransactions;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionSearchResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionSearchResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionSearchResponseType, default initialized and not managed by a soap context
        virtual ns1__TransactionSearchResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionSearchResponseType); }
      public:
        /// Constructor with initializations
        ns1__TransactionSearchResponseType() : ns3__PaymentTransactions() { }
        virtual ~ns1__TransactionSearchResponseType() { }
        /// Friend allocator used by soap_new_ns1__TransactionSearchResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionSearchResponseType * SOAP_FMAC2 soap_instantiate_ns1__TransactionSearchResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:277 */
#ifndef SOAP_TYPE_ns1__MassPayRequestType
#define SOAP_TYPE_ns1__MassPayRequestType (47)
/* Type ns1__MassPayRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MassPayRequestType': */
class SOAP_CMAC ns1__MassPayRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:EmailSubject' of XSD type 'xsd:string'
        std::string *EmailSubject;
        /// Optional element 'ns1:ReceiverType' of XSD type 'ns3:ReceiverInfoCodeType'
        enum ns3__ReceiverInfoCodeType *ReceiverType;
        /// Optional element 'ns1:ButtonSource' of XSD type 'xsd:string'
        std::string *ButtonSource;
        /// Sequence of 1 to 250 elements 'ns1:MassPayItem' of XSD type 'ns1:MassPayRequestItemType'
        std::vector<ns1__MassPayRequestItemType *> MassPayItem;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MassPayRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MassPayRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MassPayRequestType, default initialized and not managed by a soap context
        virtual ns1__MassPayRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__MassPayRequestType); }
      public:
        /// Constructor with initializations
        ns1__MassPayRequestType() : EmailSubject(), ReceiverType(), ButtonSource(), MassPayItem() { }
        virtual ~ns1__MassPayRequestType() { }
        /// Friend allocator used by soap_new_ns1__MassPayRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MassPayRequestType * SOAP_FMAC2 soap_instantiate_ns1__MassPayRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:280 */
#ifndef SOAP_TYPE_ns1__MassPayResponseType
#define SOAP_TYPE_ns1__MassPayResponseType (48)
/* Type ns1__MassPayResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MassPayResponseType': */
class SOAP_CMAC ns1__MassPayResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__MassPayResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MassPayResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MassPayResponseType, default initialized and not managed by a soap context
        virtual ns1__MassPayResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__MassPayResponseType); }
      public:
        /// Constructor with initializations
        ns1__MassPayResponseType() { }
        virtual ~ns1__MassPayResponseType() { }
        /// Friend allocator used by soap_new_ns1__MassPayResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MassPayResponseType * SOAP_FMAC2 soap_instantiate_ns1__MassPayResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:286 */
#ifndef SOAP_TYPE_ns1__BAUpdateRequestType
#define SOAP_TYPE_ns1__BAUpdateRequestType (50)
/* Type ns1__BAUpdateRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BAUpdateRequestType': */
class SOAP_CMAC ns1__BAUpdateRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:ReferenceID' of XSD type 'xsd:string'
        std::string ReferenceID;
        /// Optional element 'ns1:BillingAgreementDescription' of XSD type 'xsd:string'
        std::string *BillingAgreementDescription;
        /// Optional element 'ns1:BillingAgreementStatus' of XSD type 'ns3:MerchantPullStatusCodeType'
        enum ns3__MerchantPullStatusCodeType *BillingAgreementStatus;
        /// Optional element 'ns1:BillingAgreementCustom' of XSD type 'xsd:string'
        std::string *BillingAgreementCustom;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BAUpdateRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BAUpdateRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BAUpdateRequestType, default initialized and not managed by a soap context
        virtual ns1__BAUpdateRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BAUpdateRequestType); }
      public:
        /// Constructor with initializations
        ns1__BAUpdateRequestType() : ReferenceID(), BillingAgreementDescription(), BillingAgreementStatus(), BillingAgreementCustom() { }
        virtual ~ns1__BAUpdateRequestType() { }
        /// Friend allocator used by soap_new_ns1__BAUpdateRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BAUpdateRequestType * SOAP_FMAC2 soap_instantiate_ns1__BAUpdateRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:289 */
#ifndef SOAP_TYPE_ns1__BAUpdateResponseType
#define SOAP_TYPE_ns1__BAUpdateResponseType (51)
/* Type ns1__BAUpdateResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BAUpdateResponseType': */
class SOAP_CMAC ns1__BAUpdateResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:BAUpdateResponseDetails' of XSD type 'ns3:BAUpdateResponseDetailsType'
        ns3__BAUpdateResponseDetailsType *ns3__BAUpdateResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BAUpdateResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BAUpdateResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BAUpdateResponseType, default initialized and not managed by a soap context
        virtual ns1__BAUpdateResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BAUpdateResponseType); }
      public:
        /// Constructor with initializations
        ns1__BAUpdateResponseType() : ns3__BAUpdateResponseDetails() { }
        virtual ~ns1__BAUpdateResponseType() { }
        /// Friend allocator used by soap_new_ns1__BAUpdateResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BAUpdateResponseType * SOAP_FMAC2 soap_instantiate_ns1__BAUpdateResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:292 */
#ifndef SOAP_TYPE_ns1__AddressVerifyRequestType
#define SOAP_TYPE_ns1__AddressVerifyRequestType (52)
/* Type ns1__AddressVerifyRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AddressVerifyRequestType': */
class SOAP_CMAC ns1__AddressVerifyRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Email' of XSD type 'ns3:EmailAddressType'
        std::string Email;
        /// Required element 'ns1:Street' of XSD type 'xsd:string'
        std::string Street;
        /// Required element 'ns1:Zip' of XSD type 'xsd:string'
        std::string Zip;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AddressVerifyRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AddressVerifyRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AddressVerifyRequestType, default initialized and not managed by a soap context
        virtual ns1__AddressVerifyRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__AddressVerifyRequestType); }
      public:
        /// Constructor with initializations
        ns1__AddressVerifyRequestType() : Email(), Street(), Zip() { }
        virtual ~ns1__AddressVerifyRequestType() { }
        /// Friend allocator used by soap_new_ns1__AddressVerifyRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AddressVerifyRequestType * SOAP_FMAC2 soap_instantiate_ns1__AddressVerifyRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:295 */
#ifndef SOAP_TYPE_ns1__AddressVerifyResponseType
#define SOAP_TYPE_ns1__AddressVerifyResponseType (53)
/* Type ns1__AddressVerifyResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AddressVerifyResponseType': */
class SOAP_CMAC ns1__AddressVerifyResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:ConfirmationCode' of XSD type 'ns3:AddressStatusCodeType'
        enum ns3__AddressStatusCodeType ConfirmationCode;
        /// Required element 'ns1:StreetMatch' of XSD type 'ns3:MatchStatusCodeType'
        enum ns3__MatchStatusCodeType StreetMatch;
        /// Optional element 'ns1:ZipMatch' of XSD type 'ns3:MatchStatusCodeType'
        enum ns3__MatchStatusCodeType *ZipMatch;
        /// Optional element 'ns1:CountryCode' of XSD type 'ns3:CountryCodeType'
        enum ns3__CountryCodeType *CountryCode;
        /// Optional element 'ns1:PayPalToken' of XSD type 'xsd:string'
        std::string *PayPalToken;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AddressVerifyResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AddressVerifyResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AddressVerifyResponseType, default initialized and not managed by a soap context
        virtual ns1__AddressVerifyResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__AddressVerifyResponseType); }
      public:
        /// Constructor with initializations
        ns1__AddressVerifyResponseType() : ConfirmationCode(), StreetMatch(), ZipMatch(), CountryCode(), PayPalToken() { }
        virtual ~ns1__AddressVerifyResponseType() { }
        /// Friend allocator used by soap_new_ns1__AddressVerifyResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AddressVerifyResponseType * SOAP_FMAC2 soap_instantiate_ns1__AddressVerifyResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:298 */
#ifndef SOAP_TYPE_ns1__EnterBoardingRequestType
#define SOAP_TYPE_ns1__EnterBoardingRequestType (54)
/* Type ns1__EnterBoardingRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EnterBoardingRequestType': */
class SOAP_CMAC ns1__EnterBoardingRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:EnterBoardingRequestDetails' of XSD type 'ns3:EnterBoardingRequestDetailsType'
        ns3__EnterBoardingRequestDetailsType *ns3__EnterBoardingRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EnterBoardingRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EnterBoardingRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EnterBoardingRequestType, default initialized and not managed by a soap context
        virtual ns1__EnterBoardingRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__EnterBoardingRequestType); }
      public:
        /// Constructor with initializations
        ns1__EnterBoardingRequestType() : ns3__EnterBoardingRequestDetails() { }
        virtual ~ns1__EnterBoardingRequestType() { }
        /// Friend allocator used by soap_new_ns1__EnterBoardingRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EnterBoardingRequestType * SOAP_FMAC2 soap_instantiate_ns1__EnterBoardingRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:301 */
#ifndef SOAP_TYPE_ns1__EnterBoardingResponseType
#define SOAP_TYPE_ns1__EnterBoardingResponseType (55)
/* Type ns1__EnterBoardingResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EnterBoardingResponseType': */
class SOAP_CMAC ns1__EnterBoardingResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EnterBoardingResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EnterBoardingResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EnterBoardingResponseType, default initialized and not managed by a soap context
        virtual ns1__EnterBoardingResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__EnterBoardingResponseType); }
      public:
        /// Constructor with initializations
        ns1__EnterBoardingResponseType() : Token() { }
        virtual ~ns1__EnterBoardingResponseType() { }
        /// Friend allocator used by soap_new_ns1__EnterBoardingResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EnterBoardingResponseType * SOAP_FMAC2 soap_instantiate_ns1__EnterBoardingResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:304 */
#ifndef SOAP_TYPE_ns1__GetBoardingDetailsRequestType
#define SOAP_TYPE_ns1__GetBoardingDetailsRequestType (56)
/* Type ns1__GetBoardingDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBoardingDetailsRequestType': */
class SOAP_CMAC ns1__GetBoardingDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBoardingDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBoardingDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBoardingDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetBoardingDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBoardingDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetBoardingDetailsRequestType() : Token() { }
        virtual ~ns1__GetBoardingDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetBoardingDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBoardingDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetBoardingDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:307 */
#ifndef SOAP_TYPE_ns1__GetBoardingDetailsResponseType
#define SOAP_TYPE_ns1__GetBoardingDetailsResponseType (57)
/* Type ns1__GetBoardingDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBoardingDetailsResponseType': */
class SOAP_CMAC ns1__GetBoardingDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetBoardingDetailsResponseDetails' of XSD type 'ns3:GetBoardingDetailsResponseDetailsType'
        ns3__GetBoardingDetailsResponseDetailsType *ns3__GetBoardingDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBoardingDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBoardingDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBoardingDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetBoardingDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBoardingDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetBoardingDetailsResponseType() : ns3__GetBoardingDetailsResponseDetails() { }
        virtual ~ns1__GetBoardingDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetBoardingDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBoardingDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetBoardingDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:310 */
#ifndef SOAP_TYPE_ns1__SetAuthFlowParamRequestType
#define SOAP_TYPE_ns1__SetAuthFlowParamRequestType (58)
/* Type ns1__SetAuthFlowParamRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetAuthFlowParamRequestType': */
class SOAP_CMAC ns1__SetAuthFlowParamRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:SetAuthFlowParamRequestDetails' of XSD type 'ns3:SetAuthFlowParamRequestDetailsType'
        ns3__SetAuthFlowParamRequestDetailsType *ns3__SetAuthFlowParamRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetAuthFlowParamRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetAuthFlowParamRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetAuthFlowParamRequestType, default initialized and not managed by a soap context
        virtual ns1__SetAuthFlowParamRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SetAuthFlowParamRequestType); }
      public:
        /// Constructor with initializations
        ns1__SetAuthFlowParamRequestType() : ns3__SetAuthFlowParamRequestDetails() { }
        virtual ~ns1__SetAuthFlowParamRequestType() { }
        /// Friend allocator used by soap_new_ns1__SetAuthFlowParamRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetAuthFlowParamRequestType * SOAP_FMAC2 soap_instantiate_ns1__SetAuthFlowParamRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:313 */
#ifndef SOAP_TYPE_ns1__SetAuthFlowParamResponseType
#define SOAP_TYPE_ns1__SetAuthFlowParamResponseType (59)
/* Type ns1__SetAuthFlowParamResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetAuthFlowParamResponseType': */
class SOAP_CMAC ns1__SetAuthFlowParamResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:AuthFlowTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetAuthFlowParamResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetAuthFlowParamResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetAuthFlowParamResponseType, default initialized and not managed by a soap context
        virtual ns1__SetAuthFlowParamResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SetAuthFlowParamResponseType); }
      public:
        /// Constructor with initializations
        ns1__SetAuthFlowParamResponseType() : Token() { }
        virtual ~ns1__SetAuthFlowParamResponseType() { }
        /// Friend allocator used by soap_new_ns1__SetAuthFlowParamResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetAuthFlowParamResponseType * SOAP_FMAC2 soap_instantiate_ns1__SetAuthFlowParamResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:316 */
#ifndef SOAP_TYPE_ns1__GetAuthDetailsRequestType
#define SOAP_TYPE_ns1__GetAuthDetailsRequestType (60)
/* Type ns1__GetAuthDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetAuthDetailsRequestType': */
class SOAP_CMAC ns1__GetAuthDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:AuthFlowTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetAuthDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetAuthDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetAuthDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetAuthDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetAuthDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetAuthDetailsRequestType() : Token() { }
        virtual ~ns1__GetAuthDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetAuthDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetAuthDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetAuthDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:319 */
#ifndef SOAP_TYPE_ns1__GetAuthDetailsResponseType
#define SOAP_TYPE_ns1__GetAuthDetailsResponseType (61)
/* Type ns1__GetAuthDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetAuthDetailsResponseType': */
class SOAP_CMAC ns1__GetAuthDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetAuthDetailsResponseDetails' of XSD type 'ns3:GetAuthDetailsResponseDetailsType'
        ns3__GetAuthDetailsResponseDetailsType *ns3__GetAuthDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetAuthDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetAuthDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetAuthDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetAuthDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetAuthDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetAuthDetailsResponseType() : ns3__GetAuthDetailsResponseDetails() { }
        virtual ~ns1__GetAuthDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetAuthDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetAuthDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetAuthDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:322 */
#ifndef SOAP_TYPE_ns1__SetAccessPermissionsRequestType
#define SOAP_TYPE_ns1__SetAccessPermissionsRequestType (62)
/* Type ns1__SetAccessPermissionsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetAccessPermissionsRequestType': */
class SOAP_CMAC ns1__SetAccessPermissionsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:SetAccessPermissionsRequestDetails' of XSD type 'ns3:SetAccessPermissionsRequestDetailsType'
        ns3__SetAccessPermissionsRequestDetailsType *ns3__SetAccessPermissionsRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetAccessPermissionsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetAccessPermissionsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetAccessPermissionsRequestType, default initialized and not managed by a soap context
        virtual ns1__SetAccessPermissionsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SetAccessPermissionsRequestType); }
      public:
        /// Constructor with initializations
        ns1__SetAccessPermissionsRequestType() : ns3__SetAccessPermissionsRequestDetails() { }
        virtual ~ns1__SetAccessPermissionsRequestType() { }
        /// Friend allocator used by soap_new_ns1__SetAccessPermissionsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetAccessPermissionsRequestType * SOAP_FMAC2 soap_instantiate_ns1__SetAccessPermissionsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:325 */
#ifndef SOAP_TYPE_ns1__SetAccessPermissionsResponseType
#define SOAP_TYPE_ns1__SetAccessPermissionsResponseType (63)
/* Type ns1__SetAccessPermissionsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetAccessPermissionsResponseType': */
class SOAP_CMAC ns1__SetAccessPermissionsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:AuthFlowTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetAccessPermissionsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetAccessPermissionsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetAccessPermissionsResponseType, default initialized and not managed by a soap context
        virtual ns1__SetAccessPermissionsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SetAccessPermissionsResponseType); }
      public:
        /// Constructor with initializations
        ns1__SetAccessPermissionsResponseType() : Token() { }
        virtual ~ns1__SetAccessPermissionsResponseType() { }
        /// Friend allocator used by soap_new_ns1__SetAccessPermissionsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetAccessPermissionsResponseType * SOAP_FMAC2 soap_instantiate_ns1__SetAccessPermissionsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:328 */
#ifndef SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType
#define SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType (64)
/* Type ns1__UpdateAccessPermissionsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateAccessPermissionsRequestType': */
class SOAP_CMAC ns1__UpdateAccessPermissionsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:PayerID' of XSD type 'ns3:UserIDType'
        std::string PayerID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateAccessPermissionsRequestType, default initialized and not managed by a soap context
        virtual ns1__UpdateAccessPermissionsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateAccessPermissionsRequestType); }
      public:
        /// Constructor with initializations
        ns1__UpdateAccessPermissionsRequestType() : PayerID() { }
        virtual ~ns1__UpdateAccessPermissionsRequestType() { }
        /// Friend allocator used by soap_new_ns1__UpdateAccessPermissionsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateAccessPermissionsRequestType * SOAP_FMAC2 soap_instantiate_ns1__UpdateAccessPermissionsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:331 */
#ifndef SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType
#define SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType (65)
/* Type ns1__UpdateAccessPermissionsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateAccessPermissionsResponseType': */
class SOAP_CMAC ns1__UpdateAccessPermissionsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Status' of XSD type 'xsd:string'
        std::string Status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateAccessPermissionsResponseType, default initialized and not managed by a soap context
        virtual ns1__UpdateAccessPermissionsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateAccessPermissionsResponseType); }
      public:
        /// Constructor with initializations
        ns1__UpdateAccessPermissionsResponseType() : Status() { }
        virtual ~ns1__UpdateAccessPermissionsResponseType() { }
        /// Friend allocator used by soap_new_ns1__UpdateAccessPermissionsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateAccessPermissionsResponseType * SOAP_FMAC2 soap_instantiate_ns1__UpdateAccessPermissionsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:334 */
#ifndef SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType
#define SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType (66)
/* Type ns1__GetAccessPermissionDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetAccessPermissionDetailsRequestType': */
class SOAP_CMAC ns1__GetAccessPermissionDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:AuthFlowTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetAccessPermissionDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetAccessPermissionDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetAccessPermissionDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetAccessPermissionDetailsRequestType() : Token() { }
        virtual ~ns1__GetAccessPermissionDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetAccessPermissionDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetAccessPermissionDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetAccessPermissionDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:337 */
#ifndef SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType
#define SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType (67)
/* Type ns1__GetAccessPermissionDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetAccessPermissionDetailsResponseType': */
class SOAP_CMAC ns1__GetAccessPermissionDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetAccessPermissionDetailsResponseDetails' of XSD type 'ns3:GetAccessPermissionDetailsResponseDetailsType'
        ns3__GetAccessPermissionDetailsResponseDetailsType *ns3__GetAccessPermissionDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetAccessPermissionDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetAccessPermissionDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetAccessPermissionDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetAccessPermissionDetailsResponseType() : ns3__GetAccessPermissionDetailsResponseDetails() { }
        virtual ~ns1__GetAccessPermissionDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetAccessPermissionDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetAccessPermissionDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetAccessPermissionDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:340 */
#ifndef SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType
#define SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType (68)
/* Type ns1__GetIncentiveEvaluationRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetIncentiveEvaluationRequestType': */
class SOAP_CMAC ns1__GetIncentiveEvaluationRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:GetIncentiveEvaluationRequestDetails' of XSD type 'ns3:GetIncentiveEvaluationRequestDetailsType'
        ns3__GetIncentiveEvaluationRequestDetailsType *ns3__GetIncentiveEvaluationRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetIncentiveEvaluationRequestType, default initialized and not managed by a soap context
        virtual ns1__GetIncentiveEvaluationRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetIncentiveEvaluationRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetIncentiveEvaluationRequestType() : ns3__GetIncentiveEvaluationRequestDetails() { }
        virtual ~ns1__GetIncentiveEvaluationRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetIncentiveEvaluationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetIncentiveEvaluationRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetIncentiveEvaluationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:343 */
#ifndef SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType
#define SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType (69)
/* Type ns1__GetIncentiveEvaluationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetIncentiveEvaluationResponseType': */
class SOAP_CMAC ns1__GetIncentiveEvaluationResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetIncentiveEvaluationResponseDetails' of XSD type 'ns3:GetIncentiveEvaluationResponseDetailsType'
        ns3__GetIncentiveEvaluationResponseDetailsType *ns3__GetIncentiveEvaluationResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetIncentiveEvaluationResponseType, default initialized and not managed by a soap context
        virtual ns1__GetIncentiveEvaluationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetIncentiveEvaluationResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetIncentiveEvaluationResponseType() : ns3__GetIncentiveEvaluationResponseDetails() { }
        virtual ~ns1__GetIncentiveEvaluationResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetIncentiveEvaluationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetIncentiveEvaluationResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetIncentiveEvaluationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:346 */
#ifndef SOAP_TYPE_ns1__SetExpressCheckoutRequestType
#define SOAP_TYPE_ns1__SetExpressCheckoutRequestType (70)
/* Type ns1__SetExpressCheckoutRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetExpressCheckoutRequestType': */
class SOAP_CMAC ns1__SetExpressCheckoutRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:SetExpressCheckoutRequestDetails' of XSD type 'ns3:SetExpressCheckoutRequestDetailsType'
        ns3__SetExpressCheckoutRequestDetailsType *ns3__SetExpressCheckoutRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetExpressCheckoutRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetExpressCheckoutRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetExpressCheckoutRequestType, default initialized and not managed by a soap context
        virtual ns1__SetExpressCheckoutRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SetExpressCheckoutRequestType); }
      public:
        /// Constructor with initializations
        ns1__SetExpressCheckoutRequestType() : ns3__SetExpressCheckoutRequestDetails() { }
        virtual ~ns1__SetExpressCheckoutRequestType() { }
        /// Friend allocator used by soap_new_ns1__SetExpressCheckoutRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetExpressCheckoutRequestType * SOAP_FMAC2 soap_instantiate_ns1__SetExpressCheckoutRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:349 */
#ifndef SOAP_TYPE_ns1__SetExpressCheckoutResponseType
#define SOAP_TYPE_ns1__SetExpressCheckoutResponseType (71)
/* Type ns1__SetExpressCheckoutResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetExpressCheckoutResponseType': */
class SOAP_CMAC ns1__SetExpressCheckoutResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string *Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetExpressCheckoutResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetExpressCheckoutResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetExpressCheckoutResponseType, default initialized and not managed by a soap context
        virtual ns1__SetExpressCheckoutResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SetExpressCheckoutResponseType); }
      public:
        /// Constructor with initializations
        ns1__SetExpressCheckoutResponseType() : Token() { }
        virtual ~ns1__SetExpressCheckoutResponseType() { }
        /// Friend allocator used by soap_new_ns1__SetExpressCheckoutResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetExpressCheckoutResponseType * SOAP_FMAC2 soap_instantiate_ns1__SetExpressCheckoutResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:352 */
#ifndef SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType
#define SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType (72)
/* Type ns1__ExecuteCheckoutOperationsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ExecuteCheckoutOperationsRequestType': */
class SOAP_CMAC ns1__ExecuteCheckoutOperationsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:ExecuteCheckoutOperationsRequestDetails' of XSD type 'ns3:ExecuteCheckoutOperationsRequestDetailsType'
        ns3__ExecuteCheckoutOperationsRequestDetailsType *ns3__ExecuteCheckoutOperationsRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExecuteCheckoutOperationsRequestType, default initialized and not managed by a soap context
        virtual ns1__ExecuteCheckoutOperationsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ExecuteCheckoutOperationsRequestType); }
      public:
        /// Constructor with initializations
        ns1__ExecuteCheckoutOperationsRequestType() : ns3__ExecuteCheckoutOperationsRequestDetails() { }
        virtual ~ns1__ExecuteCheckoutOperationsRequestType() { }
        /// Friend allocator used by soap_new_ns1__ExecuteCheckoutOperationsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExecuteCheckoutOperationsRequestType * SOAP_FMAC2 soap_instantiate_ns1__ExecuteCheckoutOperationsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:355 */
#ifndef SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType
#define SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType (73)
/* Type ns1__ExecuteCheckoutOperationsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ExecuteCheckoutOperationsResponseType': */
class SOAP_CMAC ns1__ExecuteCheckoutOperationsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:ExecuteCheckoutOperationsResponseDetails' of XSD type 'ns3:ExecuteCheckoutOperationsResponseDetailsType'
        ns3__ExecuteCheckoutOperationsResponseDetailsType *ns3__ExecuteCheckoutOperationsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExecuteCheckoutOperationsResponseType, default initialized and not managed by a soap context
        virtual ns1__ExecuteCheckoutOperationsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ExecuteCheckoutOperationsResponseType); }
      public:
        /// Constructor with initializations
        ns1__ExecuteCheckoutOperationsResponseType() : ns3__ExecuteCheckoutOperationsResponseDetails() { }
        virtual ~ns1__ExecuteCheckoutOperationsResponseType() { }
        /// Friend allocator used by soap_new_ns1__ExecuteCheckoutOperationsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExecuteCheckoutOperationsResponseType * SOAP_FMAC2 soap_instantiate_ns1__ExecuteCheckoutOperationsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:358 */
#ifndef SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType
#define SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType (74)
/* Type ns1__GetExpressCheckoutDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetExpressCheckoutDetailsRequestType': */
class SOAP_CMAC ns1__GetExpressCheckoutDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetExpressCheckoutDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetExpressCheckoutDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetExpressCheckoutDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetExpressCheckoutDetailsRequestType() : Token() { }
        virtual ~ns1__GetExpressCheckoutDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetExpressCheckoutDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetExpressCheckoutDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetExpressCheckoutDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:361 */
#ifndef SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType
#define SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType (75)
/* Type ns1__GetExpressCheckoutDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetExpressCheckoutDetailsResponseType': */
class SOAP_CMAC ns1__GetExpressCheckoutDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetExpressCheckoutDetailsResponseDetails' of XSD type 'ns3:GetExpressCheckoutDetailsResponseDetailsType'
        ns3__GetExpressCheckoutDetailsResponseDetailsType *ns3__GetExpressCheckoutDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetExpressCheckoutDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetExpressCheckoutDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetExpressCheckoutDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetExpressCheckoutDetailsResponseType() : ns3__GetExpressCheckoutDetailsResponseDetails() { }
        virtual ~ns1__GetExpressCheckoutDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetExpressCheckoutDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetExpressCheckoutDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetExpressCheckoutDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:364 */
#ifndef SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType (76)
/* Type ns1__DoExpressCheckoutPaymentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoExpressCheckoutPaymentRequestType': */
class SOAP_CMAC ns1__DoExpressCheckoutPaymentRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:DoExpressCheckoutPaymentRequestDetails' of XSD type 'ns3:DoExpressCheckoutPaymentRequestDetailsType'
        ns3__DoExpressCheckoutPaymentRequestDetailsType *ns3__DoExpressCheckoutPaymentRequestDetails;
        /// Optional element 'ns1:ReturnFMFDetails' of XSD type 'xsd:int'
        int *ReturnFMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoExpressCheckoutPaymentRequestType, default initialized and not managed by a soap context
        virtual ns1__DoExpressCheckoutPaymentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoExpressCheckoutPaymentRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoExpressCheckoutPaymentRequestType() : ns3__DoExpressCheckoutPaymentRequestDetails(), ReturnFMFDetails() { }
        virtual ~ns1__DoExpressCheckoutPaymentRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoExpressCheckoutPaymentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoExpressCheckoutPaymentRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoExpressCheckoutPaymentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:367 */
#ifndef SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType (77)
/* Type ns1__DoExpressCheckoutPaymentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoExpressCheckoutPaymentResponseType': */
class SOAP_CMAC ns1__DoExpressCheckoutPaymentResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:DoExpressCheckoutPaymentResponseDetails' of XSD type 'ns3:DoExpressCheckoutPaymentResponseDetailsType'
        ns3__DoExpressCheckoutPaymentResponseDetailsType *ns3__DoExpressCheckoutPaymentResponseDetails;
        /// Optional element 'ns1:FMFDetails' of XSD type 'ns3:FMFDetailsType'
        ns3__FMFDetailsType *FMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoExpressCheckoutPaymentResponseType, default initialized and not managed by a soap context
        virtual ns1__DoExpressCheckoutPaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoExpressCheckoutPaymentResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoExpressCheckoutPaymentResponseType() : ns3__DoExpressCheckoutPaymentResponseDetails(), FMFDetails() { }
        virtual ~ns1__DoExpressCheckoutPaymentResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoExpressCheckoutPaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoExpressCheckoutPaymentResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoExpressCheckoutPaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:376 */
#ifndef SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType
#define SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType (80)
/* Type ns1__ManagePendingTransactionStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ManagePendingTransactionStatusRequestType': */
class SOAP_CMAC ns1__ManagePendingTransactionStatusRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string TransactionID;
        /// Required element 'ns1:Action' of XSD type 'ns3:FMFPendingTransactionActionType'
        enum ns3__FMFPendingTransactionActionType Action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ManagePendingTransactionStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__ManagePendingTransactionStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ManagePendingTransactionStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__ManagePendingTransactionStatusRequestType() : TransactionID(), Action() { }
        virtual ~ns1__ManagePendingTransactionStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__ManagePendingTransactionStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ManagePendingTransactionStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__ManagePendingTransactionStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:379 */
#ifndef SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType
#define SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType (81)
/* Type ns1__ManagePendingTransactionStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ManagePendingTransactionStatusResponseType': */
class SOAP_CMAC ns1__ManagePendingTransactionStatusResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Optional element 'ns1:Status' of XSD type 'xsd:string'
        std::string *Status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ManagePendingTransactionStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__ManagePendingTransactionStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ManagePendingTransactionStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__ManagePendingTransactionStatusResponseType() : TransactionID(), Status() { }
        virtual ~ns1__ManagePendingTransactionStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__ManagePendingTransactionStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ManagePendingTransactionStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__ManagePendingTransactionStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:382 */
#ifndef SOAP_TYPE_ns1__DoDirectPaymentRequestType
#define SOAP_TYPE_ns1__DoDirectPaymentRequestType (82)
/* Type ns1__DoDirectPaymentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoDirectPaymentRequestType': */
class SOAP_CMAC ns1__DoDirectPaymentRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:DoDirectPaymentRequestDetails' of XSD type 'ns3:DoDirectPaymentRequestDetailsType'
        ns3__DoDirectPaymentRequestDetailsType *ns3__DoDirectPaymentRequestDetails;
        /// Optional element 'ns1:ReturnFMFDetails' of XSD type 'xsd:int'
        int *ReturnFMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoDirectPaymentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoDirectPaymentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoDirectPaymentRequestType, default initialized and not managed by a soap context
        virtual ns1__DoDirectPaymentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoDirectPaymentRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoDirectPaymentRequestType() : ns3__DoDirectPaymentRequestDetails(), ReturnFMFDetails() { }
        virtual ~ns1__DoDirectPaymentRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoDirectPaymentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoDirectPaymentRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoDirectPaymentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:385 */
#ifndef SOAP_TYPE_ns1__DoDirectPaymentResponseType
#define SOAP_TYPE_ns1__DoDirectPaymentResponseType (83)
/* Type ns1__DoDirectPaymentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoDirectPaymentResponseType': */
class SOAP_CMAC ns1__DoDirectPaymentResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Required element 'ns1:AVSCode' of XSD type 'xsd:string'
        std::string AVSCode;
        /// Required element 'ns1:CVV2Code' of XSD type 'xsd:string'
        std::string CVV2Code;
        /// Optional element 'ns1:TransactionID' of XSD type 'ns3:TransactionId'
        std::string *TransactionID;
        /// Optional element 'ns1:TransactionPendingReason' of XSD type 'xsd:string'
        std::string *TransactionPendingReason;
        /// Optional element 'ns1:PendingReason' of XSD type 'ns3:PendingStatusCodeType'
        enum ns3__PendingStatusCodeType *PendingReason;
        /// Optional element 'ns1:PaymentStatus' of XSD type 'ns3:PaymentStatusCodeType'
        enum ns3__PaymentStatusCodeType *PaymentStatus;
        /// Optional element 'ns1:FMFDetails' of XSD type 'ns3:FMFDetailsType'
        ns3__FMFDetailsType *FMFDetails;
        /// Optional element 'ns1:ThreeDSecureResponse' of XSD type 'ns3:ThreeDSecureResponseType'
        ns3__ThreeDSecureResponseType *ThreeDSecureResponse;
        /// Optional element 'ns1:PaymentAdviceCode' of XSD type 'xsd:string'
        std::string *PaymentAdviceCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoDirectPaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoDirectPaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoDirectPaymentResponseType, default initialized and not managed by a soap context
        virtual ns1__DoDirectPaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoDirectPaymentResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoDirectPaymentResponseType() : Amount(), AVSCode(), CVV2Code(), TransactionID(), TransactionPendingReason(), PendingReason(), PaymentStatus(), FMFDetails(), ThreeDSecureResponse(), PaymentAdviceCode() { }
        virtual ~ns1__DoDirectPaymentResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoDirectPaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoDirectPaymentResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoDirectPaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:388 */
#ifndef SOAP_TYPE_ns1__DoCancelRequestType
#define SOAP_TYPE_ns1__DoCancelRequestType (84)
/* Type ns1__DoCancelRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoCancelRequestType': */
class SOAP_CMAC ns1__DoCancelRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:CancelMsgSubID' of XSD type 'xsd:string'
        std::string CancelMsgSubID;
        /// Required element 'ns1:APIType' of XSD type 'ns3:APIType'
        enum ns3__APIType APIType;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoCancelRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoCancelRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoCancelRequestType, default initialized and not managed by a soap context
        virtual ns1__DoCancelRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoCancelRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoCancelRequestType() : CancelMsgSubID(), APIType(), MsgSubID() { }
        virtual ~ns1__DoCancelRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoCancelRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoCancelRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoCancelRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:391 */
#ifndef SOAP_TYPE_ns1__DoCancelResponseType
#define SOAP_TYPE_ns1__DoCancelResponseType (85)
/* Type ns1__DoCancelResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoCancelResponseType': */
class SOAP_CMAC ns1__DoCancelResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoCancelResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoCancelResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoCancelResponseType, default initialized and not managed by a soap context
        virtual ns1__DoCancelResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoCancelResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoCancelResponseType() : MsgSubID() { }
        virtual ~ns1__DoCancelResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoCancelResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoCancelResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoCancelResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:394 */
#ifndef SOAP_TYPE_ns1__DoCaptureRequestType
#define SOAP_TYPE_ns1__DoCaptureRequestType (86)
/* Type ns1__DoCaptureRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoCaptureRequestType': */
class SOAP_CMAC ns1__DoCaptureRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:AuthorizationID' of XSD type 'ns3:AuthorizationId'
        std::string AuthorizationID;
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Required element 'ns1:CompleteType' of XSD type 'ns3:CompleteCodeType'
        enum ns3__CompleteCodeType CompleteType;
        /// Optional element 'ns1:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns1:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns3:EnhancedData' of XSD type 'ns3:EnhancedDataType'
        ns3__EnhancedDataType *ns3__EnhancedData;
        /// Optional element 'ns1:Descriptor' of XSD type 'xsd:string'
        std::string *Descriptor;
        /// Optional element 'ns3:MerchantStoreDetails' of XSD type 'ns3:MerchantStoreDetailsType'
        ns3__MerchantStoreDetailsType *ns3__MerchantStoreDetails;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns3:MerchantData' of XSD type 'ns3:MerchantDataType'
        ns3__MerchantDataType *ns3__MerchantData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoCaptureRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoCaptureRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoCaptureRequestType, default initialized and not managed by a soap context
        virtual ns1__DoCaptureRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoCaptureRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoCaptureRequestType() : AuthorizationID(), Amount(), CompleteType(), Note(), InvoiceID(), ns3__EnhancedData(), Descriptor(), ns3__MerchantStoreDetails(), MsgSubID(), ns3__MerchantData() { }
        virtual ~ns1__DoCaptureRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoCaptureRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoCaptureRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoCaptureRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:397 */
#ifndef SOAP_TYPE_ns1__DoCaptureResponseType
#define SOAP_TYPE_ns1__DoCaptureResponseType (87)
/* Type ns1__DoCaptureResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoCaptureResponseType': */
class SOAP_CMAC ns1__DoCaptureResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:DoCaptureResponseDetails' of XSD type 'ns3:DoCaptureResponseDetailsType'
        ns3__DoCaptureResponseDetailsType *ns3__DoCaptureResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoCaptureResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoCaptureResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoCaptureResponseType, default initialized and not managed by a soap context
        virtual ns1__DoCaptureResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoCaptureResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoCaptureResponseType() : ns3__DoCaptureResponseDetails() { }
        virtual ~ns1__DoCaptureResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoCaptureResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoCaptureResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoCaptureResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:400 */
#ifndef SOAP_TYPE_ns1__DoReauthorizationRequestType
#define SOAP_TYPE_ns1__DoReauthorizationRequestType (88)
/* Type ns1__DoReauthorizationRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoReauthorizationRequestType': */
class SOAP_CMAC ns1__DoReauthorizationRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:AuthorizationID' of XSD type 'xsd:string'
        std::string AuthorizationID;
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoReauthorizationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoReauthorizationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoReauthorizationRequestType, default initialized and not managed by a soap context
        virtual ns1__DoReauthorizationRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoReauthorizationRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoReauthorizationRequestType() : AuthorizationID(), Amount(), MsgSubID() { }
        virtual ~ns1__DoReauthorizationRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoReauthorizationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoReauthorizationRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoReauthorizationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:403 */
#ifndef SOAP_TYPE_ns1__DoReauthorizationResponseType
#define SOAP_TYPE_ns1__DoReauthorizationResponseType (89)
/* Type ns1__DoReauthorizationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoReauthorizationResponseType': */
class SOAP_CMAC ns1__DoReauthorizationResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:AuthorizationID' of XSD type 'xsd:string'
        std::string AuthorizationID;
        /// Optional element 'ns3:AuthorizationInfo' of XSD type 'ns3:AuthorizationInfoType'
        ns3__AuthorizationInfoType *ns3__AuthorizationInfo;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoReauthorizationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoReauthorizationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoReauthorizationResponseType, default initialized and not managed by a soap context
        virtual ns1__DoReauthorizationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoReauthorizationResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoReauthorizationResponseType() : AuthorizationID(), ns3__AuthorizationInfo(), MsgSubID() { }
        virtual ~ns1__DoReauthorizationResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoReauthorizationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoReauthorizationResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoReauthorizationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:406 */
#ifndef SOAP_TYPE_ns1__DoVoidRequestType
#define SOAP_TYPE_ns1__DoVoidRequestType (90)
/* Type ns1__DoVoidRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoVoidRequestType': */
class SOAP_CMAC ns1__DoVoidRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:AuthorizationID' of XSD type 'xsd:string'
        std::string AuthorizationID;
        /// Optional element 'ns1:Note' of XSD type 'xsd:string'
        std::string *Note;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoVoidRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoVoidRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoVoidRequestType, default initialized and not managed by a soap context
        virtual ns1__DoVoidRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoVoidRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoVoidRequestType() : AuthorizationID(), Note(), MsgSubID() { }
        virtual ~ns1__DoVoidRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoVoidRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoVoidRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoVoidRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:409 */
#ifndef SOAP_TYPE_ns1__DoVoidResponseType
#define SOAP_TYPE_ns1__DoVoidResponseType (91)
/* Type ns1__DoVoidResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoVoidResponseType': */
class SOAP_CMAC ns1__DoVoidResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:AuthorizationID' of XSD type 'xsd:string'
        std::string *AuthorizationID;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoVoidResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoVoidResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoVoidResponseType, default initialized and not managed by a soap context
        virtual ns1__DoVoidResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoVoidResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoVoidResponseType() : AuthorizationID(), MsgSubID() { }
        virtual ~ns1__DoVoidResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoVoidResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoVoidResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoVoidResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:412 */
#ifndef SOAP_TYPE_ns1__DoAuthorizationRequestType
#define SOAP_TYPE_ns1__DoAuthorizationRequestType (92)
/* Type ns1__DoAuthorizationRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoAuthorizationRequestType': */
class SOAP_CMAC ns1__DoAuthorizationRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:TransactionID' of XSD type 'xsd:string'
        std::string TransactionID;
        /// Optional element 'ns1:TransactionEntity' of XSD type 'ns3:TransactionEntityType'
        enum ns3__TransactionEntityType *TransactionEntity;
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:ShipToAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *ns3__ShipToAddress;
        /// Optional element 'ns3:PaymentDetailsItem' of XSD type 'ns3:PaymentDetailsItemType'
        std::vector<ns3__PaymentDetailsItemType *> ns3__PaymentDetailsItem;
        /// Optional element 'ns1:ItemTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ItemTotal;
        /// Optional element 'ns1:ShippingTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingTotal;
        /// Optional element 'ns1:HandlingTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *HandlingTotal;
        /// Optional element 'ns1:TaxTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *TaxTotal;
        /// Optional element 'ns1:InsuranceTotal' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *InsuranceTotal;
        /// Optional element 'ns1:ShippingDiscount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *ShippingDiscount;
        /// Optional element 'ns1:OrderDescription' of XSD type 'xsd:string'
        std::string *OrderDescription;
        /// Optional element 'ns1:Custom' of XSD type 'xsd:string'
        std::string *Custom;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
        /// Optional element 'ns1:IPAddress' of XSD type 'xsd:string'
        std::string *IPAddress;
        /// Optional element 'ns1:ShipToStore' of XSD type 'xsd:string'
        std::string *ShipToStore;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoAuthorizationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoAuthorizationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoAuthorizationRequestType, default initialized and not managed by a soap context
        virtual ns1__DoAuthorizationRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoAuthorizationRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoAuthorizationRequestType() : TransactionID(), TransactionEntity(), Amount(), ns3__ShipToAddress(), ns3__PaymentDetailsItem(), ItemTotal(), ShippingTotal(), HandlingTotal(), TaxTotal(), InsuranceTotal(), ShippingDiscount(), OrderDescription(), Custom(), MsgSubID(), IPAddress(), ShipToStore() { }
        virtual ~ns1__DoAuthorizationRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoAuthorizationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoAuthorizationRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoAuthorizationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:415 */
#ifndef SOAP_TYPE_ns1__DoAuthorizationResponseType
#define SOAP_TYPE_ns1__DoAuthorizationResponseType (93)
/* Type ns1__DoAuthorizationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoAuthorizationResponseType': */
class SOAP_CMAC ns1__DoAuthorizationResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:TransactionID' of XSD type 'xsd:string'
        std::string *TransactionID;
        /// Optional element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns3:AuthorizationInfo' of XSD type 'ns3:AuthorizationInfoType'
        ns3__AuthorizationInfoType *ns3__AuthorizationInfo;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoAuthorizationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoAuthorizationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoAuthorizationResponseType, default initialized and not managed by a soap context
        virtual ns1__DoAuthorizationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoAuthorizationResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoAuthorizationResponseType() : TransactionID(), Amount(), ns3__AuthorizationInfo(), MsgSubID() { }
        virtual ~ns1__DoAuthorizationResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoAuthorizationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoAuthorizationResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoAuthorizationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:418 */
#ifndef SOAP_TYPE_ns1__UpdateAuthorizationRequestType
#define SOAP_TYPE_ns1__UpdateAuthorizationRequestType (94)
/* Type ns1__UpdateAuthorizationRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateAuthorizationRequestType': */
class SOAP_CMAC ns1__UpdateAuthorizationRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:TransactionID' of XSD type 'xsd:string'
        std::string TransactionID;
        /// Optional element 'ns3:ShipToAddress' of XSD type 'ns3:AddressType'
        ns3__AddressType *ns3__ShipToAddress;
        /// Optional element 'ns1:IPAddress' of XSD type 'xsd:string'
        std::string *IPAddress;
        /// Optional element 'ns1:ShipToStore' of XSD type 'xsd:string'
        std::string *ShipToStore;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateAuthorizationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateAuthorizationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateAuthorizationRequestType, default initialized and not managed by a soap context
        virtual ns1__UpdateAuthorizationRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateAuthorizationRequestType); }
      public:
        /// Constructor with initializations
        ns1__UpdateAuthorizationRequestType() : TransactionID(), ns3__ShipToAddress(), IPAddress(), ShipToStore() { }
        virtual ~ns1__UpdateAuthorizationRequestType() { }
        /// Friend allocator used by soap_new_ns1__UpdateAuthorizationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateAuthorizationRequestType * SOAP_FMAC2 soap_instantiate_ns1__UpdateAuthorizationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:421 */
#ifndef SOAP_TYPE_ns1__UpdateAuthorizationResponseType
#define SOAP_TYPE_ns1__UpdateAuthorizationResponseType (95)
/* Type ns1__UpdateAuthorizationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateAuthorizationResponseType': */
class SOAP_CMAC ns1__UpdateAuthorizationResponseType : public ns3__AbstractResponseType {
      public:
        /// Optional element 'ns1:TransactionID' of XSD type 'xsd:string'
        std::string *TransactionID;
        /// Optional element 'ns3:AuthorizationInfo' of XSD type 'ns3:AuthorizationInfoType'
        ns3__AuthorizationInfoType *ns3__AuthorizationInfo;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateAuthorizationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateAuthorizationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateAuthorizationResponseType, default initialized and not managed by a soap context
        virtual ns1__UpdateAuthorizationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateAuthorizationResponseType); }
      public:
        /// Constructor with initializations
        ns1__UpdateAuthorizationResponseType() : TransactionID(), ns3__AuthorizationInfo() { }
        virtual ~ns1__UpdateAuthorizationResponseType() { }
        /// Friend allocator used by soap_new_ns1__UpdateAuthorizationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateAuthorizationResponseType * SOAP_FMAC2 soap_instantiate_ns1__UpdateAuthorizationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:424 */
#ifndef SOAP_TYPE_ns1__DoUATPAuthorizationRequestType
#define SOAP_TYPE_ns1__DoUATPAuthorizationRequestType (96)
/* Type ns1__DoUATPAuthorizationRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoUATPAuthorizationRequestType': */
class SOAP_CMAC ns1__DoUATPAuthorizationRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:UATPDetails' of XSD type 'ns3:UATPDetailsType'
        ns3__UATPDetailsType *ns3__UATPDetails;
        /// Optional element 'ns1:TransactionEntity' of XSD type 'ns3:TransactionEntityType'
        enum ns3__TransactionEntityType *TransactionEntity;
        /// Required element 'ns1:Amount' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Amount;
        /// Optional element 'ns1:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoUATPAuthorizationRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoUATPAuthorizationRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoUATPAuthorizationRequestType, default initialized and not managed by a soap context
        virtual ns1__DoUATPAuthorizationRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoUATPAuthorizationRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoUATPAuthorizationRequestType() : ns3__UATPDetails(), TransactionEntity(), Amount(), InvoiceID(), MsgSubID() { }
        virtual ~ns1__DoUATPAuthorizationRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoUATPAuthorizationRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoUATPAuthorizationRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoUATPAuthorizationRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:430 */
#ifndef SOAP_TYPE_ns1__CreateMobilePaymentRequestType
#define SOAP_TYPE_ns1__CreateMobilePaymentRequestType (98)
/* Type ns1__CreateMobilePaymentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateMobilePaymentRequestType': */
class SOAP_CMAC ns1__CreateMobilePaymentRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:CreateMobilePaymentRequestDetails' of XSD type 'ns3:CreateMobilePaymentRequestDetailsType'
        ns3__CreateMobilePaymentRequestDetailsType *ns3__CreateMobilePaymentRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateMobilePaymentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateMobilePaymentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateMobilePaymentRequestType, default initialized and not managed by a soap context
        virtual ns1__CreateMobilePaymentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateMobilePaymentRequestType); }
      public:
        /// Constructor with initializations
        ns1__CreateMobilePaymentRequestType() : ns3__CreateMobilePaymentRequestDetails() { }
        virtual ~ns1__CreateMobilePaymentRequestType() { }
        /// Friend allocator used by soap_new_ns1__CreateMobilePaymentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateMobilePaymentRequestType * SOAP_FMAC2 soap_instantiate_ns1__CreateMobilePaymentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:433 */
#ifndef SOAP_TYPE_ns1__CreateMobilePaymentResponseType
#define SOAP_TYPE_ns1__CreateMobilePaymentResponseType (99)
/* Type ns1__CreateMobilePaymentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateMobilePaymentResponseType': */
class SOAP_CMAC ns1__CreateMobilePaymentResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateMobilePaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateMobilePaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateMobilePaymentResponseType, default initialized and not managed by a soap context
        virtual ns1__CreateMobilePaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateMobilePaymentResponseType); }
      public:
        /// Constructor with initializations
        ns1__CreateMobilePaymentResponseType() { }
        virtual ~ns1__CreateMobilePaymentResponseType() { }
        /// Friend allocator used by soap_new_ns1__CreateMobilePaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateMobilePaymentResponseType * SOAP_FMAC2 soap_instantiate_ns1__CreateMobilePaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:436 */
#ifndef SOAP_TYPE_ns1__GetMobileStatusRequestType
#define SOAP_TYPE_ns1__GetMobileStatusRequestType (100)
/* Type ns1__GetMobileStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetMobileStatusRequestType': */
class SOAP_CMAC ns1__GetMobileStatusRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:GetMobileStatusRequestDetails' of XSD type 'ns3:GetMobileStatusRequestDetailsType'
        ns3__GetMobileStatusRequestDetailsType *ns3__GetMobileStatusRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetMobileStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetMobileStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetMobileStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__GetMobileStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetMobileStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetMobileStatusRequestType() : ns3__GetMobileStatusRequestDetails() { }
        virtual ~ns1__GetMobileStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetMobileStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetMobileStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetMobileStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:439 */
#ifndef SOAP_TYPE_ns1__GetMobileStatusResponseType
#define SOAP_TYPE_ns1__GetMobileStatusResponseType (101)
/* Type ns1__GetMobileStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetMobileStatusResponseType': */
class SOAP_CMAC ns1__GetMobileStatusResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:IsActivated' of XSD type 'xsd:integer'
        std::string IsActivated;
        /// Required element 'ns1:IsPasswordSet' of XSD type 'xsd:integer'
        std::string IsPasswordSet;
        /// Required element 'ns1:PaymentPending' of XSD type 'xsd:integer'
        std::string PaymentPending;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetMobileStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetMobileStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetMobileStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__GetMobileStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetMobileStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetMobileStatusResponseType() : IsActivated(), IsPasswordSet(), PaymentPending() { }
        virtual ~ns1__GetMobileStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetMobileStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetMobileStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetMobileStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:442 */
#ifndef SOAP_TYPE_ns1__SetMobileCheckoutRequestType
#define SOAP_TYPE_ns1__SetMobileCheckoutRequestType (102)
/* Type ns1__SetMobileCheckoutRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetMobileCheckoutRequestType': */
class SOAP_CMAC ns1__SetMobileCheckoutRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:SetMobileCheckoutRequestDetails' of XSD type 'ns3:SetMobileCheckoutRequestDetailsType'
        ns3__SetMobileCheckoutRequestDetailsType *ns3__SetMobileCheckoutRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetMobileCheckoutRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetMobileCheckoutRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetMobileCheckoutRequestType, default initialized and not managed by a soap context
        virtual ns1__SetMobileCheckoutRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SetMobileCheckoutRequestType); }
      public:
        /// Constructor with initializations
        ns1__SetMobileCheckoutRequestType() : ns3__SetMobileCheckoutRequestDetails() { }
        virtual ~ns1__SetMobileCheckoutRequestType() { }
        /// Friend allocator used by soap_new_ns1__SetMobileCheckoutRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetMobileCheckoutRequestType * SOAP_FMAC2 soap_instantiate_ns1__SetMobileCheckoutRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:445 */
#ifndef SOAP_TYPE_ns1__SetMobileCheckoutResponseType
#define SOAP_TYPE_ns1__SetMobileCheckoutResponseType (103)
/* Type ns1__SetMobileCheckoutResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetMobileCheckoutResponseType': */
class SOAP_CMAC ns1__SetMobileCheckoutResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Token' of XSD type 'xsd:string'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetMobileCheckoutResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetMobileCheckoutResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetMobileCheckoutResponseType, default initialized and not managed by a soap context
        virtual ns1__SetMobileCheckoutResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SetMobileCheckoutResponseType); }
      public:
        /// Constructor with initializations
        ns1__SetMobileCheckoutResponseType() : Token() { }
        virtual ~ns1__SetMobileCheckoutResponseType() { }
        /// Friend allocator used by soap_new_ns1__SetMobileCheckoutResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetMobileCheckoutResponseType * SOAP_FMAC2 soap_instantiate_ns1__SetMobileCheckoutResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:448 */
#ifndef SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType (104)
/* Type ns1__DoMobileCheckoutPaymentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoMobileCheckoutPaymentRequestType': */
class SOAP_CMAC ns1__DoMobileCheckoutPaymentRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'xsd:string'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoMobileCheckoutPaymentRequestType, default initialized and not managed by a soap context
        virtual ns1__DoMobileCheckoutPaymentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoMobileCheckoutPaymentRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoMobileCheckoutPaymentRequestType() : Token() { }
        virtual ~ns1__DoMobileCheckoutPaymentRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoMobileCheckoutPaymentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoMobileCheckoutPaymentRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoMobileCheckoutPaymentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:451 */
#ifndef SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType (105)
/* Type ns1__DoMobileCheckoutPaymentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoMobileCheckoutPaymentResponseType': */
class SOAP_CMAC ns1__DoMobileCheckoutPaymentResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:DoMobileCheckoutPaymentResponseDetails' of XSD type 'ns3:DoMobileCheckoutPaymentResponseDetailsType'
        ns3__DoMobileCheckoutPaymentResponseDetailsType *ns3__DoMobileCheckoutPaymentResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoMobileCheckoutPaymentResponseType, default initialized and not managed by a soap context
        virtual ns1__DoMobileCheckoutPaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoMobileCheckoutPaymentResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoMobileCheckoutPaymentResponseType() : ns3__DoMobileCheckoutPaymentResponseDetails() { }
        virtual ~ns1__DoMobileCheckoutPaymentResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoMobileCheckoutPaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoMobileCheckoutPaymentResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoMobileCheckoutPaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:454 */
#ifndef SOAP_TYPE_ns1__GetBalanceRequestType
#define SOAP_TYPE_ns1__GetBalanceRequestType (106)
/* Type ns1__GetBalanceRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBalanceRequestType': */
class SOAP_CMAC ns1__GetBalanceRequestType : public ns3__AbstractRequestType {
      public:
        /// Optional element 'ns1:ReturnAllCurrencies' of XSD type 'xsd:string'
        std::string *ReturnAllCurrencies;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBalanceRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBalanceRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBalanceRequestType, default initialized and not managed by a soap context
        virtual ns1__GetBalanceRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBalanceRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetBalanceRequestType() : ReturnAllCurrencies() { }
        virtual ~ns1__GetBalanceRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetBalanceRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBalanceRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetBalanceRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:457 */
#ifndef SOAP_TYPE_ns1__GetBalanceResponseType
#define SOAP_TYPE_ns1__GetBalanceResponseType (107)
/* Type ns1__GetBalanceResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBalanceResponseType': */
class SOAP_CMAC ns1__GetBalanceResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Balance' of XSD type 'ns2:BasicAmountType'
        ns2__BasicAmountType *Balance;
        /// Required element 'ns1:BalanceTimeStamp' of XSD type 'xsd:dateTime'
        time_t BalanceTimeStamp;
        /// Optional element 'ns1:BalanceHoldings' of XSD type 'ns2:BasicAmountType'
        std::vector<ns2__BasicAmountType *> BalanceHoldings;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBalanceResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBalanceResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBalanceResponseType, default initialized and not managed by a soap context
        virtual ns1__GetBalanceResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBalanceResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetBalanceResponseType() : Balance(), BalanceTimeStamp(), BalanceHoldings() { }
        virtual ~ns1__GetBalanceResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetBalanceResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBalanceResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetBalanceResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:460 */
#ifndef SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType
#define SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType (108)
/* Type ns1__SetCustomerBillingAgreementRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetCustomerBillingAgreementRequestType': */
class SOAP_CMAC ns1__SetCustomerBillingAgreementRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:SetCustomerBillingAgreementRequestDetails' of XSD type 'ns3:SetCustomerBillingAgreementRequestDetailsType'
        ns3__SetCustomerBillingAgreementRequestDetailsType *ns3__SetCustomerBillingAgreementRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetCustomerBillingAgreementRequestType, default initialized and not managed by a soap context
        virtual ns1__SetCustomerBillingAgreementRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SetCustomerBillingAgreementRequestType); }
      public:
        /// Constructor with initializations
        ns1__SetCustomerBillingAgreementRequestType() : ns3__SetCustomerBillingAgreementRequestDetails() { }
        virtual ~ns1__SetCustomerBillingAgreementRequestType() { }
        /// Friend allocator used by soap_new_ns1__SetCustomerBillingAgreementRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetCustomerBillingAgreementRequestType * SOAP_FMAC2 soap_instantiate_ns1__SetCustomerBillingAgreementRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:463 */
#ifndef SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType
#define SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType (109)
/* Type ns1__SetCustomerBillingAgreementResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SetCustomerBillingAgreementResponseType': */
class SOAP_CMAC ns1__SetCustomerBillingAgreementResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SetCustomerBillingAgreementResponseType, default initialized and not managed by a soap context
        virtual ns1__SetCustomerBillingAgreementResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SetCustomerBillingAgreementResponseType); }
      public:
        /// Constructor with initializations
        ns1__SetCustomerBillingAgreementResponseType() : Token() { }
        virtual ~ns1__SetCustomerBillingAgreementResponseType() { }
        /// Friend allocator used by soap_new_ns1__SetCustomerBillingAgreementResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SetCustomerBillingAgreementResponseType * SOAP_FMAC2 soap_instantiate_ns1__SetCustomerBillingAgreementResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:466 */
#ifndef SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType
#define SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType (110)
/* Type ns1__GetBillingAgreementCustomerDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBillingAgreementCustomerDetailsRequestType': */
class SOAP_CMAC ns1__GetBillingAgreementCustomerDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBillingAgreementCustomerDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetBillingAgreementCustomerDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBillingAgreementCustomerDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetBillingAgreementCustomerDetailsRequestType() : Token() { }
        virtual ~ns1__GetBillingAgreementCustomerDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetBillingAgreementCustomerDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBillingAgreementCustomerDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetBillingAgreementCustomerDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:469 */
#ifndef SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType
#define SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType (111)
/* Type ns1__GetBillingAgreementCustomerDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetBillingAgreementCustomerDetailsResponseType': */
class SOAP_CMAC ns1__GetBillingAgreementCustomerDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetBillingAgreementCustomerDetailsResponseDetails' of XSD type 'ns3:GetBillingAgreementCustomerDetailsResponseDetailsType'
        ns3__GetBillingAgreementCustomerDetailsResponseDetailsType *ns3__GetBillingAgreementCustomerDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetBillingAgreementCustomerDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetBillingAgreementCustomerDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetBillingAgreementCustomerDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetBillingAgreementCustomerDetailsResponseType() : ns3__GetBillingAgreementCustomerDetailsResponseDetails() { }
        virtual ~ns1__GetBillingAgreementCustomerDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetBillingAgreementCustomerDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetBillingAgreementCustomerDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetBillingAgreementCustomerDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:472 */
#ifndef SOAP_TYPE_ns1__CreateBillingAgreementRequestType
#define SOAP_TYPE_ns1__CreateBillingAgreementRequestType (112)
/* Type ns1__CreateBillingAgreementRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateBillingAgreementRequestType': */
class SOAP_CMAC ns1__CreateBillingAgreementRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns3:ExpressCheckoutTokenType'
        std::string Token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateBillingAgreementRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateBillingAgreementRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateBillingAgreementRequestType, default initialized and not managed by a soap context
        virtual ns1__CreateBillingAgreementRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateBillingAgreementRequestType); }
      public:
        /// Constructor with initializations
        ns1__CreateBillingAgreementRequestType() : Token() { }
        virtual ~ns1__CreateBillingAgreementRequestType() { }
        /// Friend allocator used by soap_new_ns1__CreateBillingAgreementRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateBillingAgreementRequestType * SOAP_FMAC2 soap_instantiate_ns1__CreateBillingAgreementRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:475 */
#ifndef SOAP_TYPE_ns1__CreateBillingAgreementResponseType
#define SOAP_TYPE_ns1__CreateBillingAgreementResponseType (113)
/* Type ns1__CreateBillingAgreementResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateBillingAgreementResponseType': */
class SOAP_CMAC ns1__CreateBillingAgreementResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:BillingAgreementID' of XSD type 'xsd:string'
        std::string BillingAgreementID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateBillingAgreementResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateBillingAgreementResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateBillingAgreementResponseType, default initialized and not managed by a soap context
        virtual ns1__CreateBillingAgreementResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateBillingAgreementResponseType); }
      public:
        /// Constructor with initializations
        ns1__CreateBillingAgreementResponseType() : BillingAgreementID() { }
        virtual ~ns1__CreateBillingAgreementResponseType() { }
        /// Friend allocator used by soap_new_ns1__CreateBillingAgreementResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateBillingAgreementResponseType * SOAP_FMAC2 soap_instantiate_ns1__CreateBillingAgreementResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:478 */
#ifndef SOAP_TYPE_ns1__DoReferenceTransactionRequestType
#define SOAP_TYPE_ns1__DoReferenceTransactionRequestType (114)
/* Type ns1__DoReferenceTransactionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoReferenceTransactionRequestType': */
class SOAP_CMAC ns1__DoReferenceTransactionRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:DoReferenceTransactionRequestDetails' of XSD type 'ns3:DoReferenceTransactionRequestDetailsType'
        ns3__DoReferenceTransactionRequestDetailsType *ns3__DoReferenceTransactionRequestDetails;
        /// Optional element 'ns1:ReturnFMFDetails' of XSD type 'xsd:int'
        int *ReturnFMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoReferenceTransactionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoReferenceTransactionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoReferenceTransactionRequestType, default initialized and not managed by a soap context
        virtual ns1__DoReferenceTransactionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoReferenceTransactionRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoReferenceTransactionRequestType() : ns3__DoReferenceTransactionRequestDetails(), ReturnFMFDetails() { }
        virtual ~ns1__DoReferenceTransactionRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoReferenceTransactionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoReferenceTransactionRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoReferenceTransactionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:481 */
#ifndef SOAP_TYPE_ns1__DoReferenceTransactionResponseType
#define SOAP_TYPE_ns1__DoReferenceTransactionResponseType (115)
/* Type ns1__DoReferenceTransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoReferenceTransactionResponseType': */
class SOAP_CMAC ns1__DoReferenceTransactionResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:DoReferenceTransactionResponseDetails' of XSD type 'ns3:DoReferenceTransactionResponseDetailsType'
        ns3__DoReferenceTransactionResponseDetailsType *ns3__DoReferenceTransactionResponseDetails;
        /// Optional element 'ns1:FMFDetails' of XSD type 'ns3:FMFDetailsType'
        ns3__FMFDetailsType *FMFDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoReferenceTransactionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoReferenceTransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoReferenceTransactionResponseType, default initialized and not managed by a soap context
        virtual ns1__DoReferenceTransactionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoReferenceTransactionResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoReferenceTransactionResponseType() : ns3__DoReferenceTransactionResponseDetails(), FMFDetails() { }
        virtual ~ns1__DoReferenceTransactionResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoReferenceTransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoReferenceTransactionResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoReferenceTransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:484 */
#ifndef SOAP_TYPE_ns1__DoNonReferencedCreditRequestType
#define SOAP_TYPE_ns1__DoNonReferencedCreditRequestType (116)
/* Type ns1__DoNonReferencedCreditRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoNonReferencedCreditRequestType': */
class SOAP_CMAC ns1__DoNonReferencedCreditRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:DoNonReferencedCreditRequestDetails' of XSD type 'ns3:DoNonReferencedCreditRequestDetailsType'
        ns3__DoNonReferencedCreditRequestDetailsType *ns3__DoNonReferencedCreditRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoNonReferencedCreditRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoNonReferencedCreditRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoNonReferencedCreditRequestType, default initialized and not managed by a soap context
        virtual ns1__DoNonReferencedCreditRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoNonReferencedCreditRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoNonReferencedCreditRequestType() : ns3__DoNonReferencedCreditRequestDetails() { }
        virtual ~ns1__DoNonReferencedCreditRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoNonReferencedCreditRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoNonReferencedCreditRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoNonReferencedCreditRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:487 */
#ifndef SOAP_TYPE_ns1__DoNonReferencedCreditResponseType
#define SOAP_TYPE_ns1__DoNonReferencedCreditResponseType (117)
/* Type ns1__DoNonReferencedCreditResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoNonReferencedCreditResponseType': */
class SOAP_CMAC ns1__DoNonReferencedCreditResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:DoNonReferencedCreditResponseDetails' of XSD type 'ns3:DoNonReferencedCreditResponseDetailsType'
        ns3__DoNonReferencedCreditResponseDetailsType *ns3__DoNonReferencedCreditResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoNonReferencedCreditResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoNonReferencedCreditResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoNonReferencedCreditResponseType, default initialized and not managed by a soap context
        virtual ns1__DoNonReferencedCreditResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoNonReferencedCreditResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoNonReferencedCreditResponseType() : ns3__DoNonReferencedCreditResponseDetails() { }
        virtual ~ns1__DoNonReferencedCreditResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoNonReferencedCreditResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoNonReferencedCreditResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoNonReferencedCreditResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:490 */
#ifndef SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType (118)
/* Type ns1__CreateRecurringPaymentsProfileRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateRecurringPaymentsProfileRequestType': */
class SOAP_CMAC ns1__CreateRecurringPaymentsProfileRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:CreateRecurringPaymentsProfileRequestDetails' of XSD type 'ns3:CreateRecurringPaymentsProfileRequestDetailsType'
        ns3__CreateRecurringPaymentsProfileRequestDetailsType *ns3__CreateRecurringPaymentsProfileRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateRecurringPaymentsProfileRequestType, default initialized and not managed by a soap context
        virtual ns1__CreateRecurringPaymentsProfileRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateRecurringPaymentsProfileRequestType); }
      public:
        /// Constructor with initializations
        ns1__CreateRecurringPaymentsProfileRequestType() : ns3__CreateRecurringPaymentsProfileRequestDetails() { }
        virtual ~ns1__CreateRecurringPaymentsProfileRequestType() { }
        /// Friend allocator used by soap_new_ns1__CreateRecurringPaymentsProfileRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateRecurringPaymentsProfileRequestType * SOAP_FMAC2 soap_instantiate_ns1__CreateRecurringPaymentsProfileRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:493 */
#ifndef SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType
#define SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType (119)
/* Type ns1__CreateRecurringPaymentsProfileResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CreateRecurringPaymentsProfileResponseType': */
class SOAP_CMAC ns1__CreateRecurringPaymentsProfileResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:CreateRecurringPaymentsProfileResponseDetails' of XSD type 'ns3:CreateRecurringPaymentsProfileResponseDetailsType'
        ns3__CreateRecurringPaymentsProfileResponseDetailsType *ns3__CreateRecurringPaymentsProfileResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CreateRecurringPaymentsProfileResponseType, default initialized and not managed by a soap context
        virtual ns1__CreateRecurringPaymentsProfileResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__CreateRecurringPaymentsProfileResponseType); }
      public:
        /// Constructor with initializations
        ns1__CreateRecurringPaymentsProfileResponseType() : ns3__CreateRecurringPaymentsProfileResponseDetails() { }
        virtual ~ns1__CreateRecurringPaymentsProfileResponseType() { }
        /// Friend allocator used by soap_new_ns1__CreateRecurringPaymentsProfileResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CreateRecurringPaymentsProfileResponseType * SOAP_FMAC2 soap_instantiate_ns1__CreateRecurringPaymentsProfileResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:496 */
#ifndef SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType
#define SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType (120)
/* Type ns1__GetRecurringPaymentsProfileDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetRecurringPaymentsProfileDetailsRequestType': */
class SOAP_CMAC ns1__GetRecurringPaymentsProfileDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:ProfileID' of XSD type 'xsd:string'
        std::string ProfileID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetRecurringPaymentsProfileDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetRecurringPaymentsProfileDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetRecurringPaymentsProfileDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetRecurringPaymentsProfileDetailsRequestType() : ProfileID() { }
        virtual ~ns1__GetRecurringPaymentsProfileDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetRecurringPaymentsProfileDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetRecurringPaymentsProfileDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetRecurringPaymentsProfileDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:499 */
#ifndef SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType
#define SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType (121)
/* Type ns1__GetRecurringPaymentsProfileDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetRecurringPaymentsProfileDetailsResponseType': */
class SOAP_CMAC ns1__GetRecurringPaymentsProfileDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:GetRecurringPaymentsProfileDetailsResponseDetails' of XSD type 'ns3:GetRecurringPaymentsProfileDetailsResponseDetailsType'
        ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType *ns3__GetRecurringPaymentsProfileDetailsResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetRecurringPaymentsProfileDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetRecurringPaymentsProfileDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetRecurringPaymentsProfileDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetRecurringPaymentsProfileDetailsResponseType() : ns3__GetRecurringPaymentsProfileDetailsResponseDetails() { }
        virtual ~ns1__GetRecurringPaymentsProfileDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetRecurringPaymentsProfileDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetRecurringPaymentsProfileDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetRecurringPaymentsProfileDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:502 */
#ifndef SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType
#define SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType (122)
/* Type ns1__ManageRecurringPaymentsProfileStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ManageRecurringPaymentsProfileStatusRequestType': */
class SOAP_CMAC ns1__ManageRecurringPaymentsProfileStatusRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:ManageRecurringPaymentsProfileStatusRequestDetails' of XSD type 'ns3:ManageRecurringPaymentsProfileStatusRequestDetailsType'
        ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType *ns3__ManageRecurringPaymentsProfileStatusRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ManageRecurringPaymentsProfileStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__ManageRecurringPaymentsProfileStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ManageRecurringPaymentsProfileStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__ManageRecurringPaymentsProfileStatusRequestType() : ns3__ManageRecurringPaymentsProfileStatusRequestDetails() { }
        virtual ~ns1__ManageRecurringPaymentsProfileStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__ManageRecurringPaymentsProfileStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ManageRecurringPaymentsProfileStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__ManageRecurringPaymentsProfileStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:505 */
#ifndef SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType
#define SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType (123)
/* Type ns1__ManageRecurringPaymentsProfileStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ManageRecurringPaymentsProfileStatusResponseType': */
class SOAP_CMAC ns1__ManageRecurringPaymentsProfileStatusResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:ManageRecurringPaymentsProfileStatusResponseDetails' of XSD type 'ns3:ManageRecurringPaymentsProfileStatusResponseDetailsType'
        ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType *ns3__ManageRecurringPaymentsProfileStatusResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ManageRecurringPaymentsProfileStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__ManageRecurringPaymentsProfileStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ManageRecurringPaymentsProfileStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__ManageRecurringPaymentsProfileStatusResponseType() : ns3__ManageRecurringPaymentsProfileStatusResponseDetails() { }
        virtual ~ns1__ManageRecurringPaymentsProfileStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__ManageRecurringPaymentsProfileStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ManageRecurringPaymentsProfileStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__ManageRecurringPaymentsProfileStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:508 */
#ifndef SOAP_TYPE_ns1__BillOutstandingAmountRequestType
#define SOAP_TYPE_ns1__BillOutstandingAmountRequestType (124)
/* Type ns1__BillOutstandingAmountRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BillOutstandingAmountRequestType': */
class SOAP_CMAC ns1__BillOutstandingAmountRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:BillOutstandingAmountRequestDetails' of XSD type 'ns3:BillOutstandingAmountRequestDetailsType'
        ns3__BillOutstandingAmountRequestDetailsType *ns3__BillOutstandingAmountRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BillOutstandingAmountRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BillOutstandingAmountRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BillOutstandingAmountRequestType, default initialized and not managed by a soap context
        virtual ns1__BillOutstandingAmountRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BillOutstandingAmountRequestType); }
      public:
        /// Constructor with initializations
        ns1__BillOutstandingAmountRequestType() : ns3__BillOutstandingAmountRequestDetails() { }
        virtual ~ns1__BillOutstandingAmountRequestType() { }
        /// Friend allocator used by soap_new_ns1__BillOutstandingAmountRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BillOutstandingAmountRequestType * SOAP_FMAC2 soap_instantiate_ns1__BillOutstandingAmountRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:511 */
#ifndef SOAP_TYPE_ns1__BillOutstandingAmountResponseType
#define SOAP_TYPE_ns1__BillOutstandingAmountResponseType (125)
/* Type ns1__BillOutstandingAmountResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BillOutstandingAmountResponseType': */
class SOAP_CMAC ns1__BillOutstandingAmountResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:BillOutstandingAmountResponseDetails' of XSD type 'ns3:BillOutstandingAmountResponseDetailsType'
        ns3__BillOutstandingAmountResponseDetailsType *ns3__BillOutstandingAmountResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BillOutstandingAmountResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BillOutstandingAmountResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BillOutstandingAmountResponseType, default initialized and not managed by a soap context
        virtual ns1__BillOutstandingAmountResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__BillOutstandingAmountResponseType); }
      public:
        /// Constructor with initializations
        ns1__BillOutstandingAmountResponseType() : ns3__BillOutstandingAmountResponseDetails() { }
        virtual ~ns1__BillOutstandingAmountResponseType() { }
        /// Friend allocator used by soap_new_ns1__BillOutstandingAmountResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BillOutstandingAmountResponseType * SOAP_FMAC2 soap_instantiate_ns1__BillOutstandingAmountResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:514 */
#ifndef SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType (126)
/* Type ns1__UpdateRecurringPaymentsProfileRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateRecurringPaymentsProfileRequestType': */
class SOAP_CMAC ns1__UpdateRecurringPaymentsProfileRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:UpdateRecurringPaymentsProfileRequestDetails' of XSD type 'ns3:UpdateRecurringPaymentsProfileRequestDetailsType'
        ns3__UpdateRecurringPaymentsProfileRequestDetailsType *ns3__UpdateRecurringPaymentsProfileRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateRecurringPaymentsProfileRequestType, default initialized and not managed by a soap context
        virtual ns1__UpdateRecurringPaymentsProfileRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateRecurringPaymentsProfileRequestType); }
      public:
        /// Constructor with initializations
        ns1__UpdateRecurringPaymentsProfileRequestType() : ns3__UpdateRecurringPaymentsProfileRequestDetails() { }
        virtual ~ns1__UpdateRecurringPaymentsProfileRequestType() { }
        /// Friend allocator used by soap_new_ns1__UpdateRecurringPaymentsProfileRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateRecurringPaymentsProfileRequestType * SOAP_FMAC2 soap_instantiate_ns1__UpdateRecurringPaymentsProfileRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:517 */
#ifndef SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType
#define SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType (127)
/* Type ns1__UpdateRecurringPaymentsProfileResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UpdateRecurringPaymentsProfileResponseType': */
class SOAP_CMAC ns1__UpdateRecurringPaymentsProfileResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:UpdateRecurringPaymentsProfileResponseDetails' of XSD type 'ns3:UpdateRecurringPaymentsProfileResponseDetailsType'
        ns3__UpdateRecurringPaymentsProfileResponseDetailsType *ns3__UpdateRecurringPaymentsProfileResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UpdateRecurringPaymentsProfileResponseType, default initialized and not managed by a soap context
        virtual ns1__UpdateRecurringPaymentsProfileResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__UpdateRecurringPaymentsProfileResponseType); }
      public:
        /// Constructor with initializations
        ns1__UpdateRecurringPaymentsProfileResponseType() : ns3__UpdateRecurringPaymentsProfileResponseDetails() { }
        virtual ~ns1__UpdateRecurringPaymentsProfileResponseType() { }
        /// Friend allocator used by soap_new_ns1__UpdateRecurringPaymentsProfileResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UpdateRecurringPaymentsProfileResponseType * SOAP_FMAC2 soap_instantiate_ns1__UpdateRecurringPaymentsProfileResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:520 */
#ifndef SOAP_TYPE_ns1__GetPalDetailsRequestType
#define SOAP_TYPE_ns1__GetPalDetailsRequestType (128)
/* Type ns1__GetPalDetailsRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetPalDetailsRequestType': */
class SOAP_CMAC ns1__GetPalDetailsRequestType : public ns3__AbstractRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetPalDetailsRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetPalDetailsRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetPalDetailsRequestType, default initialized and not managed by a soap context
        virtual ns1__GetPalDetailsRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GetPalDetailsRequestType); }
      public:
        /// Constructor with initializations
        ns1__GetPalDetailsRequestType() { }
        virtual ~ns1__GetPalDetailsRequestType() { }
        /// Friend allocator used by soap_new_ns1__GetPalDetailsRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetPalDetailsRequestType * SOAP_FMAC2 soap_instantiate_ns1__GetPalDetailsRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:523 */
#ifndef SOAP_TYPE_ns1__GetPalDetailsResponseType
#define SOAP_TYPE_ns1__GetPalDetailsResponseType (129)
/* Type ns1__GetPalDetailsResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GetPalDetailsResponseType': */
class SOAP_CMAC ns1__GetPalDetailsResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns1:Pal' of XSD type 'xsd:string'
        std::string Pal;
        /// Required element 'ns1:Locale' of XSD type 'xsd:string'
        std::string Locale;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetPalDetailsResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GetPalDetailsResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetPalDetailsResponseType, default initialized and not managed by a soap context
        virtual ns1__GetPalDetailsResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__GetPalDetailsResponseType); }
      public:
        /// Constructor with initializations
        ns1__GetPalDetailsResponseType() : Pal(), Locale() { }
        virtual ~ns1__GetPalDetailsResponseType() { }
        /// Friend allocator used by soap_new_ns1__GetPalDetailsResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetPalDetailsResponseType * SOAP_FMAC2 soap_instantiate_ns1__GetPalDetailsResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:526 */
#ifndef SOAP_TYPE_ns1__ReverseTransactionRequestType
#define SOAP_TYPE_ns1__ReverseTransactionRequestType (130)
/* Type ns1__ReverseTransactionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ReverseTransactionRequestType': */
class SOAP_CMAC ns1__ReverseTransactionRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns3:ReverseTransactionRequestDetails' of XSD type 'ns3:ReverseTransactionRequestDetailsType'
        ns3__ReverseTransactionRequestDetailsType *ns3__ReverseTransactionRequestDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReverseTransactionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReverseTransactionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReverseTransactionRequestType, default initialized and not managed by a soap context
        virtual ns1__ReverseTransactionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ReverseTransactionRequestType); }
      public:
        /// Constructor with initializations
        ns1__ReverseTransactionRequestType() : ns3__ReverseTransactionRequestDetails() { }
        virtual ~ns1__ReverseTransactionRequestType() { }
        /// Friend allocator used by soap_new_ns1__ReverseTransactionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReverseTransactionRequestType * SOAP_FMAC2 soap_instantiate_ns1__ReverseTransactionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:529 */
#ifndef SOAP_TYPE_ns1__ReverseTransactionResponseType
#define SOAP_TYPE_ns1__ReverseTransactionResponseType (131)
/* Type ns1__ReverseTransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ReverseTransactionResponseType': */
class SOAP_CMAC ns1__ReverseTransactionResponseType : public ns3__AbstractResponseType {
      public:
        /// Required element 'ns3:ReverseTransactionResponseDetails' of XSD type 'ns3:ReverseTransactionResponseDetailsType'
        ns3__ReverseTransactionResponseDetailsType *ns3__ReverseTransactionResponseDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReverseTransactionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReverseTransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReverseTransactionResponseType, default initialized and not managed by a soap context
        virtual ns1__ReverseTransactionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ReverseTransactionResponseType); }
      public:
        /// Constructor with initializations
        ns1__ReverseTransactionResponseType() : ns3__ReverseTransactionResponseDetails() { }
        virtual ~ns1__ReverseTransactionResponseType() { }
        /// Friend allocator used by soap_new_ns1__ReverseTransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReverseTransactionResponseType * SOAP_FMAC2 soap_instantiate_ns1__ReverseTransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:532 */
#ifndef SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType
#define SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType (132)
/* Type ns1__ExternalRememberMeOptOutRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ExternalRememberMeOptOutRequestType': */
class SOAP_CMAC ns1__ExternalRememberMeOptOutRequestType : public ns3__AbstractRequestType {
      public:
        /// Required element 'ns1:ExternalRememberMeID' of XSD type 'xsd:string'
        std::string ExternalRememberMeID;
        /// Optional element 'ns1:ExternalRememberMeOwnerDetails' of XSD type 'ns3:ExternalRememberMeOwnerDetailsType'
        ns3__ExternalRememberMeOwnerDetailsType *ExternalRememberMeOwnerDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExternalRememberMeOptOutRequestType, default initialized and not managed by a soap context
        virtual ns1__ExternalRememberMeOptOutRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ExternalRememberMeOptOutRequestType); }
      public:
        /// Constructor with initializations
        ns1__ExternalRememberMeOptOutRequestType() : ExternalRememberMeID(), ExternalRememberMeOwnerDetails() { }
        virtual ~ns1__ExternalRememberMeOptOutRequestType() { }
        /// Friend allocator used by soap_new_ns1__ExternalRememberMeOptOutRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExternalRememberMeOptOutRequestType * SOAP_FMAC2 soap_instantiate_ns1__ExternalRememberMeOptOutRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:535 */
#ifndef SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType
#define SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType (133)
/* Type ns1__ExternalRememberMeOptOutResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ExternalRememberMeOptOutResponseType': */
class SOAP_CMAC ns1__ExternalRememberMeOptOutResponseType : public ns3__AbstractResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExternalRememberMeOptOutResponseType, default initialized and not managed by a soap context
        virtual ns1__ExternalRememberMeOptOutResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ExternalRememberMeOptOutResponseType); }
      public:
        /// Constructor with initializations
        ns1__ExternalRememberMeOptOutResponseType() { }
        virtual ~ns1__ExternalRememberMeOptOutResponseType() { }
        /// Friend allocator used by soap_new_ns1__ExternalRememberMeOptOutResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExternalRememberMeOptOutResponseType * SOAP_FMAC2 soap_instantiate_ns1__ExternalRememberMeOptOutResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:709 */
#ifndef SOAP_TYPE_ns2__AmountType
#define SOAP_TYPE_ns2__AmountType (191)
/* simple XSD type 'ns2:AmountType': */
class SOAP_CMAC ns2__AmountType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
        /// required attribute 'currencyID' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType currencyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AmountType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AmountType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AmountType, default initialized and not managed by a soap context
        virtual ns2__AmountType *soap_alloc(void) const { return SOAP_NEW(ns2__AmountType); }
      public:
        /// Constructor with initializations
        ns2__AmountType() : __item(), currencyID(), soap() { }
        virtual ~ns2__AmountType() { }
        /// Friend allocator used by soap_new_ns2__AmountType(struct soap*, int)
        friend SOAP_FMAC1 ns2__AmountType * SOAP_FMAC2 soap_instantiate_ns2__AmountType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:712 */
#ifndef SOAP_TYPE_ns2__BasicAmountType
#define SOAP_TYPE_ns2__BasicAmountType (192)
/* simple XSD type 'ns2:BasicAmountType': */
class SOAP_CMAC ns2__BasicAmountType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'currencyID' of XSD type 'ns3:CurrencyCodeType'
        enum ns3__CurrencyCodeType currencyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BasicAmountType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BasicAmountType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BasicAmountType, default initialized and not managed by a soap context
        virtual ns2__BasicAmountType *soap_alloc(void) const { return SOAP_NEW(ns2__BasicAmountType); }
      public:
        /// Constructor with initializations
        ns2__BasicAmountType() : __item(), currencyID(), soap() { }
        virtual ~ns2__BasicAmountType() { }
        /// Friend allocator used by soap_new_ns2__BasicAmountType(struct soap*, int)
        friend SOAP_FMAC1 ns2__BasicAmountType * SOAP_FMAC2 soap_instantiate_ns2__BasicAmountType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:715 */
#ifndef SOAP_TYPE_ns2__MeasureType
#define SOAP_TYPE_ns2__MeasureType (193)
/* simple XSD type 'ns2:MeasureType': */
class SOAP_CMAC ns2__MeasureType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
        /// required attribute 'unit' of XSD type 'xsd:token'
        std::string unit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MeasureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MeasureType, default initialized and not managed by a soap context
        virtual ns2__MeasureType *soap_alloc(void) const { return SOAP_NEW(ns2__MeasureType); }
      public:
        /// Constructor with initializations
        ns2__MeasureType() : __item(), unit(), soap() { }
        virtual ~ns2__MeasureType() { }
        /// Friend allocator used by soap_new_ns2__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 ns2__MeasureType * SOAP_FMAC2 soap_instantiate_ns2__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:718 */
#ifndef SOAP_TYPE_ns2__QuantityType
#define SOAP_TYPE_ns2__QuantityType (194)
/* simple XSD type 'ns2:QuantityType': */
class SOAP_CMAC ns2__QuantityType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
        /// optional attribute 'unit' of XSD type 'xsd:token'
        std::string *unit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__QuantityType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__QuantityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__QuantityType, default initialized and not managed by a soap context
        virtual ns2__QuantityType *soap_alloc(void) const { return SOAP_NEW(ns2__QuantityType); }
      public:
        /// Constructor with initializations
        ns2__QuantityType() : __item(), unit(), soap() { }
        virtual ~ns2__QuantityType() { }
        /// Friend allocator used by soap_new_ns2__QuantityType(struct soap*, int)
        friend SOAP_FMAC1 ns2__QuantityType * SOAP_FMAC2 soap_instantiate_ns2__QuantityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:370 */
#ifndef SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType (78)
/* Type ns1__DoUATPExpressCheckoutPaymentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoUATPExpressCheckoutPaymentRequestType': */
class SOAP_CMAC ns1__DoUATPExpressCheckoutPaymentRequestType : public ns1__DoExpressCheckoutPaymentRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoUATPExpressCheckoutPaymentRequestType, default initialized and not managed by a soap context
        virtual ns1__DoUATPExpressCheckoutPaymentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DoUATPExpressCheckoutPaymentRequestType); }
      public:
        /// Constructor with initializations
        ns1__DoUATPExpressCheckoutPaymentRequestType() { }
        virtual ~ns1__DoUATPExpressCheckoutPaymentRequestType() { }
        /// Friend allocator used by soap_new_ns1__DoUATPExpressCheckoutPaymentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoUATPExpressCheckoutPaymentRequestType * SOAP_FMAC2 soap_instantiate_ns1__DoUATPExpressCheckoutPaymentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:373 */
#ifndef SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType (79)
/* Type ns1__DoUATPExpressCheckoutPaymentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoUATPExpressCheckoutPaymentResponseType': */
class SOAP_CMAC ns1__DoUATPExpressCheckoutPaymentResponseType : public ns1__DoExpressCheckoutPaymentResponseType {
      public:
        /// Required element 'ns3:UATPDetails' of XSD type 'ns3:UATPDetailsType'
        ns3__UATPDetailsType *ns3__UATPDetails;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoUATPExpressCheckoutPaymentResponseType, default initialized and not managed by a soap context
        virtual ns1__DoUATPExpressCheckoutPaymentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoUATPExpressCheckoutPaymentResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoUATPExpressCheckoutPaymentResponseType() : ns3__UATPDetails() { }
        virtual ~ns1__DoUATPExpressCheckoutPaymentResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoUATPExpressCheckoutPaymentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoUATPExpressCheckoutPaymentResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoUATPExpressCheckoutPaymentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:427 */
#ifndef SOAP_TYPE_ns1__DoUATPAuthorizationResponseType
#define SOAP_TYPE_ns1__DoUATPAuthorizationResponseType (97)
/* Type ns1__DoUATPAuthorizationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DoUATPAuthorizationResponseType': */
class SOAP_CMAC ns1__DoUATPAuthorizationResponseType : public ns1__DoAuthorizationResponseType {
      public:
        /// Required element 'ns3:UATPDetails' of XSD type 'ns3:UATPDetailsType'
        ns3__UATPDetailsType *ns3__UATPDetails;
        /// Required element 'ns1:AuthorizationCode' of XSD type 'xsd:string'
        std::string AuthorizationCode;
        /// Optional element 'ns1:InvoiceID' of XSD type 'xsd:string'
        std::string *InvoiceID;
        /// Optional element 'ns1:MsgSubID' of XSD type 'xsd:string'
        std::string *MsgSubID;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DoUATPAuthorizationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DoUATPAuthorizationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DoUATPAuthorizationResponseType, default initialized and not managed by a soap context
        virtual ns1__DoUATPAuthorizationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__DoUATPAuthorizationResponseType); }
      public:
        /// Constructor with initializations
        ns1__DoUATPAuthorizationResponseType() : ns3__UATPDetails(), AuthorizationCode(), InvoiceID(), MsgSubID() { }
        virtual ~ns1__DoUATPAuthorizationResponseType() { }
        /// Friend allocator used by soap_new_ns1__DoUATPAuthorizationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DoUATPAuthorizationResponseType * SOAP_FMAC2 soap_instantiate_ns1__DoUATPAuthorizationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26235 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (958)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'ns1:RequesterCredentials' of XSD type 'ns3:CustomSecurityHeaderType' */
        ns3__CustomSecurityHeaderType *ns1__RequesterCredentials;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : ns1__RequesterCredentials() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* paypal.h:26324 */
#ifndef SOAP_TYPE___ns1__RefundTransaction
#define SOAP_TYPE___ns1__RefundTransaction (963)
/* Wrapper: */
struct SOAP_CMAC __ns1__RefundTransaction {
      public:
        /** Optional element 'ns1:RefundTransactionReq' of XSD type 'ns1:RefundTransactionReq' */
        _ns1__RefundTransactionReq *ns1__RefundTransactionReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RefundTransaction */
        int soap_type() const { return SOAP_TYPE___ns1__RefundTransaction; }
        /** Constructor with member initializations */
        __ns1__RefundTransaction() : ns1__RefundTransactionReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__RefundTransaction * SOAP_FMAC2 soap_instantiate___ns1__RefundTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26400 */
#ifndef SOAP_TYPE___ns1__InitiateRecoup
#define SOAP_TYPE___ns1__InitiateRecoup (967)
/* Wrapper: */
struct SOAP_CMAC __ns1__InitiateRecoup {
      public:
        /** Optional element 'ns1:InitiateRecoupReq' of XSD type 'ns1:InitiateRecoupReq' */
        _ns1__InitiateRecoupReq *ns1__InitiateRecoupReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InitiateRecoup */
        int soap_type() const { return SOAP_TYPE___ns1__InitiateRecoup; }
        /** Constructor with member initializations */
        __ns1__InitiateRecoup() : ns1__InitiateRecoupReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InitiateRecoup * SOAP_FMAC2 soap_instantiate___ns1__InitiateRecoup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26476 */
#ifndef SOAP_TYPE___ns1__CompleteRecoup
#define SOAP_TYPE___ns1__CompleteRecoup (971)
/* Wrapper: */
struct SOAP_CMAC __ns1__CompleteRecoup {
      public:
        /** Optional element 'ns1:CompleteRecoupReq' of XSD type 'ns1:CompleteRecoupReq' */
        _ns1__CompleteRecoupReq *ns1__CompleteRecoupReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CompleteRecoup */
        int soap_type() const { return SOAP_TYPE___ns1__CompleteRecoup; }
        /** Constructor with member initializations */
        __ns1__CompleteRecoup() : ns1__CompleteRecoupReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CompleteRecoup * SOAP_FMAC2 soap_instantiate___ns1__CompleteRecoup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26552 */
#ifndef SOAP_TYPE___ns1__CancelRecoup
#define SOAP_TYPE___ns1__CancelRecoup (975)
/* Wrapper: */
struct SOAP_CMAC __ns1__CancelRecoup {
      public:
        /** Optional element 'ns1:CancelRecoupReq' of XSD type 'ns1:CancelRecoupReq' */
        _ns1__CancelRecoupReq *ns1__CancelRecoupReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CancelRecoup */
        int soap_type() const { return SOAP_TYPE___ns1__CancelRecoup; }
        /** Constructor with member initializations */
        __ns1__CancelRecoup() : ns1__CancelRecoupReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CancelRecoup * SOAP_FMAC2 soap_instantiate___ns1__CancelRecoup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26628 */
#ifndef SOAP_TYPE___ns1__GetTransactionDetails
#define SOAP_TYPE___ns1__GetTransactionDetails (979)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTransactionDetails {
      public:
        /** Optional element 'ns1:GetTransactionDetailsReq' of XSD type 'ns1:GetTransactionDetailsReq' */
        _ns1__GetTransactionDetailsReq *ns1__GetTransactionDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTransactionDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetTransactionDetails; }
        /** Constructor with member initializations */
        __ns1__GetTransactionDetails() : ns1__GetTransactionDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTransactionDetails * SOAP_FMAC2 soap_instantiate___ns1__GetTransactionDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26704 */
#ifndef SOAP_TYPE___ns1__BMCreateButton
#define SOAP_TYPE___ns1__BMCreateButton (983)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMCreateButton {
      public:
        /** Optional element 'ns1:BMCreateButtonReq' of XSD type 'ns1:BMCreateButtonReq' */
        _ns1__BMCreateButtonReq *ns1__BMCreateButtonReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMCreateButton */
        int soap_type() const { return SOAP_TYPE___ns1__BMCreateButton; }
        /** Constructor with member initializations */
        __ns1__BMCreateButton() : ns1__BMCreateButtonReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMCreateButton * SOAP_FMAC2 soap_instantiate___ns1__BMCreateButton(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26780 */
#ifndef SOAP_TYPE___ns1__BMUpdateButton
#define SOAP_TYPE___ns1__BMUpdateButton (987)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMUpdateButton {
      public:
        /** Optional element 'ns1:BMUpdateButtonReq' of XSD type 'ns1:BMUpdateButtonReq' */
        _ns1__BMUpdateButtonReq *ns1__BMUpdateButtonReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMUpdateButton */
        int soap_type() const { return SOAP_TYPE___ns1__BMUpdateButton; }
        /** Constructor with member initializations */
        __ns1__BMUpdateButton() : ns1__BMUpdateButtonReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMUpdateButton * SOAP_FMAC2 soap_instantiate___ns1__BMUpdateButton(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26856 */
#ifndef SOAP_TYPE___ns1__BMSetInventory
#define SOAP_TYPE___ns1__BMSetInventory (991)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMSetInventory {
      public:
        /** Optional element 'ns1:BMSetInventoryReq' of XSD type 'ns1:BMSetInventoryReq' */
        _ns1__BMSetInventoryReq *ns1__BMSetInventoryReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMSetInventory */
        int soap_type() const { return SOAP_TYPE___ns1__BMSetInventory; }
        /** Constructor with member initializations */
        __ns1__BMSetInventory() : ns1__BMSetInventoryReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMSetInventory * SOAP_FMAC2 soap_instantiate___ns1__BMSetInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:26932 */
#ifndef SOAP_TYPE___ns1__BMGetButtonDetails
#define SOAP_TYPE___ns1__BMGetButtonDetails (995)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMGetButtonDetails {
      public:
        /** Optional element 'ns1:BMGetButtonDetailsReq' of XSD type 'ns1:BMGetButtonDetailsReq' */
        _ns1__BMGetButtonDetailsReq *ns1__BMGetButtonDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMGetButtonDetails */
        int soap_type() const { return SOAP_TYPE___ns1__BMGetButtonDetails; }
        /** Constructor with member initializations */
        __ns1__BMGetButtonDetails() : ns1__BMGetButtonDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMGetButtonDetails * SOAP_FMAC2 soap_instantiate___ns1__BMGetButtonDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27008 */
#ifndef SOAP_TYPE___ns1__BMGetInventory
#define SOAP_TYPE___ns1__BMGetInventory (999)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMGetInventory {
      public:
        /** Optional element 'ns1:BMGetInventoryReq' of XSD type 'ns1:BMGetInventoryReq' */
        _ns1__BMGetInventoryReq *ns1__BMGetInventoryReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMGetInventory */
        int soap_type() const { return SOAP_TYPE___ns1__BMGetInventory; }
        /** Constructor with member initializations */
        __ns1__BMGetInventory() : ns1__BMGetInventoryReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMGetInventory * SOAP_FMAC2 soap_instantiate___ns1__BMGetInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27084 */
#ifndef SOAP_TYPE___ns1__BMManageButtonStatus
#define SOAP_TYPE___ns1__BMManageButtonStatus (1003)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMManageButtonStatus {
      public:
        /** Optional element 'ns1:BMManageButtonStatusReq' of XSD type 'ns1:BMManageButtonStatusReq' */
        _ns1__BMManageButtonStatusReq *ns1__BMManageButtonStatusReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMManageButtonStatus */
        int soap_type() const { return SOAP_TYPE___ns1__BMManageButtonStatus; }
        /** Constructor with member initializations */
        __ns1__BMManageButtonStatus() : ns1__BMManageButtonStatusReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMManageButtonStatus * SOAP_FMAC2 soap_instantiate___ns1__BMManageButtonStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27160 */
#ifndef SOAP_TYPE___ns1__BMButtonSearch
#define SOAP_TYPE___ns1__BMButtonSearch (1007)
/* Wrapper: */
struct SOAP_CMAC __ns1__BMButtonSearch {
      public:
        /** Optional element 'ns1:BMButtonSearchReq' of XSD type 'ns1:BMButtonSearchReq' */
        _ns1__BMButtonSearchReq *ns1__BMButtonSearchReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BMButtonSearch */
        int soap_type() const { return SOAP_TYPE___ns1__BMButtonSearch; }
        /** Constructor with member initializations */
        __ns1__BMButtonSearch() : ns1__BMButtonSearchReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BMButtonSearch * SOAP_FMAC2 soap_instantiate___ns1__BMButtonSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27236 */
#ifndef SOAP_TYPE___ns1__BillUser
#define SOAP_TYPE___ns1__BillUser (1011)
/* Wrapper: */
struct SOAP_CMAC __ns1__BillUser {
      public:
        /** Optional element 'ns1:BillUserReq' of XSD type 'ns1:BillUserReq' */
        _ns1__BillUserReq *ns1__BillUserReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BillUser */
        int soap_type() const { return SOAP_TYPE___ns1__BillUser; }
        /** Constructor with member initializations */
        __ns1__BillUser() : ns1__BillUserReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BillUser * SOAP_FMAC2 soap_instantiate___ns1__BillUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27312 */
#ifndef SOAP_TYPE___ns1__TransactionSearch
#define SOAP_TYPE___ns1__TransactionSearch (1015)
/* Wrapper: */
struct SOAP_CMAC __ns1__TransactionSearch {
      public:
        /** Optional element 'ns1:TransactionSearchReq' of XSD type 'ns1:TransactionSearchReq' */
        _ns1__TransactionSearchReq *ns1__TransactionSearchReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__TransactionSearch */
        int soap_type() const { return SOAP_TYPE___ns1__TransactionSearch; }
        /** Constructor with member initializations */
        __ns1__TransactionSearch() : ns1__TransactionSearchReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__TransactionSearch * SOAP_FMAC2 soap_instantiate___ns1__TransactionSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27388 */
#ifndef SOAP_TYPE___ns1__MassPay
#define SOAP_TYPE___ns1__MassPay (1019)
/* Wrapper: */
struct SOAP_CMAC __ns1__MassPay {
      public:
        /** Optional element 'ns1:MassPayReq' of XSD type 'ns1:MassPayReq' */
        _ns1__MassPayReq *ns1__MassPayReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__MassPay */
        int soap_type() const { return SOAP_TYPE___ns1__MassPay; }
        /** Constructor with member initializations */
        __ns1__MassPay() : ns1__MassPayReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__MassPay * SOAP_FMAC2 soap_instantiate___ns1__MassPay(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27464 */
#ifndef SOAP_TYPE___ns1__BillAgreementUpdate
#define SOAP_TYPE___ns1__BillAgreementUpdate (1023)
/* Wrapper: */
struct SOAP_CMAC __ns1__BillAgreementUpdate {
      public:
        /** Optional element 'ns1:BillAgreementUpdateReq' of XSD type 'ns1:BillAgreementUpdateReq' */
        _ns1__BillAgreementUpdateReq *ns1__BillAgreementUpdateReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BillAgreementUpdate */
        int soap_type() const { return SOAP_TYPE___ns1__BillAgreementUpdate; }
        /** Constructor with member initializations */
        __ns1__BillAgreementUpdate() : ns1__BillAgreementUpdateReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BillAgreementUpdate * SOAP_FMAC2 soap_instantiate___ns1__BillAgreementUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27540 */
#ifndef SOAP_TYPE___ns1__AddressVerify
#define SOAP_TYPE___ns1__AddressVerify (1027)
/* Wrapper: */
struct SOAP_CMAC __ns1__AddressVerify {
      public:
        /** Optional element 'ns1:AddressVerifyReq' of XSD type 'ns1:AddressVerifyReq' */
        _ns1__AddressVerifyReq *ns1__AddressVerifyReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AddressVerify */
        int soap_type() const { return SOAP_TYPE___ns1__AddressVerify; }
        /** Constructor with member initializations */
        __ns1__AddressVerify() : ns1__AddressVerifyReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__AddressVerify * SOAP_FMAC2 soap_instantiate___ns1__AddressVerify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27616 */
#ifndef SOAP_TYPE___ns1__EnterBoarding
#define SOAP_TYPE___ns1__EnterBoarding (1031)
/* Wrapper: */
struct SOAP_CMAC __ns1__EnterBoarding {
      public:
        /** Optional element 'ns1:EnterBoardingReq' of XSD type 'ns1:EnterBoardingReq' */
        _ns1__EnterBoardingReq *ns1__EnterBoardingReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EnterBoarding */
        int soap_type() const { return SOAP_TYPE___ns1__EnterBoarding; }
        /** Constructor with member initializations */
        __ns1__EnterBoarding() : ns1__EnterBoardingReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EnterBoarding * SOAP_FMAC2 soap_instantiate___ns1__EnterBoarding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27692 */
#ifndef SOAP_TYPE___ns1__GetBoardingDetails
#define SOAP_TYPE___ns1__GetBoardingDetails (1035)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetBoardingDetails {
      public:
        /** Optional element 'ns1:GetBoardingDetailsReq' of XSD type 'ns1:GetBoardingDetailsReq' */
        _ns1__GetBoardingDetailsReq *ns1__GetBoardingDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetBoardingDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetBoardingDetails; }
        /** Constructor with member initializations */
        __ns1__GetBoardingDetails() : ns1__GetBoardingDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetBoardingDetails * SOAP_FMAC2 soap_instantiate___ns1__GetBoardingDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27768 */
#ifndef SOAP_TYPE___ns1__CreateMobilePayment
#define SOAP_TYPE___ns1__CreateMobilePayment (1039)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateMobilePayment {
      public:
        /** Optional element 'ns1:CreateMobilePaymentReq' of XSD type 'ns1:CreateMobilePaymentReq' */
        _ns1__CreateMobilePaymentReq *ns1__CreateMobilePaymentReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateMobilePayment */
        int soap_type() const { return SOAP_TYPE___ns1__CreateMobilePayment; }
        /** Constructor with member initializations */
        __ns1__CreateMobilePayment() : ns1__CreateMobilePaymentReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CreateMobilePayment * SOAP_FMAC2 soap_instantiate___ns1__CreateMobilePayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27844 */
#ifndef SOAP_TYPE___ns1__GetMobileStatus
#define SOAP_TYPE___ns1__GetMobileStatus (1043)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMobileStatus {
      public:
        /** Optional element 'ns1:GetMobileStatusReq' of XSD type 'ns1:GetMobileStatusReq' */
        _ns1__GetMobileStatusReq *ns1__GetMobileStatusReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMobileStatus */
        int soap_type() const { return SOAP_TYPE___ns1__GetMobileStatus; }
        /** Constructor with member initializations */
        __ns1__GetMobileStatus() : ns1__GetMobileStatusReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMobileStatus * SOAP_FMAC2 soap_instantiate___ns1__GetMobileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27920 */
#ifndef SOAP_TYPE___ns1__SetMobileCheckout
#define SOAP_TYPE___ns1__SetMobileCheckout (1047)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetMobileCheckout {
      public:
        /** Optional element 'ns1:SetMobileCheckoutReq' of XSD type 'ns1:SetMobileCheckoutReq' */
        _ns1__SetMobileCheckoutReq *ns1__SetMobileCheckoutReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetMobileCheckout */
        int soap_type() const { return SOAP_TYPE___ns1__SetMobileCheckout; }
        /** Constructor with member initializations */
        __ns1__SetMobileCheckout() : ns1__SetMobileCheckoutReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetMobileCheckout * SOAP_FMAC2 soap_instantiate___ns1__SetMobileCheckout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:27996 */
#ifndef SOAP_TYPE___ns1__DoMobileCheckoutPayment
#define SOAP_TYPE___ns1__DoMobileCheckoutPayment (1051)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoMobileCheckoutPayment {
      public:
        /** Optional element 'ns1:DoMobileCheckoutPaymentReq' of XSD type 'ns1:DoMobileCheckoutPaymentReq' */
        _ns1__DoMobileCheckoutPaymentReq *ns1__DoMobileCheckoutPaymentReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoMobileCheckoutPayment */
        int soap_type() const { return SOAP_TYPE___ns1__DoMobileCheckoutPayment; }
        /** Constructor with member initializations */
        __ns1__DoMobileCheckoutPayment() : ns1__DoMobileCheckoutPaymentReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoMobileCheckoutPayment * SOAP_FMAC2 soap_instantiate___ns1__DoMobileCheckoutPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28072 */
#ifndef SOAP_TYPE___ns1__GetBalance
#define SOAP_TYPE___ns1__GetBalance (1055)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetBalance {
      public:
        /** Optional element 'ns1:GetBalanceReq' of XSD type 'ns1:GetBalanceReq' */
        _ns1__GetBalanceReq *ns1__GetBalanceReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetBalance */
        int soap_type() const { return SOAP_TYPE___ns1__GetBalance; }
        /** Constructor with member initializations */
        __ns1__GetBalance() : ns1__GetBalanceReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetBalance * SOAP_FMAC2 soap_instantiate___ns1__GetBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28148 */
#ifndef SOAP_TYPE___ns1__GetPalDetails
#define SOAP_TYPE___ns1__GetPalDetails (1059)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPalDetails {
      public:
        /** Optional element 'ns1:GetPalDetailsReq' of XSD type 'ns1:GetPalDetailsReq' */
        _ns1__GetPalDetailsReq *ns1__GetPalDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPalDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetPalDetails; }
        /** Constructor with member initializations */
        __ns1__GetPalDetails() : ns1__GetPalDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetPalDetails * SOAP_FMAC2 soap_instantiate___ns1__GetPalDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28224 */
#ifndef SOAP_TYPE___ns1__DoExpressCheckoutPayment
#define SOAP_TYPE___ns1__DoExpressCheckoutPayment (1063)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoExpressCheckoutPayment {
      public:
        /** Optional element 'ns1:DoExpressCheckoutPaymentReq' of XSD type 'ns1:DoExpressCheckoutPaymentReq' */
        _ns1__DoExpressCheckoutPaymentReq *ns1__DoExpressCheckoutPaymentReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoExpressCheckoutPayment */
        int soap_type() const { return SOAP_TYPE___ns1__DoExpressCheckoutPayment; }
        /** Constructor with member initializations */
        __ns1__DoExpressCheckoutPayment() : ns1__DoExpressCheckoutPaymentReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoExpressCheckoutPayment * SOAP_FMAC2 soap_instantiate___ns1__DoExpressCheckoutPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28300 */
#ifndef SOAP_TYPE___ns1__DoUATPExpressCheckoutPayment
#define SOAP_TYPE___ns1__DoUATPExpressCheckoutPayment (1067)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoUATPExpressCheckoutPayment {
      public:
        /** Optional element 'ns1:DoUATPExpressCheckoutPaymentReq' of XSD type 'ns1:DoUATPExpressCheckoutPaymentReq' */
        _ns1__DoUATPExpressCheckoutPaymentReq *ns1__DoUATPExpressCheckoutPaymentReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoUATPExpressCheckoutPayment */
        int soap_type() const { return SOAP_TYPE___ns1__DoUATPExpressCheckoutPayment; }
        /** Constructor with member initializations */
        __ns1__DoUATPExpressCheckoutPayment() : ns1__DoUATPExpressCheckoutPaymentReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoUATPExpressCheckoutPayment * SOAP_FMAC2 soap_instantiate___ns1__DoUATPExpressCheckoutPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28376 */
#ifndef SOAP_TYPE___ns1__SetAuthFlowParam
#define SOAP_TYPE___ns1__SetAuthFlowParam (1071)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetAuthFlowParam {
      public:
        /** Optional element 'ns1:SetAuthFlowParamReq' of XSD type 'ns1:SetAuthFlowParamReq' */
        _ns1__SetAuthFlowParamReq *ns1__SetAuthFlowParamReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAuthFlowParam */
        int soap_type() const { return SOAP_TYPE___ns1__SetAuthFlowParam; }
        /** Constructor with member initializations */
        __ns1__SetAuthFlowParam() : ns1__SetAuthFlowParamReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetAuthFlowParam * SOAP_FMAC2 soap_instantiate___ns1__SetAuthFlowParam(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28452 */
#ifndef SOAP_TYPE___ns1__GetAuthDetails
#define SOAP_TYPE___ns1__GetAuthDetails (1075)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAuthDetails {
      public:
        /** Optional element 'ns1:GetAuthDetailsReq' of XSD type 'ns1:GetAuthDetailsReq' */
        _ns1__GetAuthDetailsReq *ns1__GetAuthDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAuthDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetAuthDetails; }
        /** Constructor with member initializations */
        __ns1__GetAuthDetails() : ns1__GetAuthDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAuthDetails * SOAP_FMAC2 soap_instantiate___ns1__GetAuthDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28528 */
#ifndef SOAP_TYPE___ns1__SetAccessPermissions
#define SOAP_TYPE___ns1__SetAccessPermissions (1079)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetAccessPermissions {
      public:
        /** Optional element 'ns1:SetAccessPermissionsReq' of XSD type 'ns1:SetAccessPermissionsReq' */
        _ns1__SetAccessPermissionsReq *ns1__SetAccessPermissionsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAccessPermissions */
        int soap_type() const { return SOAP_TYPE___ns1__SetAccessPermissions; }
        /** Constructor with member initializations */
        __ns1__SetAccessPermissions() : ns1__SetAccessPermissionsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetAccessPermissions * SOAP_FMAC2 soap_instantiate___ns1__SetAccessPermissions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28604 */
#ifndef SOAP_TYPE___ns1__UpdateAccessPermissions
#define SOAP_TYPE___ns1__UpdateAccessPermissions (1083)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdateAccessPermissions {
      public:
        /** Optional element 'ns1:UpdateAccessPermissionsReq' of XSD type 'ns1:UpdateAccessPermissionsReq' */
        _ns1__UpdateAccessPermissionsReq *ns1__UpdateAccessPermissionsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdateAccessPermissions */
        int soap_type() const { return SOAP_TYPE___ns1__UpdateAccessPermissions; }
        /** Constructor with member initializations */
        __ns1__UpdateAccessPermissions() : ns1__UpdateAccessPermissionsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdateAccessPermissions * SOAP_FMAC2 soap_instantiate___ns1__UpdateAccessPermissions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28680 */
#ifndef SOAP_TYPE___ns1__GetAccessPermissionDetails
#define SOAP_TYPE___ns1__GetAccessPermissionDetails (1087)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAccessPermissionDetails {
      public:
        /** Optional element 'ns1:GetAccessPermissionDetailsReq' of XSD type 'ns1:GetAccessPermissionDetailsReq' */
        _ns1__GetAccessPermissionDetailsReq *ns1__GetAccessPermissionDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAccessPermissionDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetAccessPermissionDetails; }
        /** Constructor with member initializations */
        __ns1__GetAccessPermissionDetails() : ns1__GetAccessPermissionDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetAccessPermissionDetails * SOAP_FMAC2 soap_instantiate___ns1__GetAccessPermissionDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28756 */
#ifndef SOAP_TYPE___ns1__GetIncentiveEvaluation
#define SOAP_TYPE___ns1__GetIncentiveEvaluation (1091)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetIncentiveEvaluation {
      public:
        /** Optional element 'ns1:GetIncentiveEvaluationReq' of XSD type 'ns1:GetIncentiveEvaluationReq' */
        _ns1__GetIncentiveEvaluationReq *ns1__GetIncentiveEvaluationReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetIncentiveEvaluation */
        int soap_type() const { return SOAP_TYPE___ns1__GetIncentiveEvaluation; }
        /** Constructor with member initializations */
        __ns1__GetIncentiveEvaluation() : ns1__GetIncentiveEvaluationReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetIncentiveEvaluation * SOAP_FMAC2 soap_instantiate___ns1__GetIncentiveEvaluation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28832 */
#ifndef SOAP_TYPE___ns1__SetExpressCheckout
#define SOAP_TYPE___ns1__SetExpressCheckout (1095)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetExpressCheckout {
      public:
        /** Optional element 'ns1:SetExpressCheckoutReq' of XSD type 'ns1:SetExpressCheckoutReq' */
        _ns1__SetExpressCheckoutReq *ns1__SetExpressCheckoutReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetExpressCheckout */
        int soap_type() const { return SOAP_TYPE___ns1__SetExpressCheckout; }
        /** Constructor with member initializations */
        __ns1__SetExpressCheckout() : ns1__SetExpressCheckoutReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetExpressCheckout * SOAP_FMAC2 soap_instantiate___ns1__SetExpressCheckout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28908 */
#ifndef SOAP_TYPE___ns1__ExecuteCheckoutOperations
#define SOAP_TYPE___ns1__ExecuteCheckoutOperations (1099)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExecuteCheckoutOperations {
      public:
        /** Optional element 'ns1:ExecuteCheckoutOperationsReq' of XSD type 'ns1:ExecuteCheckoutOperationsReq' */
        _ns1__ExecuteCheckoutOperationsReq *ns1__ExecuteCheckoutOperationsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExecuteCheckoutOperations */
        int soap_type() const { return SOAP_TYPE___ns1__ExecuteCheckoutOperations; }
        /** Constructor with member initializations */
        __ns1__ExecuteCheckoutOperations() : ns1__ExecuteCheckoutOperationsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ExecuteCheckoutOperations * SOAP_FMAC2 soap_instantiate___ns1__ExecuteCheckoutOperations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:28984 */
#ifndef SOAP_TYPE___ns1__GetExpressCheckoutDetails
#define SOAP_TYPE___ns1__GetExpressCheckoutDetails (1103)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetExpressCheckoutDetails {
      public:
        /** Optional element 'ns1:GetExpressCheckoutDetailsReq' of XSD type 'ns1:GetExpressCheckoutDetailsReq' */
        _ns1__GetExpressCheckoutDetailsReq *ns1__GetExpressCheckoutDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetExpressCheckoutDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetExpressCheckoutDetails; }
        /** Constructor with member initializations */
        __ns1__GetExpressCheckoutDetails() : ns1__GetExpressCheckoutDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetExpressCheckoutDetails * SOAP_FMAC2 soap_instantiate___ns1__GetExpressCheckoutDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29060 */
#ifndef SOAP_TYPE___ns1__DoDirectPayment
#define SOAP_TYPE___ns1__DoDirectPayment (1107)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoDirectPayment {
      public:
        /** Optional element 'ns1:DoDirectPaymentReq' of XSD type 'ns1:DoDirectPaymentReq' */
        _ns1__DoDirectPaymentReq *ns1__DoDirectPaymentReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoDirectPayment */
        int soap_type() const { return SOAP_TYPE___ns1__DoDirectPayment; }
        /** Constructor with member initializations */
        __ns1__DoDirectPayment() : ns1__DoDirectPaymentReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoDirectPayment * SOAP_FMAC2 soap_instantiate___ns1__DoDirectPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29136 */
#ifndef SOAP_TYPE___ns1__ManagePendingTransactionStatus
#define SOAP_TYPE___ns1__ManagePendingTransactionStatus (1111)
/* Wrapper: */
struct SOAP_CMAC __ns1__ManagePendingTransactionStatus {
      public:
        /** Optional element 'ns1:ManagePendingTransactionStatusReq' of XSD type 'ns1:ManagePendingTransactionStatusReq' */
        _ns1__ManagePendingTransactionStatusReq *ns1__ManagePendingTransactionStatusReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ManagePendingTransactionStatus */
        int soap_type() const { return SOAP_TYPE___ns1__ManagePendingTransactionStatus; }
        /** Constructor with member initializations */
        __ns1__ManagePendingTransactionStatus() : ns1__ManagePendingTransactionStatusReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ManagePendingTransactionStatus * SOAP_FMAC2 soap_instantiate___ns1__ManagePendingTransactionStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29212 */
#ifndef SOAP_TYPE___ns1__DoCancel
#define SOAP_TYPE___ns1__DoCancel (1115)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoCancel {
      public:
        /** Optional element 'ns1:DoCancelReq' of XSD type 'ns1:DoCancelReq' */
        _ns1__DoCancelReq *ns1__DoCancelReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoCancel */
        int soap_type() const { return SOAP_TYPE___ns1__DoCancel; }
        /** Constructor with member initializations */
        __ns1__DoCancel() : ns1__DoCancelReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoCancel * SOAP_FMAC2 soap_instantiate___ns1__DoCancel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29288 */
#ifndef SOAP_TYPE___ns1__DoCapture
#define SOAP_TYPE___ns1__DoCapture (1119)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoCapture {
      public:
        /** Optional element 'ns1:DoCaptureReq' of XSD type 'ns1:DoCaptureReq' */
        _ns1__DoCaptureReq *ns1__DoCaptureReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoCapture */
        int soap_type() const { return SOAP_TYPE___ns1__DoCapture; }
        /** Constructor with member initializations */
        __ns1__DoCapture() : ns1__DoCaptureReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoCapture * SOAP_FMAC2 soap_instantiate___ns1__DoCapture(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29364 */
#ifndef SOAP_TYPE___ns1__DoReauthorization
#define SOAP_TYPE___ns1__DoReauthorization (1123)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoReauthorization {
      public:
        /** Optional element 'ns1:DoReauthorizationReq' of XSD type 'ns1:DoReauthorizationReq' */
        _ns1__DoReauthorizationReq *ns1__DoReauthorizationReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoReauthorization */
        int soap_type() const { return SOAP_TYPE___ns1__DoReauthorization; }
        /** Constructor with member initializations */
        __ns1__DoReauthorization() : ns1__DoReauthorizationReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoReauthorization * SOAP_FMAC2 soap_instantiate___ns1__DoReauthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29440 */
#ifndef SOAP_TYPE___ns1__DoVoid
#define SOAP_TYPE___ns1__DoVoid (1127)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoVoid {
      public:
        /** Optional element 'ns1:DoVoidReq' of XSD type 'ns1:DoVoidReq' */
        _ns1__DoVoidReq *ns1__DoVoidReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoVoid */
        int soap_type() const { return SOAP_TYPE___ns1__DoVoid; }
        /** Constructor with member initializations */
        __ns1__DoVoid() : ns1__DoVoidReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoVoid * SOAP_FMAC2 soap_instantiate___ns1__DoVoid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29516 */
#ifndef SOAP_TYPE___ns1__DoAuthorization
#define SOAP_TYPE___ns1__DoAuthorization (1131)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoAuthorization {
      public:
        /** Optional element 'ns1:DoAuthorizationReq' of XSD type 'ns1:DoAuthorizationReq' */
        _ns1__DoAuthorizationReq *ns1__DoAuthorizationReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoAuthorization */
        int soap_type() const { return SOAP_TYPE___ns1__DoAuthorization; }
        /** Constructor with member initializations */
        __ns1__DoAuthorization() : ns1__DoAuthorizationReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoAuthorization * SOAP_FMAC2 soap_instantiate___ns1__DoAuthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29592 */
#ifndef SOAP_TYPE___ns1__UpdateAuthorization
#define SOAP_TYPE___ns1__UpdateAuthorization (1135)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdateAuthorization {
      public:
        /** Optional element 'ns1:UpdateAuthorizationReq' of XSD type 'ns1:UpdateAuthorizationReq' */
        _ns1__UpdateAuthorizationReq *ns1__UpdateAuthorizationReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdateAuthorization */
        int soap_type() const { return SOAP_TYPE___ns1__UpdateAuthorization; }
        /** Constructor with member initializations */
        __ns1__UpdateAuthorization() : ns1__UpdateAuthorizationReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdateAuthorization * SOAP_FMAC2 soap_instantiate___ns1__UpdateAuthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29668 */
#ifndef SOAP_TYPE___ns1__DoUATPAuthorization
#define SOAP_TYPE___ns1__DoUATPAuthorization (1139)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoUATPAuthorization {
      public:
        /** Optional element 'ns1:DoUATPAuthorizationReq' of XSD type 'ns1:DoUATPAuthorizationReq' */
        _ns1__DoUATPAuthorizationReq *ns1__DoUATPAuthorizationReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoUATPAuthorization */
        int soap_type() const { return SOAP_TYPE___ns1__DoUATPAuthorization; }
        /** Constructor with member initializations */
        __ns1__DoUATPAuthorization() : ns1__DoUATPAuthorizationReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoUATPAuthorization * SOAP_FMAC2 soap_instantiate___ns1__DoUATPAuthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29744 */
#ifndef SOAP_TYPE___ns1__SetCustomerBillingAgreement
#define SOAP_TYPE___ns1__SetCustomerBillingAgreement (1143)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetCustomerBillingAgreement {
      public:
        /** Optional element 'ns1:SetCustomerBillingAgreementReq' of XSD type 'ns1:SetCustomerBillingAgreementReq' */
        _ns1__SetCustomerBillingAgreementReq *ns1__SetCustomerBillingAgreementReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetCustomerBillingAgreement */
        int soap_type() const { return SOAP_TYPE___ns1__SetCustomerBillingAgreement; }
        /** Constructor with member initializations */
        __ns1__SetCustomerBillingAgreement() : ns1__SetCustomerBillingAgreementReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetCustomerBillingAgreement * SOAP_FMAC2 soap_instantiate___ns1__SetCustomerBillingAgreement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29820 */
#ifndef SOAP_TYPE___ns1__GetBillingAgreementCustomerDetails
#define SOAP_TYPE___ns1__GetBillingAgreementCustomerDetails (1147)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetBillingAgreementCustomerDetails {
      public:
        /** Optional element 'ns1:GetBillingAgreementCustomerDetailsReq' of XSD type 'ns1:GetBillingAgreementCustomerDetailsReq' */
        _ns1__GetBillingAgreementCustomerDetailsReq *ns1__GetBillingAgreementCustomerDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetBillingAgreementCustomerDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetBillingAgreementCustomerDetails; }
        /** Constructor with member initializations */
        __ns1__GetBillingAgreementCustomerDetails() : ns1__GetBillingAgreementCustomerDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetBillingAgreementCustomerDetails * SOAP_FMAC2 soap_instantiate___ns1__GetBillingAgreementCustomerDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29896 */
#ifndef SOAP_TYPE___ns1__CreateBillingAgreement
#define SOAP_TYPE___ns1__CreateBillingAgreement (1151)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateBillingAgreement {
      public:
        /** Optional element 'ns1:CreateBillingAgreementReq' of XSD type 'ns1:CreateBillingAgreementReq' */
        _ns1__CreateBillingAgreementReq *ns1__CreateBillingAgreementReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateBillingAgreement */
        int soap_type() const { return SOAP_TYPE___ns1__CreateBillingAgreement; }
        /** Constructor with member initializations */
        __ns1__CreateBillingAgreement() : ns1__CreateBillingAgreementReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CreateBillingAgreement * SOAP_FMAC2 soap_instantiate___ns1__CreateBillingAgreement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:29972 */
#ifndef SOAP_TYPE___ns1__DoReferenceTransaction
#define SOAP_TYPE___ns1__DoReferenceTransaction (1155)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoReferenceTransaction {
      public:
        /** Optional element 'ns1:DoReferenceTransactionReq' of XSD type 'ns1:DoReferenceTransactionReq' */
        _ns1__DoReferenceTransactionReq *ns1__DoReferenceTransactionReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoReferenceTransaction */
        int soap_type() const { return SOAP_TYPE___ns1__DoReferenceTransaction; }
        /** Constructor with member initializations */
        __ns1__DoReferenceTransaction() : ns1__DoReferenceTransactionReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoReferenceTransaction * SOAP_FMAC2 soap_instantiate___ns1__DoReferenceTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30048 */
#ifndef SOAP_TYPE___ns1__CreateRecurringPaymentsProfile
#define SOAP_TYPE___ns1__CreateRecurringPaymentsProfile (1159)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateRecurringPaymentsProfile {
      public:
        /** Optional element 'ns1:CreateRecurringPaymentsProfileReq' of XSD type 'ns1:CreateRecurringPaymentsProfileReq' */
        _ns1__CreateRecurringPaymentsProfileReq *ns1__CreateRecurringPaymentsProfileReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateRecurringPaymentsProfile */
        int soap_type() const { return SOAP_TYPE___ns1__CreateRecurringPaymentsProfile; }
        /** Constructor with member initializations */
        __ns1__CreateRecurringPaymentsProfile() : ns1__CreateRecurringPaymentsProfileReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CreateRecurringPaymentsProfile * SOAP_FMAC2 soap_instantiate___ns1__CreateRecurringPaymentsProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30124 */
#ifndef SOAP_TYPE___ns1__GetRecurringPaymentsProfileDetails
#define SOAP_TYPE___ns1__GetRecurringPaymentsProfileDetails (1163)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRecurringPaymentsProfileDetails {
      public:
        /** Optional element 'ns1:GetRecurringPaymentsProfileDetailsReq' of XSD type 'ns1:GetRecurringPaymentsProfileDetailsReq' */
        _ns1__GetRecurringPaymentsProfileDetailsReq *ns1__GetRecurringPaymentsProfileDetailsReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRecurringPaymentsProfileDetails */
        int soap_type() const { return SOAP_TYPE___ns1__GetRecurringPaymentsProfileDetails; }
        /** Constructor with member initializations */
        __ns1__GetRecurringPaymentsProfileDetails() : ns1__GetRecurringPaymentsProfileDetailsReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetRecurringPaymentsProfileDetails * SOAP_FMAC2 soap_instantiate___ns1__GetRecurringPaymentsProfileDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30200 */
#ifndef SOAP_TYPE___ns1__ManageRecurringPaymentsProfileStatus
#define SOAP_TYPE___ns1__ManageRecurringPaymentsProfileStatus (1167)
/* Wrapper: */
struct SOAP_CMAC __ns1__ManageRecurringPaymentsProfileStatus {
      public:
        /** Optional element 'ns1:ManageRecurringPaymentsProfileStatusReq' of XSD type 'ns1:ManageRecurringPaymentsProfileStatusReq' */
        _ns1__ManageRecurringPaymentsProfileStatusReq *ns1__ManageRecurringPaymentsProfileStatusReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ManageRecurringPaymentsProfileStatus */
        int soap_type() const { return SOAP_TYPE___ns1__ManageRecurringPaymentsProfileStatus; }
        /** Constructor with member initializations */
        __ns1__ManageRecurringPaymentsProfileStatus() : ns1__ManageRecurringPaymentsProfileStatusReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ManageRecurringPaymentsProfileStatus * SOAP_FMAC2 soap_instantiate___ns1__ManageRecurringPaymentsProfileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30276 */
#ifndef SOAP_TYPE___ns1__BillOutstandingAmount
#define SOAP_TYPE___ns1__BillOutstandingAmount (1171)
/* Wrapper: */
struct SOAP_CMAC __ns1__BillOutstandingAmount {
      public:
        /** Optional element 'ns1:BillOutstandingAmountReq' of XSD type 'ns1:BillOutstandingAmountReq' */
        _ns1__BillOutstandingAmountReq *ns1__BillOutstandingAmountReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BillOutstandingAmount */
        int soap_type() const { return SOAP_TYPE___ns1__BillOutstandingAmount; }
        /** Constructor with member initializations */
        __ns1__BillOutstandingAmount() : ns1__BillOutstandingAmountReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BillOutstandingAmount * SOAP_FMAC2 soap_instantiate___ns1__BillOutstandingAmount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30352 */
#ifndef SOAP_TYPE___ns1__UpdateRecurringPaymentsProfile
#define SOAP_TYPE___ns1__UpdateRecurringPaymentsProfile (1175)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpdateRecurringPaymentsProfile {
      public:
        /** Optional element 'ns1:UpdateRecurringPaymentsProfileReq' of XSD type 'ns1:UpdateRecurringPaymentsProfileReq' */
        _ns1__UpdateRecurringPaymentsProfileReq *ns1__UpdateRecurringPaymentsProfileReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdateRecurringPaymentsProfile */
        int soap_type() const { return SOAP_TYPE___ns1__UpdateRecurringPaymentsProfile; }
        /** Constructor with member initializations */
        __ns1__UpdateRecurringPaymentsProfile() : ns1__UpdateRecurringPaymentsProfileReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UpdateRecurringPaymentsProfile * SOAP_FMAC2 soap_instantiate___ns1__UpdateRecurringPaymentsProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30428 */
#ifndef SOAP_TYPE___ns1__DoNonReferencedCredit
#define SOAP_TYPE___ns1__DoNonReferencedCredit (1179)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoNonReferencedCredit {
      public:
        /** Optional element 'ns1:DoNonReferencedCreditReq' of XSD type 'ns1:DoNonReferencedCreditReq' */
        _ns1__DoNonReferencedCreditReq *ns1__DoNonReferencedCreditReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoNonReferencedCredit */
        int soap_type() const { return SOAP_TYPE___ns1__DoNonReferencedCredit; }
        /** Constructor with member initializations */
        __ns1__DoNonReferencedCredit() : ns1__DoNonReferencedCreditReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoNonReferencedCredit * SOAP_FMAC2 soap_instantiate___ns1__DoNonReferencedCredit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30504 */
#ifndef SOAP_TYPE___ns1__ReverseTransaction
#define SOAP_TYPE___ns1__ReverseTransaction (1183)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReverseTransaction {
      public:
        /** Optional element 'ns1:ReverseTransactionReq' of XSD type 'ns1:ReverseTransactionReq' */
        _ns1__ReverseTransactionReq *ns1__ReverseTransactionReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReverseTransaction */
        int soap_type() const { return SOAP_TYPE___ns1__ReverseTransaction; }
        /** Constructor with member initializations */
        __ns1__ReverseTransaction() : ns1__ReverseTransactionReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ReverseTransaction * SOAP_FMAC2 soap_instantiate___ns1__ReverseTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:30580 */
#ifndef SOAP_TYPE___ns1__ExternalRememberMeOptOut
#define SOAP_TYPE___ns1__ExternalRememberMeOptOut (1187)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExternalRememberMeOptOut {
      public:
        /** Optional element 'ns1:ExternalRememberMeOptOutReq' of XSD type 'ns1:ExternalRememberMeOptOutReq' */
        _ns1__ExternalRememberMeOptOutReq *ns1__ExternalRememberMeOptOutReq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExternalRememberMeOptOut */
        int soap_type() const { return SOAP_TYPE___ns1__ExternalRememberMeOptOut; }
        /** Constructor with member initializations */
        __ns1__ExternalRememberMeOptOut() : ns1__ExternalRememberMeOptOutReq() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ExternalRememberMeOptOut * SOAP_FMAC2 soap_instantiate___ns1__ExternalRememberMeOptOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* paypal.h:31986 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1188)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* paypal.h:31986 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1190)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* paypal.h:31986 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1193)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* paypal.h:31986 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1194)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* paypal.h:164 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
typedef std::string xsd__anyURI;
#endif

/* paypal.h:167 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (13)
typedef std::string xsd__decimal;
#endif

/* paypal.h:170 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (14)
typedef std::string xsd__integer;
#endif

/* paypal.h:173 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (15)
typedef std::string xsd__token;
#endif

/* paypal.h:1369 */
#ifndef SOAP_TYPE_ns2__UUIDType
#define SOAP_TYPE_ns2__UUIDType (396)
typedef std::string ns2__UUIDType;
#endif

/* paypal.h:2326 */
#ifndef SOAP_TYPE_ns3__ItemIDType
#define SOAP_TYPE_ns3__ItemIDType (411)
typedef std::string ns3__ItemIDType;
#endif

/* paypal.h:2348 */
#ifndef SOAP_TYPE_ns3__UserIDType
#define SOAP_TYPE_ns3__UserIDType (413)
typedef std::string ns3__UserIDType;
#endif

/* paypal.h:3556 */
#ifndef SOAP_TYPE_ns3__NameType
#define SOAP_TYPE_ns3__NameType (447)
typedef std::string ns3__NameType;
#endif

/* paypal.h:3561 */
#ifndef SOAP_TYPE_ns3__SalutationType
#define SOAP_TYPE_ns3__SalutationType (448)
typedef std::string ns3__SalutationType;
#endif

/* paypal.h:3566 */
#ifndef SOAP_TYPE_ns3__SuffixType
#define SOAP_TYPE_ns3__SuffixType (449)
typedef std::string ns3__SuffixType;
#endif

/* paypal.h:3573 */
#ifndef SOAP_TYPE_ns3__TransactionId
#define SOAP_TYPE_ns3__TransactionId (450)
typedef std::string ns3__TransactionId;
#endif

/* paypal.h:3580 */
#ifndef SOAP_TYPE_ns3__AuthorizationId
#define SOAP_TYPE_ns3__AuthorizationId (451)
typedef std::string ns3__AuthorizationId;
#endif

/* paypal.h:3584 */
#ifndef SOAP_TYPE_ns3__MerchantPullIDType
#define SOAP_TYPE_ns3__MerchantPullIDType (452)
typedef std::string ns3__MerchantPullIDType;
#endif

/* paypal.h:3588 */
#ifndef SOAP_TYPE_ns3__EmailAddressType
#define SOAP_TYPE_ns3__EmailAddressType (453)
typedef std::string ns3__EmailAddressType;
#endif

/* paypal.h:3592 */
#ifndef SOAP_TYPE_ns3__ExpressCheckoutTokenType
#define SOAP_TYPE_ns3__ExpressCheckoutTokenType (454)
typedef std::string ns3__ExpressCheckoutTokenType;
#endif

/* paypal.h:3596 */
#ifndef SOAP_TYPE_ns3__AuthFlowTokenType
#define SOAP_TYPE_ns3__AuthFlowTokenType (455)
typedef std::string ns3__AuthFlowTokenType;
#endif

/* paypal.h:3600 */
#ifndef SOAP_TYPE_ns3__LanguageCodeType
#define SOAP_TYPE_ns3__LanguageCodeType (456)
typedef std::string ns3__LanguageCodeType;
#endif

/* paypal.h:3615 */
#ifndef SOAP_TYPE_ns3__OrderID
#define SOAP_TYPE_ns3__OrderID (458)
typedef std::string ns3__OrderID;
#endif

/* paypal.h:3641 */
#ifndef SOAP_TYPE_ns3__PaymentStatusIDCodeType
#define SOAP_TYPE_ns3__PaymentStatusIDCodeType (460)
typedef xsd__integer ns3__PaymentStatusIDCodeType;
#endif

/* paypal.h:4889 */
#ifndef SOAP_TYPE_ns3__EnterBoardingTokenType
#define SOAP_TYPE_ns3__EnterBoardingTokenType (508)
typedef std::string ns3__EnterBoardingTokenType;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (631)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (868)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (605)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (609)
#endif

/* enum ns3__WalletItemType has binding name 'ns3__WalletItemType' for type 'ns3:WalletItemType' */
#ifndef SOAP_TYPE_ns3__WalletItemType
#define SOAP_TYPE_ns3__WalletItemType (534)
#endif

/* enum ns3__LocationType has binding name 'ns3__LocationType' for type 'ns3:LocationType' */
#ifndef SOAP_TYPE_ns3__LocationType
#define SOAP_TYPE_ns3__LocationType (533)
#endif

/* enum ns3__PaymentCategoryType has binding name 'ns3__PaymentCategoryType' for type 'ns3:PaymentCategoryType' */
#ifndef SOAP_TYPE_ns3__PaymentCategoryType
#define SOAP_TYPE_ns3__PaymentCategoryType (532)
#endif

/* enum ns3__CoupleType has binding name 'ns3__CoupleType' for type 'ns3:CoupleType' */
#ifndef SOAP_TYPE_ns3__CoupleType
#define SOAP_TYPE_ns3__CoupleType (531)
#endif

/* enum ns3__RecurringFlagType has binding name 'ns3__RecurringFlagType' for type 'ns3:RecurringFlagType' */
#ifndef SOAP_TYPE_ns3__RecurringFlagType
#define SOAP_TYPE_ns3__RecurringFlagType (530)
#endif

/* enum ns3__ItemCategoryType has binding name 'ns3__ItemCategoryType' for type 'ns3:ItemCategoryType' */
#ifndef SOAP_TYPE_ns3__ItemCategoryType
#define SOAP_TYPE_ns3__ItemCategoryType (529)
#endif

/* enum ns3__UserSelectedFundingSourceType has binding name 'ns3__UserSelectedFundingSourceType' for type 'ns3:UserSelectedFundingSourceType' */
#ifndef SOAP_TYPE_ns3__UserSelectedFundingSourceType
#define SOAP_TYPE_ns3__UserSelectedFundingSourceType (528)
#endif

/* enum ns3__OptionTypeListType has binding name 'ns3__OptionTypeListType' for type 'ns3:OptionTypeListType' */
#ifndef SOAP_TYPE_ns3__OptionTypeListType
#define SOAP_TYPE_ns3__OptionTypeListType (527)
#endif

/* enum ns3__ButtonStatusType has binding name 'ns3__ButtonStatusType' for type 'ns3:ButtonStatusType' */
#ifndef SOAP_TYPE_ns3__ButtonStatusType
#define SOAP_TYPE_ns3__ButtonStatusType (526)
#endif

/* enum ns3__SubscribeTextType has binding name 'ns3__SubscribeTextType' for type 'ns3:SubscribeTextType' */
#ifndef SOAP_TYPE_ns3__SubscribeTextType
#define SOAP_TYPE_ns3__SubscribeTextType (525)
#endif

/* enum ns3__BuyNowTextType has binding name 'ns3__BuyNowTextType' for type 'ns3:BuyNowTextType' */
#ifndef SOAP_TYPE_ns3__BuyNowTextType
#define SOAP_TYPE_ns3__BuyNowTextType (524)
#endif

/* enum ns3__ButtonImageType has binding name 'ns3__ButtonImageType' for type 'ns3:ButtonImageType' */
#ifndef SOAP_TYPE_ns3__ButtonImageType
#define SOAP_TYPE_ns3__ButtonImageType (523)
#endif

/* enum ns3__ButtonSubTypeType has binding name 'ns3__ButtonSubTypeType' for type 'ns3:ButtonSubTypeType' */
#ifndef SOAP_TYPE_ns3__ButtonSubTypeType
#define SOAP_TYPE_ns3__ButtonSubTypeType (522)
#endif

/* enum ns3__ButtonTypeType has binding name 'ns3__ButtonTypeType' for type 'ns3:ButtonTypeType' */
#ifndef SOAP_TYPE_ns3__ButtonTypeType
#define SOAP_TYPE_ns3__ButtonTypeType (521)
#endif

/* enum ns3__ButtonCodeType has binding name 'ns3__ButtonCodeType' for type 'ns3:ButtonCodeType' */
#ifndef SOAP_TYPE_ns3__ButtonCodeType
#define SOAP_TYPE_ns3__ButtonCodeType (520)
#endif

/* enum ns3__ProductCategoryType has binding name 'ns3__ProductCategoryType' for type 'ns3:ProductCategoryType' */
#ifndef SOAP_TYPE_ns3__ProductCategoryType
#define SOAP_TYPE_ns3__ProductCategoryType (519)
#endif

/* enum ns3__BillingPeriodType has binding name 'ns3__BillingPeriodType' for type 'ns3:BillingPeriodType' */
#ifndef SOAP_TYPE_ns3__BillingPeriodType
#define SOAP_TYPE_ns3__BillingPeriodType (518)
#endif

/* enum ns3__StatusChangeActionType has binding name 'ns3__StatusChangeActionType' for type 'ns3:StatusChangeActionType' */
#ifndef SOAP_TYPE_ns3__StatusChangeActionType
#define SOAP_TYPE_ns3__StatusChangeActionType (517)
#endif

/* enum ns3__AutoBillType has binding name 'ns3__AutoBillType' for type 'ns3:AutoBillType' */
#ifndef SOAP_TYPE_ns3__AutoBillType
#define SOAP_TYPE_ns3__AutoBillType (516)
#endif

/* enum ns3__FailedPaymentActionType has binding name 'ns3__FailedPaymentActionType' for type 'ns3:FailedPaymentActionType' */
#ifndef SOAP_TYPE_ns3__FailedPaymentActionType
#define SOAP_TYPE_ns3__FailedPaymentActionType (515)
#endif

/* enum ns3__RecurringPaymentsProfileStatusType has binding name 'ns3__RecurringPaymentsProfileStatusType' for type 'ns3:RecurringPaymentsProfileStatusType' */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsProfileStatusType
#define SOAP_TYPE_ns3__RecurringPaymentsProfileStatusType (514)
#endif

/* enum ns3__DyneticClientType has binding name 'ns3__DyneticClientType' for type 'ns3:DyneticClientType' */
#ifndef SOAP_TYPE_ns3__DyneticClientType
#define SOAP_TYPE_ns3__DyneticClientType (513)
#endif

/* enum ns3__EbayCheckoutType has binding name 'ns3__EbayCheckoutType' for type 'ns3:EbayCheckoutType' */
#ifndef SOAP_TYPE_ns3__EbayCheckoutType
#define SOAP_TYPE_ns3__EbayCheckoutType (512)
#endif

/* enum ns3__APIAuthenticationType has binding name 'ns3__APIAuthenticationType' for type 'ns3:APIAuthenticationType' */
#ifndef SOAP_TYPE_ns3__APIAuthenticationType
#define SOAP_TYPE_ns3__APIAuthenticationType (511)
#endif

/* enum ns3__UserWithdrawalLimitTypeType has binding name 'ns3__UserWithdrawalLimitTypeType' for type 'ns3:UserWithdrawalLimitTypeType' */
#ifndef SOAP_TYPE_ns3__UserWithdrawalLimitTypeType
#define SOAP_TYPE_ns3__UserWithdrawalLimitTypeType (510)
#endif

/* enum ns3__BoardingStatusType has binding name 'ns3__BoardingStatusType' for type 'ns3:BoardingStatusType' */
#ifndef SOAP_TYPE_ns3__BoardingStatusType
#define SOAP_TYPE_ns3__BoardingStatusType (509)
#endif

/* enum ns3__BankAccountTypeType has binding name 'ns3__BankAccountTypeType' for type 'ns3:BankAccountTypeType' */
#ifndef SOAP_TYPE_ns3__BankAccountTypeType
#define SOAP_TYPE_ns3__BankAccountTypeType (507)
#endif

/* enum ns3__PercentageRevenueFromOnlineSalesType has binding name 'ns3__PercentageRevenueFromOnlineSalesType' for type 'ns3:PercentageRevenueFromOnlineSalesType' */
#ifndef SOAP_TYPE_ns3__PercentageRevenueFromOnlineSalesType
#define SOAP_TYPE_ns3__PercentageRevenueFromOnlineSalesType (506)
#endif

/* enum ns3__SalesVenueType has binding name 'ns3__SalesVenueType' for type 'ns3:SalesVenueType' */
#ifndef SOAP_TYPE_ns3__SalesVenueType
#define SOAP_TYPE_ns3__SalesVenueType (505)
#endif

/* enum ns3__AverageMonthlyVolumeType has binding name 'ns3__AverageMonthlyVolumeType' for type 'ns3:AverageMonthlyVolumeType' */
#ifndef SOAP_TYPE_ns3__AverageMonthlyVolumeType
#define SOAP_TYPE_ns3__AverageMonthlyVolumeType (504)
#endif

/* enum ns3__AverageTransactionPriceType has binding name 'ns3__AverageTransactionPriceType' for type 'ns3:AverageTransactionPriceType' */
#ifndef SOAP_TYPE_ns3__AverageTransactionPriceType
#define SOAP_TYPE_ns3__AverageTransactionPriceType (503)
#endif

/* enum ns3__BusinessSubCategoryType has binding name 'ns3__BusinessSubCategoryType' for type 'ns3:BusinessSubCategoryType' */
#ifndef SOAP_TYPE_ns3__BusinessSubCategoryType
#define SOAP_TYPE_ns3__BusinessSubCategoryType (502)
#endif

/* enum ns3__BusinessCategoryType has binding name 'ns3__BusinessCategoryType' for type 'ns3:BusinessCategoryType' */
#ifndef SOAP_TYPE_ns3__BusinessCategoryType
#define SOAP_TYPE_ns3__BusinessCategoryType (501)
#endif

/* enum ns3__BusinessTypeType has binding name 'ns3__BusinessTypeType' for type 'ns3:BusinessTypeType' */
#ifndef SOAP_TYPE_ns3__BusinessTypeType
#define SOAP_TYPE_ns3__BusinessTypeType (500)
#endif

/* enum ns3__MarketingCategoryType has binding name 'ns3__MarketingCategoryType' for type 'ns3:MarketingCategoryType' */
#ifndef SOAP_TYPE_ns3__MarketingCategoryType
#define SOAP_TYPE_ns3__MarketingCategoryType (499)
#endif

/* enum ns3__MobilePaymentCodeType has binding name 'ns3__MobilePaymentCodeType' for type 'ns3:MobilePaymentCodeType' */
#ifndef SOAP_TYPE_ns3__MobilePaymentCodeType
#define SOAP_TYPE_ns3__MobilePaymentCodeType (498)
#endif

/* enum ns3__MobileRecipientCodeType has binding name 'ns3__MobileRecipientCodeType' for type 'ns3:MobileRecipientCodeType' */
#ifndef SOAP_TYPE_ns3__MobileRecipientCodeType
#define SOAP_TYPE_ns3__MobileRecipientCodeType (497)
#endif

/* enum ns3__TransactionEntityType has binding name 'ns3__TransactionEntityType' for type 'ns3:TransactionEntityType' */
#ifndef SOAP_TYPE_ns3__TransactionEntityType
#define SOAP_TYPE_ns3__TransactionEntityType (496)
#endif

/* enum ns3__CompleteCodeType has binding name 'ns3__CompleteCodeType' for type 'ns3:CompleteCodeType' */
#ifndef SOAP_TYPE_ns3__CompleteCodeType
#define SOAP_TYPE_ns3__CompleteCodeType (495)
#endif

/* enum ns3__MatchStatusCodeType has binding name 'ns3__MatchStatusCodeType' for type 'ns3:MatchStatusCodeType' */
#ifndef SOAP_TYPE_ns3__MatchStatusCodeType
#define SOAP_TYPE_ns3__MatchStatusCodeType (494)
#endif

/* enum ns3__PaymentTransactionClassCodeType has binding name 'ns3__PaymentTransactionClassCodeType' for type 'ns3:PaymentTransactionClassCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentTransactionClassCodeType
#define SOAP_TYPE_ns3__PaymentTransactionClassCodeType (493)
#endif

/* enum ns3__PaymentTransactionStatusCodeType has binding name 'ns3__PaymentTransactionStatusCodeType' for type 'ns3:PaymentTransactionStatusCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentTransactionStatusCodeType
#define SOAP_TYPE_ns3__PaymentTransactionStatusCodeType (492)
#endif

/* enum ns3__MerchantPullStatusCodeType has binding name 'ns3__MerchantPullStatusCodeType' for type 'ns3:MerchantPullStatusCodeType' */
#ifndef SOAP_TYPE_ns3__MerchantPullStatusCodeType
#define SOAP_TYPE_ns3__MerchantPullStatusCodeType (491)
#endif

/* enum ns3__MerchantPullPaymentCodeType has binding name 'ns3__MerchantPullPaymentCodeType' for type 'ns3:MerchantPullPaymentCodeType' */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentCodeType
#define SOAP_TYPE_ns3__MerchantPullPaymentCodeType (490)
#endif

/* enum ns3__PayPalUserStatusCodeType has binding name 'ns3__PayPalUserStatusCodeType' for type 'ns3:PayPalUserStatusCodeType' */
#ifndef SOAP_TYPE_ns3__PayPalUserStatusCodeType
#define SOAP_TYPE_ns3__PayPalUserStatusCodeType (489)
#endif

/* enum ns3__RefundSourceCodeType has binding name 'ns3__RefundSourceCodeType' for type 'ns3:RefundSourceCodeType' */
#ifndef SOAP_TYPE_ns3__RefundSourceCodeType
#define SOAP_TYPE_ns3__RefundSourceCodeType (488)
#endif

/* enum ns3__PaymentCodeType has binding name 'ns3__PaymentCodeType' for type 'ns3:PaymentCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentCodeType
#define SOAP_TYPE_ns3__PaymentCodeType (487)
#endif

/* enum ns3__POSTransactionCodeType has binding name 'ns3__POSTransactionCodeType' for type 'ns3:POSTransactionCodeType' */
#ifndef SOAP_TYPE_ns3__POSTransactionCodeType
#define SOAP_TYPE_ns3__POSTransactionCodeType (486)
#endif

/* enum ns3__ReversalReasonCodeType has binding name 'ns3__ReversalReasonCodeType' for type 'ns3:ReversalReasonCodeType' */
#ifndef SOAP_TYPE_ns3__ReversalReasonCodeType
#define SOAP_TYPE_ns3__ReversalReasonCodeType (485)
#endif

/* enum ns3__ReceiverInfoCodeType has binding name 'ns3__ReceiverInfoCodeType' for type 'ns3:ReceiverInfoCodeType' */
#ifndef SOAP_TYPE_ns3__ReceiverInfoCodeType
#define SOAP_TYPE_ns3__ReceiverInfoCodeType (484)
#endif

/* enum ns3__PendingStatusCodeType has binding name 'ns3__PendingStatusCodeType' for type 'ns3:PendingStatusCodeType' */
#ifndef SOAP_TYPE_ns3__PendingStatusCodeType
#define SOAP_TYPE_ns3__PendingStatusCodeType (483)
#endif

/* enum ns3__ApprovalSubTypeType has binding name 'ns3__ApprovalSubTypeType' for type 'ns3:ApprovalSubTypeType' */
#ifndef SOAP_TYPE_ns3__ApprovalSubTypeType
#define SOAP_TYPE_ns3__ApprovalSubTypeType (482)
#endif

/* enum ns3__ApprovalTypeType has binding name 'ns3__ApprovalTypeType' for type 'ns3:ApprovalTypeType' */
#ifndef SOAP_TYPE_ns3__ApprovalTypeType
#define SOAP_TYPE_ns3__ApprovalTypeType (481)
#endif

/* enum ns3__BillingCodeType has binding name 'ns3__BillingCodeType' for type 'ns3:BillingCodeType' */
#ifndef SOAP_TYPE_ns3__BillingCodeType
#define SOAP_TYPE_ns3__BillingCodeType (480)
#endif

/* enum ns3__LandingPageType has binding name 'ns3__LandingPageType' for type 'ns3:LandingPageType' */
#ifndef SOAP_TYPE_ns3__LandingPageType
#define SOAP_TYPE_ns3__LandingPageType (479)
#endif

/* enum ns3__AllowedPaymentMethodType has binding name 'ns3__AllowedPaymentMethodType' for type 'ns3:AllowedPaymentMethodType' */
#ifndef SOAP_TYPE_ns3__AllowedPaymentMethodType
#define SOAP_TYPE_ns3__AllowedPaymentMethodType (478)
#endif

/* enum ns3__SolutionTypeType has binding name 'ns3__SolutionTypeType' for type 'ns3:SolutionTypeType' */
#ifndef SOAP_TYPE_ns3__SolutionTypeType
#define SOAP_TYPE_ns3__SolutionTypeType (477)
#endif

/* enum ns3__TotalType has binding name 'ns3__TotalType' for type 'ns3:TotalType' */
#ifndef SOAP_TYPE_ns3__TotalType
#define SOAP_TYPE_ns3__TotalType (476)
#endif

/* enum ns3__ChannelType has binding name 'ns3__ChannelType' for type 'ns3:ChannelType' */
#ifndef SOAP_TYPE_ns3__ChannelType
#define SOAP_TYPE_ns3__ChannelType (475)
#endif

/* enum ns3__FMFPendingTransactionActionType has binding name 'ns3__FMFPendingTransactionActionType' for type 'ns3:FMFPendingTransactionActionType' */
#ifndef SOAP_TYPE_ns3__FMFPendingTransactionActionType
#define SOAP_TYPE_ns3__FMFPendingTransactionActionType (474)
#endif

/* enum ns3__PaymentActionCodeType has binding name 'ns3__PaymentActionCodeType' for type 'ns3:PaymentActionCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentActionCodeType
#define SOAP_TYPE_ns3__PaymentActionCodeType (473)
#endif

/* enum ns3__AddressNormalizationStatusCodeType has binding name 'ns3__AddressNormalizationStatusCodeType' for type 'ns3:AddressNormalizationStatusCodeType' */
#ifndef SOAP_TYPE_ns3__AddressNormalizationStatusCodeType
#define SOAP_TYPE_ns3__AddressNormalizationStatusCodeType (472)
#endif

/* enum ns3__AddressStatusCodeType has binding name 'ns3__AddressStatusCodeType' for type 'ns3:AddressStatusCodeType' */
#ifndef SOAP_TYPE_ns3__AddressStatusCodeType
#define SOAP_TYPE_ns3__AddressStatusCodeType (471)
#endif

/* enum ns3__PaymentStatusCodeType has binding name 'ns3__PaymentStatusCodeType' for type 'ns3:PaymentStatusCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentStatusCodeType
#define SOAP_TYPE_ns3__PaymentStatusCodeType (470)
#endif

/* enum ns3__PaymentTransactionCodeType has binding name 'ns3__PaymentTransactionCodeType' for type 'ns3:PaymentTransactionCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentTransactionCodeType
#define SOAP_TYPE_ns3__PaymentTransactionCodeType (469)
#endif

/* enum ns3__UserChannelCodeType has binding name 'ns3__UserChannelCodeType' for type 'ns3:UserChannelCodeType' */
#ifndef SOAP_TYPE_ns3__UserChannelCodeType
#define SOAP_TYPE_ns3__UserChannelCodeType (468)
#endif

/* enum ns3__IncentiveTypeCodeType has binding name 'ns3__IncentiveTypeCodeType' for type 'ns3:IncentiveTypeCodeType' */
#ifndef SOAP_TYPE_ns3__IncentiveTypeCodeType
#define SOAP_TYPE_ns3__IncentiveTypeCodeType (467)
#endif

/* enum ns3__IncentiveRequestDetailLevelCodeType has binding name 'ns3__IncentiveRequestDetailLevelCodeType' for type 'ns3:IncentiveRequestDetailLevelCodeType' */
#ifndef SOAP_TYPE_ns3__IncentiveRequestDetailLevelCodeType
#define SOAP_TYPE_ns3__IncentiveRequestDetailLevelCodeType (466)
#endif

/* enum ns3__IncentiveRequestCodeType has binding name 'ns3__IncentiveRequestCodeType' for type 'ns3:IncentiveRequestCodeType' */
#ifndef SOAP_TYPE_ns3__IncentiveRequestCodeType
#define SOAP_TYPE_ns3__IncentiveRequestCodeType (465)
#endif

/* enum ns3__APIType has binding name 'ns3__APIType' for type 'ns3:APIType' */
#ifndef SOAP_TYPE_ns3__APIType
#define SOAP_TYPE_ns3__APIType (464)
#endif

/* enum ns3__RedeemedOfferType has binding name 'ns3__RedeemedOfferType' for type 'ns3:RedeemedOfferType' */
#ifndef SOAP_TYPE_ns3__RedeemedOfferType
#define SOAP_TYPE_ns3__RedeemedOfferType (463)
#endif

/* enum ns3__UnitOfMeasure has binding name 'ns3__UnitOfMeasure' for type 'ns3:UnitOfMeasure' */
#ifndef SOAP_TYPE_ns3__UnitOfMeasure
#define SOAP_TYPE_ns3__UnitOfMeasure (462)
#endif

/* enum ns3__RefundType has binding name 'ns3__RefundType' for type 'ns3:RefundType' */
#ifndef SOAP_TYPE_ns3__RefundType
#define SOAP_TYPE_ns3__RefundType (461)
#endif

/* enum ns3__BankIDCodeType has binding name 'ns3__BankIDCodeType' for type 'ns3:BankIDCodeType' */
#ifndef SOAP_TYPE_ns3__BankIDCodeType
#define SOAP_TYPE_ns3__BankIDCodeType (459)
#endif

/* enum ns3__PaymentNotificationServiceCodeType has binding name 'ns3__PaymentNotificationServiceCodeType' for type 'ns3:PaymentNotificationServiceCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentNotificationServiceCodeType
#define SOAP_TYPE_ns3__PaymentNotificationServiceCodeType (457)
#endif

/* enum ns3__CreditCardTypeType has binding name 'ns3__CreditCardTypeType' for type 'ns3:CreditCardTypeType' */
#ifndef SOAP_TYPE_ns3__CreditCardTypeType
#define SOAP_TYPE_ns3__CreditCardTypeType (446)
#endif

/* enum ns3__VATStatusCodeType has binding name 'ns3__VATStatusCodeType' for type 'ns3:VATStatusCodeType' */
#ifndef SOAP_TYPE_ns3__VATStatusCodeType
#define SOAP_TYPE_ns3__VATStatusCodeType (445)
#endif

/* enum ns3__UserStatusCodeType has binding name 'ns3__UserStatusCodeType' for type 'ns3:UserStatusCodeType' */
#ifndef SOAP_TYPE_ns3__UserStatusCodeType
#define SOAP_TYPE_ns3__UserStatusCodeType (444)
#endif

/* enum ns3__UnitCodeType has binding name 'ns3__UnitCodeType' for type 'ns3:UnitCodeType' */
#ifndef SOAP_TYPE_ns3__UnitCodeType
#define SOAP_TYPE_ns3__UnitCodeType (443)
#endif

/* enum ns3__StoreVisibilityStatusType has binding name 'ns3__StoreVisibilityStatusType' for type 'ns3:StoreVisibilityStatusType' */
#ifndef SOAP_TYPE_ns3__StoreVisibilityStatusType
#define SOAP_TYPE_ns3__StoreVisibilityStatusType (442)
#endif

/* enum ns3__SiteCodeType has binding name 'ns3__SiteCodeType' for type 'ns3:SiteCodeType' */
#ifndef SOAP_TYPE_ns3__SiteCodeType
#define SOAP_TYPE_ns3__SiteCodeType (441)
#endif

/* enum ns3__ShippingTermsCodeType has binding name 'ns3__ShippingTermsCodeType' for type 'ns3:ShippingTermsCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingTermsCodeType
#define SOAP_TYPE_ns3__ShippingTermsCodeType (440)
#endif

/* enum ns3__ShippingServiceCodeType has binding name 'ns3__ShippingServiceCodeType' for type 'ns3:ShippingServiceCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingServiceCodeType
#define SOAP_TYPE_ns3__ShippingServiceCodeType (439)
#endif

/* enum ns3__ShippingRegionCodeType has binding name 'ns3__ShippingRegionCodeType' for type 'ns3:ShippingRegionCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingRegionCodeType
#define SOAP_TYPE_ns3__ShippingRegionCodeType (438)
#endif

/* enum ns3__ShippingRatesTypeCodeType has binding name 'ns3__ShippingRatesTypeCodeType' for type 'ns3:ShippingRatesTypeCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingRatesTypeCodeType
#define SOAP_TYPE_ns3__ShippingRatesTypeCodeType (437)
#endif

/* enum ns3__ShippingPackageCodeType has binding name 'ns3__ShippingPackageCodeType' for type 'ns3:ShippingPackageCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingPackageCodeType
#define SOAP_TYPE_ns3__ShippingPackageCodeType (436)
#endif

/* enum ns3__ShippingOptionCodeType has binding name 'ns3__ShippingOptionCodeType' for type 'ns3:ShippingOptionCodeType' */
#ifndef SOAP_TYPE_ns3__ShippingOptionCodeType
#define SOAP_TYPE_ns3__ShippingOptionCodeType (435)
#endif

/* enum ns3__SeverityCodeType has binding name 'ns3__SeverityCodeType' for type 'ns3:SeverityCodeType' */
#ifndef SOAP_TYPE_ns3__SeverityCodeType
#define SOAP_TYPE_ns3__SeverityCodeType (434)
#endif

/* enum ns3__SellerPaymentMethodCodeType has binding name 'ns3__SellerPaymentMethodCodeType' for type 'ns3:SellerPaymentMethodCodeType' */
#ifndef SOAP_TYPE_ns3__SellerPaymentMethodCodeType
#define SOAP_TYPE_ns3__SellerPaymentMethodCodeType (433)
#endif

/* enum ns3__SellerLevelCodeType has binding name 'ns3__SellerLevelCodeType' for type 'ns3:SellerLevelCodeType' */
#ifndef SOAP_TYPE_ns3__SellerLevelCodeType
#define SOAP_TYPE_ns3__SellerLevelCodeType (432)
#endif

/* enum ns3__PurchasePurposeTypeCodeType has binding name 'ns3__PurchasePurposeTypeCodeType' for type 'ns3:PurchasePurposeTypeCodeType' */
#ifndef SOAP_TYPE_ns3__PurchasePurposeTypeCodeType
#define SOAP_TYPE_ns3__PurchasePurposeTypeCodeType (431)
#endif

/* enum ns3__PromotionSchemeCodeType has binding name 'ns3__PromotionSchemeCodeType' for type 'ns3:PromotionSchemeCodeType' */
#ifndef SOAP_TYPE_ns3__PromotionSchemeCodeType
#define SOAP_TYPE_ns3__PromotionSchemeCodeType (430)
#endif

/* enum ns3__PromotionMethodCodeType has binding name 'ns3__PromotionMethodCodeType' for type 'ns3:PromotionMethodCodeType' */
#ifndef SOAP_TYPE_ns3__PromotionMethodCodeType
#define SOAP_TYPE_ns3__PromotionMethodCodeType (429)
#endif

/* enum ns3__PromotionItemSelectionCodeType has binding name 'ns3__PromotionItemSelectionCodeType' for type 'ns3:PromotionItemSelectionCodeType' */
#ifndef SOAP_TYPE_ns3__PromotionItemSelectionCodeType
#define SOAP_TYPE_ns3__PromotionItemSelectionCodeType (428)
#endif

/* enum ns3__PromotionItemPriceTypeCodeType has binding name 'ns3__PromotionItemPriceTypeCodeType' for type 'ns3:PromotionItemPriceTypeCodeType' */
#ifndef SOAP_TYPE_ns3__PromotionItemPriceTypeCodeType
#define SOAP_TYPE_ns3__PromotionItemPriceTypeCodeType (427)
#endif

/* enum ns3__PhotoDisplayCodeType has binding name 'ns3__PhotoDisplayCodeType' for type 'ns3:PhotoDisplayCodeType' */
#ifndef SOAP_TYPE_ns3__PhotoDisplayCodeType
#define SOAP_TYPE_ns3__PhotoDisplayCodeType (426)
#endif

/* enum ns3__ModifyCodeType has binding name 'ns3__ModifyCodeType' for type 'ns3:ModifyCodeType' */
#ifndef SOAP_TYPE_ns3__ModifyCodeType
#define SOAP_TYPE_ns3__ModifyCodeType (425)
#endif

/* enum ns3__MerchandizingPrefCodeType has binding name 'ns3__MerchandizingPrefCodeType' for type 'ns3:MerchandizingPrefCodeType' */
#ifndef SOAP_TYPE_ns3__MerchandizingPrefCodeType
#define SOAP_TYPE_ns3__MerchandizingPrefCodeType (424)
#endif

/* enum ns3__ListingTypeCodeType has binding name 'ns3__ListingTypeCodeType' for type 'ns3:ListingTypeCodeType' */
#ifndef SOAP_TYPE_ns3__ListingTypeCodeType
#define SOAP_TYPE_ns3__ListingTypeCodeType (423)
#endif

/* enum ns3__ListingEnhancementsCodeType has binding name 'ns3__ListingEnhancementsCodeType' for type 'ns3:ListingEnhancementsCodeType' */
#ifndef SOAP_TYPE_ns3__ListingEnhancementsCodeType
#define SOAP_TYPE_ns3__ListingEnhancementsCodeType (422)
#endif

/* enum ns3__ListingDurationCodeType has binding name 'ns3__ListingDurationCodeType' for type 'ns3:ListingDurationCodeType' */
#ifndef SOAP_TYPE_ns3__ListingDurationCodeType
#define SOAP_TYPE_ns3__ListingDurationCodeType (421)
#endif

/* enum ns3__InsuranceOptionCodeType has binding name 'ns3__InsuranceOptionCodeType' for type 'ns3:InsuranceOptionCodeType' */
#ifndef SOAP_TYPE_ns3__InsuranceOptionCodeType
#define SOAP_TYPE_ns3__InsuranceOptionCodeType (420)
#endif

/* enum ns3__HitCounterCodeType has binding name 'ns3__HitCounterCodeType' for type 'ns3:HitCounterCodeType' */
#ifndef SOAP_TYPE_ns3__HitCounterCodeType
#define SOAP_TYPE_ns3__HitCounterCodeType (419)
#endif

/* enum ns3__GiftServicesCodeType has binding name 'ns3__GiftServicesCodeType' for type 'ns3:GiftServicesCodeType' */
#ifndef SOAP_TYPE_ns3__GiftServicesCodeType
#define SOAP_TYPE_ns3__GiftServicesCodeType (418)
#endif

/* enum ns3__GeneralPaymentMethodCodeType has binding name 'ns3__GeneralPaymentMethodCodeType' for type 'ns3:GeneralPaymentMethodCodeType' */
#ifndef SOAP_TYPE_ns3__GeneralPaymentMethodCodeType
#define SOAP_TYPE_ns3__GeneralPaymentMethodCodeType (417)
#endif

/* enum ns3__GalleryTypeCodeType has binding name 'ns3__GalleryTypeCodeType' for type 'ns3:GalleryTypeCodeType' */
#ifndef SOAP_TYPE_ns3__GalleryTypeCodeType
#define SOAP_TYPE_ns3__GalleryTypeCodeType (416)
#endif

/* enum ns3__FeedbackRatingStarCodeType has binding name 'ns3__FeedbackRatingStarCodeType' for type 'ns3:FeedbackRatingStarCodeType' */
#ifndef SOAP_TYPE_ns3__FeedbackRatingStarCodeType
#define SOAP_TYPE_ns3__FeedbackRatingStarCodeType (415)
#endif

/* enum ns3__EscrowCodeType has binding name 'ns3__EscrowCodeType' for type 'ns3:EscrowCodeType' */
#ifndef SOAP_TYPE_ns3__EscrowCodeType
#define SOAP_TYPE_ns3__EscrowCodeType (414)
#endif

/* enum ns3__PaymentReasonType has binding name 'ns3__PaymentReasonType' for type 'ns3:PaymentReasonType' */
#ifndef SOAP_TYPE_ns3__PaymentReasonType
#define SOAP_TYPE_ns3__PaymentReasonType (412)
#endif

/* enum ns3__IncentiveAppliedStatusType has binding name 'ns3__IncentiveAppliedStatusType' for type 'ns3:IncentiveAppliedStatusType' */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedStatusType
#define SOAP_TYPE_ns3__IncentiveAppliedStatusType (410)
#endif

/* enum ns3__IncentiveSiteAppliedOnType has binding name 'ns3__IncentiveSiteAppliedOnType' for type 'ns3:IncentiveSiteAppliedOnType' */
#ifndef SOAP_TYPE_ns3__IncentiveSiteAppliedOnType
#define SOAP_TYPE_ns3__IncentiveSiteAppliedOnType (409)
#endif

/* enum ns3__DetailLevelCodeType has binding name 'ns3__DetailLevelCodeType' for type 'ns3:DetailLevelCodeType' */
#ifndef SOAP_TYPE_ns3__DetailLevelCodeType
#define SOAP_TYPE_ns3__DetailLevelCodeType (408)
#endif

/* enum ns3__DepositTypeCodeType has binding name 'ns3__DepositTypeCodeType' for type 'ns3:DepositTypeCodeType' */
#ifndef SOAP_TYPE_ns3__DepositTypeCodeType
#define SOAP_TYPE_ns3__DepositTypeCodeType (407)
#endif

/* enum ns3__CurrencyCodeType has binding name 'ns3__CurrencyCodeType' for type 'ns3:CurrencyCodeType' */
#ifndef SOAP_TYPE_ns3__CurrencyCodeType
#define SOAP_TYPE_ns3__CurrencyCodeType (406)
#endif

/* enum ns3__CountryCodeType has binding name 'ns3__CountryCodeType' for type 'ns3:CountryCodeType' */
#ifndef SOAP_TYPE_ns3__CountryCodeType
#define SOAP_TYPE_ns3__CountryCodeType (405)
#endif

/* enum ns3__CheckoutStatusCodeType has binding name 'ns3__CheckoutStatusCodeType' for type 'ns3:CheckoutStatusCodeType' */
#ifndef SOAP_TYPE_ns3__CheckoutStatusCodeType
#define SOAP_TYPE_ns3__CheckoutStatusCodeType (404)
#endif

/* enum ns3__BuyerProtectionCodeType has binding name 'ns3__BuyerProtectionCodeType' for type 'ns3:BuyerProtectionCodeType' */
#ifndef SOAP_TYPE_ns3__BuyerProtectionCodeType
#define SOAP_TYPE_ns3__BuyerProtectionCodeType (403)
#endif

/* enum ns3__BuyerPaymentMethodCodeType has binding name 'ns3__BuyerPaymentMethodCodeType' for type 'ns3:BuyerPaymentMethodCodeType' */
#ifndef SOAP_TYPE_ns3__BuyerPaymentMethodCodeType
#define SOAP_TYPE_ns3__BuyerPaymentMethodCodeType (402)
#endif

/* enum ns3__BalanceCodeType has binding name 'ns3__BalanceCodeType' for type 'ns3:BalanceCodeType' */
#ifndef SOAP_TYPE_ns3__BalanceCodeType
#define SOAP_TYPE_ns3__BalanceCodeType (401)
#endif

/* enum ns3__AuctionTypeCodeType has binding name 'ns3__AuctionTypeCodeType' for type 'ns3:AuctionTypeCodeType' */
#ifndef SOAP_TYPE_ns3__AuctionTypeCodeType
#define SOAP_TYPE_ns3__AuctionTypeCodeType (400)
#endif

/* enum ns3__AddressOwnerCodeType has binding name 'ns3__AddressOwnerCodeType' for type 'ns3:AddressOwnerCodeType' */
#ifndef SOAP_TYPE_ns3__AddressOwnerCodeType
#define SOAP_TYPE_ns3__AddressOwnerCodeType (399)
#endif

/* enum ns3__AckCodeType has binding name 'ns3__AckCodeType' for type 'ns3:AckCodeType' */
#ifndef SOAP_TYPE_ns3__AckCodeType
#define SOAP_TYPE_ns3__AckCodeType (398)
#endif

/* enum ns3__AccountStateCodeType has binding name 'ns3__AccountStateCodeType' for type 'ns3:AccountStateCodeType' */
#ifndef SOAP_TYPE_ns3__AccountStateCodeType
#define SOAP_TYPE_ns3__AccountStateCodeType (397)
#endif

/* ns3__EnterBoardingTokenType has binding name 'ns3__EnterBoardingTokenType' for type 'ns3:EnterBoardingTokenType' */
#ifndef SOAP_TYPE_ns3__EnterBoardingTokenType
#define SOAP_TYPE_ns3__EnterBoardingTokenType (508)
#endif

/* ns3__PaymentStatusIDCodeType has binding name 'ns3__PaymentStatusIDCodeType' for type 'ns3:PaymentStatusIDCodeType' */
#ifndef SOAP_TYPE_ns3__PaymentStatusIDCodeType
#define SOAP_TYPE_ns3__PaymentStatusIDCodeType (460)
#endif

/* ns3__OrderID has binding name 'ns3__OrderID' for type 'ns3:OrderID' */
#ifndef SOAP_TYPE_ns3__OrderID
#define SOAP_TYPE_ns3__OrderID (458)
#endif

/* ns3__LanguageCodeType has binding name 'ns3__LanguageCodeType' for type 'ns3:LanguageCodeType' */
#ifndef SOAP_TYPE_ns3__LanguageCodeType
#define SOAP_TYPE_ns3__LanguageCodeType (456)
#endif

/* ns3__AuthFlowTokenType has binding name 'ns3__AuthFlowTokenType' for type 'ns3:AuthFlowTokenType' */
#ifndef SOAP_TYPE_ns3__AuthFlowTokenType
#define SOAP_TYPE_ns3__AuthFlowTokenType (455)
#endif

/* ns3__ExpressCheckoutTokenType has binding name 'ns3__ExpressCheckoutTokenType' for type 'ns3:ExpressCheckoutTokenType' */
#ifndef SOAP_TYPE_ns3__ExpressCheckoutTokenType
#define SOAP_TYPE_ns3__ExpressCheckoutTokenType (454)
#endif

/* ns3__EmailAddressType has binding name 'ns3__EmailAddressType' for type 'ns3:EmailAddressType' */
#ifndef SOAP_TYPE_ns3__EmailAddressType
#define SOAP_TYPE_ns3__EmailAddressType (453)
#endif

/* ns3__MerchantPullIDType has binding name 'ns3__MerchantPullIDType' for type 'ns3:MerchantPullIDType' */
#ifndef SOAP_TYPE_ns3__MerchantPullIDType
#define SOAP_TYPE_ns3__MerchantPullIDType (452)
#endif

/* ns3__AuthorizationId has binding name 'ns3__AuthorizationId' for type 'ns3:AuthorizationId' */
#ifndef SOAP_TYPE_ns3__AuthorizationId
#define SOAP_TYPE_ns3__AuthorizationId (451)
#endif

/* ns3__TransactionId has binding name 'ns3__TransactionId' for type 'ns3:TransactionId' */
#ifndef SOAP_TYPE_ns3__TransactionId
#define SOAP_TYPE_ns3__TransactionId (450)
#endif

/* ns3__SuffixType has binding name 'ns3__SuffixType' for type 'ns3:SuffixType' */
#ifndef SOAP_TYPE_ns3__SuffixType
#define SOAP_TYPE_ns3__SuffixType (449)
#endif

/* ns3__SalutationType has binding name 'ns3__SalutationType' for type 'ns3:SalutationType' */
#ifndef SOAP_TYPE_ns3__SalutationType
#define SOAP_TYPE_ns3__SalutationType (448)
#endif

/* ns3__NameType has binding name 'ns3__NameType' for type 'ns3:NameType' */
#ifndef SOAP_TYPE_ns3__NameType
#define SOAP_TYPE_ns3__NameType (447)
#endif

/* ns3__UserIDType has binding name 'ns3__UserIDType' for type 'ns3:UserIDType' */
#ifndef SOAP_TYPE_ns3__UserIDType
#define SOAP_TYPE_ns3__UserIDType (413)
#endif

/* ns3__ItemIDType has binding name 'ns3__ItemIDType' for type 'ns3:ItemIDType' */
#ifndef SOAP_TYPE_ns3__ItemIDType
#define SOAP_TYPE_ns3__ItemIDType (411)
#endif

/* ns2__UUIDType has binding name 'ns2__UUIDType' for type 'ns2:UUIDType' */
#ifndef SOAP_TYPE_ns2__UUIDType
#define SOAP_TYPE_ns2__UUIDType (396)
#endif

/* ns4__EnhancedPayerInfoType has binding name 'ns4__EnhancedPayerInfoType' for type 'ns4:EnhancedPayerInfoType' */
#ifndef SOAP_TYPE_ns4__EnhancedPayerInfoType
#define SOAP_TYPE_ns4__EnhancedPayerInfoType (395)
#endif

/* ns4__EnhancedCancelRecoupRequestDetailsType has binding name 'ns4__EnhancedCancelRecoupRequestDetailsType' for type 'ns4:EnhancedCancelRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedCancelRecoupRequestDetailsType (394)
#endif

/* ns4__EnhancedCompleteRecoupResponseDetailsType has binding name 'ns4__EnhancedCompleteRecoupResponseDetailsType' for type 'ns4:EnhancedCompleteRecoupResponseDetailsType' */
#ifndef SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType
#define SOAP_TYPE_ns4__EnhancedCompleteRecoupResponseDetailsType (393)
#endif

/* ns4__EnhancedCompleteRecoupRequestDetailsType has binding name 'ns4__EnhancedCompleteRecoupRequestDetailsType' for type 'ns4:EnhancedCompleteRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedCompleteRecoupRequestDetailsType (392)
#endif

/* ns4__EnhancedInitiateRecoupRequestDetailsType has binding name 'ns4__EnhancedInitiateRecoupRequestDetailsType' for type 'ns4:EnhancedInitiateRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType
#define SOAP_TYPE_ns4__EnhancedInitiateRecoupRequestDetailsType (391)
#endif

/* ns4__EnhancedItemDataType has binding name 'ns4__EnhancedItemDataType' for type 'ns4:EnhancedItemDataType' */
#ifndef SOAP_TYPE_ns4__EnhancedItemDataType
#define SOAP_TYPE_ns4__EnhancedItemDataType (390)
#endif

/* ns4__EnhancedPaymentInfoType has binding name 'ns4__EnhancedPaymentInfoType' for type 'ns4:EnhancedPaymentInfoType' */
#ifndef SOAP_TYPE_ns4__EnhancedPaymentInfoType
#define SOAP_TYPE_ns4__EnhancedPaymentInfoType (389)
#endif

/* ns4__EnhancedPaymentDataType has binding name 'ns4__EnhancedPaymentDataType' for type 'ns4:EnhancedPaymentDataType' */
#ifndef SOAP_TYPE_ns4__EnhancedPaymentDataType
#define SOAP_TYPE_ns4__EnhancedPaymentDataType (388)
#endif

/* ns4__EnhancedCheckoutDataType has binding name 'ns4__EnhancedCheckoutDataType' for type 'ns4:EnhancedCheckoutDataType' */
#ifndef SOAP_TYPE_ns4__EnhancedCheckoutDataType
#define SOAP_TYPE_ns4__EnhancedCheckoutDataType (387)
#endif

/* ns3__DiscountInfoType has binding name 'ns3__DiscountInfoType' for type 'ns3:DiscountInfoType' */
#ifndef SOAP_TYPE_ns3__DiscountInfoType
#define SOAP_TYPE_ns3__DiscountInfoType (386)
#endif

/* ns3__WalletItemsType has binding name 'ns3__WalletItemsType' for type 'ns3:WalletItemsType' */
#ifndef SOAP_TYPE_ns3__WalletItemsType
#define SOAP_TYPE_ns3__WalletItemsType (385)
#endif

/* ns3__MerchantDataType has binding name 'ns3__MerchantDataType' for type 'ns3:MerchantDataType' */
#ifndef SOAP_TYPE_ns3__MerchantDataType
#define SOAP_TYPE_ns3__MerchantDataType (384)
#endif

/* ns3__TupleType has binding name 'ns3__TupleType' for type 'ns3:TupleType' */
#ifndef SOAP_TYPE_ns3__TupleType
#define SOAP_TYPE_ns3__TupleType (383)
#endif

/* ns3__CoupledPaymentInfoType has binding name 'ns3__CoupledPaymentInfoType' for type 'ns3:CoupledPaymentInfoType' */
#ifndef SOAP_TYPE_ns3__CoupledPaymentInfoType
#define SOAP_TYPE_ns3__CoupledPaymentInfoType (382)
#endif

/* ns3__CoupledBucketsType has binding name 'ns3__CoupledBucketsType' for type 'ns3:CoupledBucketsType' */
#ifndef SOAP_TYPE_ns3__CoupledBucketsType
#define SOAP_TYPE_ns3__CoupledBucketsType (381)
#endif

/* ns3__RefundInfoType has binding name 'ns3__RefundInfoType' for type 'ns3:RefundInfoType' */
#ifndef SOAP_TYPE_ns3__RefundInfoType
#define SOAP_TYPE_ns3__RefundInfoType (380)
#endif

/* ns3__InvoiceItemType has binding name 'ns3__InvoiceItemType' for type 'ns3:InvoiceItemType' */
#ifndef SOAP_TYPE_ns3__InvoiceItemType
#define SOAP_TYPE_ns3__InvoiceItemType (379)
#endif

/* ns3__DiscountType has binding name 'ns3__DiscountType' for type 'ns3:DiscountType' */
#ifndef SOAP_TYPE_ns3__DiscountType
#define SOAP_TYPE_ns3__DiscountType (378)
#endif

/* ns3__AdditionalFeeType has binding name 'ns3__AdditionalFeeType' for type 'ns3:AdditionalFeeType' */
#ifndef SOAP_TYPE_ns3__AdditionalFeeType
#define SOAP_TYPE_ns3__AdditionalFeeType (377)
#endif

/* ns3__MerchantStoreDetailsType has binding name 'ns3__MerchantStoreDetailsType' for type 'ns3:MerchantStoreDetailsType' */
#ifndef SOAP_TYPE_ns3__MerchantStoreDetailsType
#define SOAP_TYPE_ns3__MerchantStoreDetailsType (376)
#endif

/* ns3__ExternalPartnerTrackingDetailsType has binding name 'ns3__ExternalPartnerTrackingDetailsType' for type 'ns3:ExternalPartnerTrackingDetailsType' */
#ifndef SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType
#define SOAP_TYPE_ns3__ExternalPartnerTrackingDetailsType (375)
#endif

/* ns3__DisplayControlDetailsType has binding name 'ns3__DisplayControlDetailsType' for type 'ns3:DisplayControlDetailsType' */
#ifndef SOAP_TYPE_ns3__DisplayControlDetailsType
#define SOAP_TYPE_ns3__DisplayControlDetailsType (374)
#endif

/* ns3__RefreshTokenStatusDetailsType has binding name 'ns3__RefreshTokenStatusDetailsType' for type 'ns3:RefreshTokenStatusDetailsType' */
#ifndef SOAP_TYPE_ns3__RefreshTokenStatusDetailsType
#define SOAP_TYPE_ns3__RefreshTokenStatusDetailsType (373)
#endif

/* ns3__ExternalRememberMeStatusDetailsType has binding name 'ns3__ExternalRememberMeStatusDetailsType' for type 'ns3:ExternalRememberMeStatusDetailsType' */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeStatusDetailsType (372)
#endif

/* ns3__FlowControlDetailsType has binding name 'ns3__FlowControlDetailsType' for type 'ns3:FlowControlDetailsType' */
#ifndef SOAP_TYPE_ns3__FlowControlDetailsType
#define SOAP_TYPE_ns3__FlowControlDetailsType (371)
#endif

/* ns3__ExternalRememberMeOptInDetailsType has binding name 'ns3__ExternalRememberMeOptInDetailsType' for type 'ns3:ExternalRememberMeOptInDetailsType' */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeOptInDetailsType (370)
#endif

/* ns3__ExternalRememberMeOwnerDetailsType has binding name 'ns3__ExternalRememberMeOwnerDetailsType' for type 'ns3:ExternalRememberMeOwnerDetailsType' */
#ifndef SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType
#define SOAP_TYPE_ns3__ExternalRememberMeOwnerDetailsType (369)
#endif

/* ns3__PaymentRequestInfoType has binding name 'ns3__PaymentRequestInfoType' for type 'ns3:PaymentRequestInfoType' */
#ifndef SOAP_TYPE_ns3__PaymentRequestInfoType
#define SOAP_TYPE_ns3__PaymentRequestInfoType (368)
#endif

/* ns3__IncentiveApplyIndicationType has binding name 'ns3__IncentiveApplyIndicationType' for type 'ns3:IncentiveApplyIndicationType' */
#ifndef SOAP_TYPE_ns3__IncentiveApplyIndicationType
#define SOAP_TYPE_ns3__IncentiveApplyIndicationType (367)
#endif

/* ns3__IncentiveInfoType has binding name 'ns3__IncentiveInfoType' for type 'ns3:IncentiveInfoType' */
#ifndef SOAP_TYPE_ns3__IncentiveInfoType
#define SOAP_TYPE_ns3__IncentiveInfoType (366)
#endif

/* ns3__ReverseTransactionResponseDetailsType has binding name 'ns3__ReverseTransactionResponseDetailsType' for type 'ns3:ReverseTransactionResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType
#define SOAP_TYPE_ns3__ReverseTransactionResponseDetailsType (365)
#endif

/* ns3__ReverseTransactionRequestDetailsType has binding name 'ns3__ReverseTransactionRequestDetailsType' for type 'ns3:ReverseTransactionRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType
#define SOAP_TYPE_ns3__ReverseTransactionRequestDetailsType (364)
#endif

/* ns3__ButtonSearchResultType has binding name 'ns3__ButtonSearchResultType' for type 'ns3:ButtonSearchResultType' */
#ifndef SOAP_TYPE_ns3__ButtonSearchResultType
#define SOAP_TYPE_ns3__ButtonSearchResultType (363)
#endif

/* ns3__ItemTrackingDetailsType has binding name 'ns3__ItemTrackingDetailsType' for type 'ns3:ItemTrackingDetailsType' */
#ifndef SOAP_TYPE_ns3__ItemTrackingDetailsType
#define SOAP_TYPE_ns3__ItemTrackingDetailsType (362)
#endif

/* ns3__OptionTrackingDetailsType has binding name 'ns3__OptionTrackingDetailsType' for type 'ns3:OptionTrackingDetailsType' */
#ifndef SOAP_TYPE_ns3__OptionTrackingDetailsType
#define SOAP_TYPE_ns3__OptionTrackingDetailsType (361)
#endif

/* ns3__AuthorizationInfoType has binding name 'ns3__AuthorizationInfoType' for type 'ns3:AuthorizationInfoType' */
#ifndef SOAP_TYPE_ns3__AuthorizationInfoType
#define SOAP_TYPE_ns3__AuthorizationInfoType (360)
#endif

/* ns3__FlightDetailsType has binding name 'ns3__FlightDetailsType' for type 'ns3:FlightDetailsType' */
#ifndef SOAP_TYPE_ns3__FlightDetailsType
#define SOAP_TYPE_ns3__FlightDetailsType (359)
#endif

/* ns3__AirlineItineraryType has binding name 'ns3__AirlineItineraryType' for type 'ns3:AirlineItineraryType' */
#ifndef SOAP_TYPE_ns3__AirlineItineraryType
#define SOAP_TYPE_ns3__AirlineItineraryType (358)
#endif

/* ns3__EnhancedDataType has binding name 'ns3__EnhancedDataType' for type 'ns3:EnhancedDataType' */
#ifndef SOAP_TYPE_ns3__EnhancedDataType
#define SOAP_TYPE_ns3__EnhancedDataType (357)
#endif

/* ns3__FMFDetailsType has binding name 'ns3__FMFDetailsType' for type 'ns3:FMFDetailsType' */
#ifndef SOAP_TYPE_ns3__FMFDetailsType
#define SOAP_TYPE_ns3__FMFDetailsType (356)
#endif

/* ns3__RiskFilterListType has binding name 'ns3__RiskFilterListType' for type 'ns3:RiskFilterListType' */
#ifndef SOAP_TYPE_ns3__RiskFilterListType
#define SOAP_TYPE_ns3__RiskFilterListType (355)
#endif

/* ns3__RiskFilterDetailsType has binding name 'ns3__RiskFilterDetailsType' for type 'ns3:RiskFilterDetailsType' */
#ifndef SOAP_TYPE_ns3__RiskFilterDetailsType
#define SOAP_TYPE_ns3__RiskFilterDetailsType (354)
#endif

/* ns3__UpdateRecurringPaymentsProfileResponseDetailsType has binding name 'ns3__UpdateRecurringPaymentsProfileResponseDetailsType' for type 'ns3:UpdateRecurringPaymentsProfileResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileResponseDetailsType (353)
#endif

/* ns3__UpdateRecurringPaymentsProfileRequestDetailsType has binding name 'ns3__UpdateRecurringPaymentsProfileRequestDetailsType' for type 'ns3:UpdateRecurringPaymentsProfileRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_ns3__UpdateRecurringPaymentsProfileRequestDetailsType (352)
#endif

/* ns3__BillOutstandingAmountResponseDetailsType has binding name 'ns3__BillOutstandingAmountResponseDetailsType' for type 'ns3:BillOutstandingAmountResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType
#define SOAP_TYPE_ns3__BillOutstandingAmountResponseDetailsType (351)
#endif

/* ns3__BillOutstandingAmountRequestDetailsType has binding name 'ns3__BillOutstandingAmountRequestDetailsType' for type 'ns3:BillOutstandingAmountRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType
#define SOAP_TYPE_ns3__BillOutstandingAmountRequestDetailsType (350)
#endif

/* ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType has binding name 'ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType' for type 'ns3:ManageRecurringPaymentsProfileStatusResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType
#define SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType (349)
#endif

/* ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType has binding name 'ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType' for type 'ns3:ManageRecurringPaymentsProfileStatusRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType
#define SOAP_TYPE_ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType (348)
#endif

/* ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType has binding name 'ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType' for type 'ns3:GetRecurringPaymentsProfileDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType (347)
#endif

/* ns3__CreateRecurringPaymentsProfileResponseDetailsType has binding name 'ns3__CreateRecurringPaymentsProfileResponseDetailsType' for type 'ns3:CreateRecurringPaymentsProfileResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_ns3__CreateRecurringPaymentsProfileResponseDetailsType (346)
#endif

/* ns3__CreateRecurringPaymentsProfileRequestDetailsType has binding name 'ns3__CreateRecurringPaymentsProfileRequestDetailsType' for type 'ns3:CreateRecurringPaymentsProfileRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_ns3__CreateRecurringPaymentsProfileRequestDetailsType (345)
#endif

/* ns3__RecurringPaymentsProfileDetailsType has binding name 'ns3__RecurringPaymentsProfileDetailsType' for type 'ns3:RecurringPaymentsProfileDetailsType' */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType
#define SOAP_TYPE_ns3__RecurringPaymentsProfileDetailsType (344)
#endif

/* ns3__ScheduleDetailsType has binding name 'ns3__ScheduleDetailsType' for type 'ns3:ScheduleDetailsType' */
#ifndef SOAP_TYPE_ns3__ScheduleDetailsType
#define SOAP_TYPE_ns3__ScheduleDetailsType (343)
#endif

/* ns3__BillingPeriodDetailsType_USCOREUpdate has binding name 'ns3__BillingPeriodDetailsType_USCOREUpdate' for type 'ns3:BillingPeriodDetailsType_Update' */
#ifndef SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate
#define SOAP_TYPE_ns3__BillingPeriodDetailsType_USCOREUpdate (342)
#endif

/* ns3__BillingPeriodDetailsType has binding name 'ns3__BillingPeriodDetailsType' for type 'ns3:BillingPeriodDetailsType' */
#ifndef SOAP_TYPE_ns3__BillingPeriodDetailsType
#define SOAP_TYPE_ns3__BillingPeriodDetailsType (341)
#endif

/* ns3__ActivationDetailsType has binding name 'ns3__ActivationDetailsType' for type 'ns3:ActivationDetailsType' */
#ifndef SOAP_TYPE_ns3__ActivationDetailsType
#define SOAP_TYPE_ns3__ActivationDetailsType (340)
#endif

/* ns3__RecurringPaymentsSummaryType has binding name 'ns3__RecurringPaymentsSummaryType' for type 'ns3:RecurringPaymentsSummaryType' */
#ifndef SOAP_TYPE_ns3__RecurringPaymentsSummaryType
#define SOAP_TYPE_ns3__RecurringPaymentsSummaryType (339)
#endif

/* ns3__UATPDetailsType has binding name 'ns3__UATPDetailsType' for type 'ns3:UATPDetailsType' */
#ifndef SOAP_TYPE_ns3__UATPDetailsType
#define SOAP_TYPE_ns3__UATPDetailsType (338)
#endif

/* ns3__SetEbayMobileCheckoutRequestDetailsType has binding name 'ns3__SetEbayMobileCheckoutRequestDetailsType' for type 'ns3:SetEbayMobileCheckoutRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetEbayMobileCheckoutRequestDetailsType (337)
#endif

/* ns3__DoMobileCheckoutPaymentResponseDetailsType has binding name 'ns3__DoMobileCheckoutPaymentResponseDetailsType' for type 'ns3:DoMobileCheckoutPaymentResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_ns3__DoMobileCheckoutPaymentResponseDetailsType (336)
#endif

/* ns3__SetMobileCheckoutRequestDetailsType has binding name 'ns3__SetMobileCheckoutRequestDetailsType' for type 'ns3:SetMobileCheckoutRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetMobileCheckoutRequestDetailsType (335)
#endif

/* ns3__APICredentialsType has binding name 'ns3__APICredentialsType' for type 'ns3:APICredentialsType' */
#ifndef SOAP_TYPE_ns3__APICredentialsType
#define SOAP_TYPE_ns3__APICredentialsType (334)
#endif

/* ns3__GetBoardingDetailsResponseDetailsType has binding name 'ns3__GetBoardingDetailsResponseDetailsType' for type 'ns3:GetBoardingDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetBoardingDetailsResponseDetailsType (333)
#endif

/* ns3__BankAccountDetailsType has binding name 'ns3__BankAccountDetailsType' for type 'ns3:BankAccountDetailsType' */
#ifndef SOAP_TYPE_ns3__BankAccountDetailsType
#define SOAP_TYPE_ns3__BankAccountDetailsType (332)
#endif

/* ns3__BusinessOwnerInfoType has binding name 'ns3__BusinessOwnerInfoType' for type 'ns3:BusinessOwnerInfoType' */
#ifndef SOAP_TYPE_ns3__BusinessOwnerInfoType
#define SOAP_TYPE_ns3__BusinessOwnerInfoType (331)
#endif

/* ns3__BusinessInfoType has binding name 'ns3__BusinessInfoType' for type 'ns3:BusinessInfoType' */
#ifndef SOAP_TYPE_ns3__BusinessInfoType
#define SOAP_TYPE_ns3__BusinessInfoType (330)
#endif

/* ns3__EnterBoardingRequestDetailsType has binding name 'ns3__EnterBoardingRequestDetailsType' for type 'ns3:EnterBoardingRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__EnterBoardingRequestDetailsType
#define SOAP_TYPE_ns3__EnterBoardingRequestDetailsType (329)
#endif

/* ns3__DoNonReferencedCreditResponseDetailsType has binding name 'ns3__DoNonReferencedCreditResponseDetailsType' for type 'ns3:DoNonReferencedCreditResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType
#define SOAP_TYPE_ns3__DoNonReferencedCreditResponseDetailsType (328)
#endif

/* ns3__DoNonReferencedCreditRequestDetailsType has binding name 'ns3__DoNonReferencedCreditRequestDetailsType' for type 'ns3:DoNonReferencedCreditRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType
#define SOAP_TYPE_ns3__DoNonReferencedCreditRequestDetailsType (327)
#endif

/* ns3__DoReferenceTransactionResponseDetailsType has binding name 'ns3__DoReferenceTransactionResponseDetailsType' for type 'ns3:DoReferenceTransactionResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType
#define SOAP_TYPE_ns3__DoReferenceTransactionResponseDetailsType (326)
#endif

/* ns3__DoReferenceTransactionRequestDetailsType has binding name 'ns3__DoReferenceTransactionRequestDetailsType' for type 'ns3:DoReferenceTransactionRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType
#define SOAP_TYPE_ns3__DoReferenceTransactionRequestDetailsType (325)
#endif

/* ns3__SenderDetailsType has binding name 'ns3__SenderDetailsType' for type 'ns3:SenderDetailsType' */
#ifndef SOAP_TYPE_ns3__SenderDetailsType
#define SOAP_TYPE_ns3__SenderDetailsType (324)
#endif

/* ns3__DeviceDetailsType has binding name 'ns3__DeviceDetailsType' for type 'ns3:DeviceDetailsType' */
#ifndef SOAP_TYPE_ns3__DeviceDetailsType
#define SOAP_TYPE_ns3__DeviceDetailsType (323)
#endif

/* ns3__GetBillingAgreementCustomerDetailsResponseDetailsType has binding name 'ns3__GetBillingAgreementCustomerDetailsResponseDetailsType' for type 'ns3:GetBillingAgreementCustomerDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetBillingAgreementCustomerDetailsResponseDetailsType (322)
#endif

/* ns3__SetCustomerBillingAgreementRequestDetailsType has binding name 'ns3__SetCustomerBillingAgreementRequestDetailsType' for type 'ns3:SetCustomerBillingAgreementRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType
#define SOAP_TYPE_ns3__SetCustomerBillingAgreementRequestDetailsType (321)
#endif

/* ns3__UserIdPasswordType has binding name 'ns3__UserIdPasswordType' for type 'ns3:UserIdPasswordType' */
#ifndef SOAP_TYPE_ns3__UserIdPasswordType
#define SOAP_TYPE_ns3__UserIdPasswordType (320)
#endif

/* ns3__CustomSecurityHeaderType has binding name 'ns3__CustomSecurityHeaderType' for type 'ns3:CustomSecurityHeaderType' */
#ifndef SOAP_TYPE_ns3__CustomSecurityHeaderType
#define SOAP_TYPE_ns3__CustomSecurityHeaderType (319)
#endif

/* ns3__ReferenceCreditCardDetailsType has binding name 'ns3__ReferenceCreditCardDetailsType' for type 'ns3:ReferenceCreditCardDetailsType' */
#ifndef SOAP_TYPE_ns3__ReferenceCreditCardDetailsType
#define SOAP_TYPE_ns3__ReferenceCreditCardDetailsType (318)
#endif

/* ns3__CreditCardNumberTypeType has binding name 'ns3__CreditCardNumberTypeType' for type 'ns3:CreditCardNumberTypeType' */
#ifndef SOAP_TYPE_ns3__CreditCardNumberTypeType
#define SOAP_TYPE_ns3__CreditCardNumberTypeType (317)
#endif

/* ns3__UserSelectedOptionType has binding name 'ns3__UserSelectedOptionType' for type 'ns3:UserSelectedOptionType' */
#ifndef SOAP_TYPE_ns3__UserSelectedOptionType
#define SOAP_TYPE_ns3__UserSelectedOptionType (316)
#endif

/* ns3__ShippingOptionType has binding name 'ns3__ShippingOptionType' for type 'ns3:ShippingOptionType' */
#ifndef SOAP_TYPE_ns3__ShippingOptionType
#define SOAP_TYPE_ns3__ShippingOptionType (315)
#endif

/* ns3__CreditCardDetailsType has binding name 'ns3__CreditCardDetailsType' for type 'ns3:CreditCardDetailsType' */
#ifndef SOAP_TYPE_ns3__CreditCardDetailsType
#define SOAP_TYPE_ns3__CreditCardDetailsType (314)
#endif

/* ns3__ThreeDSecureInfoType has binding name 'ns3__ThreeDSecureInfoType' for type 'ns3:ThreeDSecureInfoType' */
#ifndef SOAP_TYPE_ns3__ThreeDSecureInfoType
#define SOAP_TYPE_ns3__ThreeDSecureInfoType (313)
#endif

/* ns3__ThreeDSecureResponseType has binding name 'ns3__ThreeDSecureResponseType' for type 'ns3:ThreeDSecureResponseType' */
#ifndef SOAP_TYPE_ns3__ThreeDSecureResponseType
#define SOAP_TYPE_ns3__ThreeDSecureResponseType (312)
#endif

/* ns3__ThreeDSecureRequestType has binding name 'ns3__ThreeDSecureRequestType' for type 'ns3:ThreeDSecureRequestType' */
#ifndef SOAP_TYPE_ns3__ThreeDSecureRequestType
#define SOAP_TYPE_ns3__ThreeDSecureRequestType (311)
#endif

/* ns3__TaxIdDetailsType has binding name 'ns3__TaxIdDetailsType' for type 'ns3:TaxIdDetailsType' */
#ifndef SOAP_TYPE_ns3__TaxIdDetailsType
#define SOAP_TYPE_ns3__TaxIdDetailsType (310)
#endif

/* ns3__BuyerDetailsType has binding name 'ns3__BuyerDetailsType' for type 'ns3:BuyerDetailsType' */
#ifndef SOAP_TYPE_ns3__BuyerDetailsType
#define SOAP_TYPE_ns3__BuyerDetailsType (309)
#endif

/* ns3__OtherPaymentMethodDetailsType has binding name 'ns3__OtherPaymentMethodDetailsType' for type 'ns3:OtherPaymentMethodDetailsType' */
#ifndef SOAP_TYPE_ns3__OtherPaymentMethodDetailsType
#define SOAP_TYPE_ns3__OtherPaymentMethodDetailsType (308)
#endif

/* ns3__SellerDetailsType has binding name 'ns3__SellerDetailsType' for type 'ns3:SellerDetailsType' */
#ifndef SOAP_TYPE_ns3__SellerDetailsType
#define SOAP_TYPE_ns3__SellerDetailsType (307)
#endif

/* ns3__IncentiveAppliedDetailsType has binding name 'ns3__IncentiveAppliedDetailsType' for type 'ns3:IncentiveAppliedDetailsType' */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedDetailsType
#define SOAP_TYPE_ns3__IncentiveAppliedDetailsType (306)
#endif

/* ns3__IncentiveDetailsType has binding name 'ns3__IncentiveDetailsType' for type 'ns3:IncentiveDetailsType' */
#ifndef SOAP_TYPE_ns3__IncentiveDetailsType
#define SOAP_TYPE_ns3__IncentiveDetailsType (305)
#endif

/* ns3__PaymentDetailsType has binding name 'ns3__PaymentDetailsType' for type 'ns3:PaymentDetailsType' */
#ifndef SOAP_TYPE_ns3__PaymentDetailsType
#define SOAP_TYPE_ns3__PaymentDetailsType (304)
#endif

/* ns3__OfferCouponInfoType has binding name 'ns3__OfferCouponInfoType' for type 'ns3:OfferCouponInfoType' */
#ifndef SOAP_TYPE_ns3__OfferCouponInfoType
#define SOAP_TYPE_ns3__OfferCouponInfoType (303)
#endif

/* ns3__PaymentItemInfoType has binding name 'ns3__PaymentItemInfoType' for type 'ns3:PaymentItemInfoType' */
#ifndef SOAP_TYPE_ns3__PaymentItemInfoType
#define SOAP_TYPE_ns3__PaymentItemInfoType (302)
#endif

/* ns3__PaymentItemType has binding name 'ns3__PaymentItemType' for type 'ns3:PaymentItemType' */
#ifndef SOAP_TYPE_ns3__PaymentItemType
#define SOAP_TYPE_ns3__PaymentItemType (301)
#endif

/* ns3__PaymentDetailsItemType has binding name 'ns3__PaymentDetailsItemType' for type 'ns3:PaymentDetailsItemType' */
#ifndef SOAP_TYPE_ns3__PaymentDetailsItemType
#define SOAP_TYPE_ns3__PaymentDetailsItemType (300)
#endif

/* ns3__EbayItemPaymentDetailsItemType has binding name 'ns3__EbayItemPaymentDetailsItemType' for type 'ns3:EbayItemPaymentDetailsItemType' */
#ifndef SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType
#define SOAP_TYPE_ns3__EbayItemPaymentDetailsItemType (299)
#endif

/* ns3__OptionType has binding name 'ns3__OptionType' for type 'ns3:OptionType' */
#ifndef SOAP_TYPE_ns3__OptionType
#define SOAP_TYPE_ns3__OptionType (298)
#endif

/* ns3__AuctionInfoType has binding name 'ns3__AuctionInfoType' for type 'ns3:AuctionInfoType' */
#ifndef SOAP_TYPE_ns3__AuctionInfoType
#define SOAP_TYPE_ns3__AuctionInfoType (297)
#endif

/* ns3__SubscriptionInfoType has binding name 'ns3__SubscriptionInfoType' for type 'ns3:SubscriptionInfoType' */
#ifndef SOAP_TYPE_ns3__SubscriptionInfoType
#define SOAP_TYPE_ns3__SubscriptionInfoType (296)
#endif

/* ns3__SubscriptionTermsType has binding name 'ns3__SubscriptionTermsType' for type 'ns3:SubscriptionTermsType' */
#ifndef SOAP_TYPE_ns3__SubscriptionTermsType
#define SOAP_TYPE_ns3__SubscriptionTermsType (295)
#endif

/* ns3__PaymentInfoType has binding name 'ns3__PaymentInfoType' for type 'ns3:PaymentInfoType' */
#ifndef SOAP_TYPE_ns3__PaymentInfoType
#define SOAP_TYPE_ns3__PaymentInfoType (294)
#endif

/* ns3__OfferDetailsType has binding name 'ns3__OfferDetailsType' for type 'ns3:OfferDetailsType' */
#ifndef SOAP_TYPE_ns3__OfferDetailsType
#define SOAP_TYPE_ns3__OfferDetailsType (293)
#endif

/* ns3__BMLOfferInfoType has binding name 'ns3__BMLOfferInfoType' for type 'ns3:BMLOfferInfoType' */
#ifndef SOAP_TYPE_ns3__BMLOfferInfoType
#define SOAP_TYPE_ns3__BMLOfferInfoType (292)
#endif

/* ns3__InstrumentDetailsType has binding name 'ns3__InstrumentDetailsType' for type 'ns3:InstrumentDetailsType' */
#ifndef SOAP_TYPE_ns3__InstrumentDetailsType
#define SOAP_TYPE_ns3__InstrumentDetailsType (291)
#endif

/* ns3__PayeeInfoType has binding name 'ns3__PayeeInfoType' for type 'ns3:PayeeInfoType' */
#ifndef SOAP_TYPE_ns3__PayeeInfoType
#define SOAP_TYPE_ns3__PayeeInfoType (290)
#endif

/* ns3__PayerInfoType has binding name 'ns3__PayerInfoType' for type 'ns3:PayerInfoType' */
#ifndef SOAP_TYPE_ns3__PayerInfoType
#define SOAP_TYPE_ns3__PayerInfoType (289)
#endif

/* ns3__ReceiverInfoType has binding name 'ns3__ReceiverInfoType' for type 'ns3:ReceiverInfoType' */
#ifndef SOAP_TYPE_ns3__ReceiverInfoType
#define SOAP_TYPE_ns3__ReceiverInfoType (288)
#endif

/* ns3__PaymentTransactionType has binding name 'ns3__PaymentTransactionType' for type 'ns3:PaymentTransactionType' */
#ifndef SOAP_TYPE_ns3__PaymentTransactionType
#define SOAP_TYPE_ns3__PaymentTransactionType (287)
#endif

/* ns3__MerchantPullPaymentType has binding name 'ns3__MerchantPullPaymentType' for type 'ns3:MerchantPullPaymentType' */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentType
#define SOAP_TYPE_ns3__MerchantPullPaymentType (286)
#endif

/* ns3__TaxInfoType has binding name 'ns3__TaxInfoType' for type 'ns3:TaxInfoType' */
#ifndef SOAP_TYPE_ns3__TaxInfoType
#define SOAP_TYPE_ns3__TaxInfoType (285)
#endif

/* ns3__ShippingInfoType has binding name 'ns3__ShippingInfoType' for type 'ns3:ShippingInfoType' */
#ifndef SOAP_TYPE_ns3__ShippingInfoType
#define SOAP_TYPE_ns3__ShippingInfoType (284)
#endif

/* ns3__PaymentTransactionSearchResultType has binding name 'ns3__PaymentTransactionSearchResultType' for type 'ns3:PaymentTransactionSearchResultType' */
#ifndef SOAP_TYPE_ns3__PaymentTransactionSearchResultType
#define SOAP_TYPE_ns3__PaymentTransactionSearchResultType (283)
#endif

/* ns3__MerchantPullInfoType has binding name 'ns3__MerchantPullInfoType' for type 'ns3:MerchantPullInfoType' */
#ifndef SOAP_TYPE_ns3__MerchantPullInfoType
#define SOAP_TYPE_ns3__MerchantPullInfoType (282)
#endif

/* ns3__MerchantPullPaymentResponseType has binding name 'ns3__MerchantPullPaymentResponseType' for type 'ns3:MerchantPullPaymentResponseType' */
#ifndef SOAP_TYPE_ns3__MerchantPullPaymentResponseType
#define SOAP_TYPE_ns3__MerchantPullPaymentResponseType (281)
#endif

/* ns3__BAUpdateResponseDetailsType has binding name 'ns3__BAUpdateResponseDetailsType' for type 'ns3:BAUpdateResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__BAUpdateResponseDetailsType
#define SOAP_TYPE_ns3__BAUpdateResponseDetailsType (280)
#endif

/* ns3__GetAccessPermissionDetailsResponseDetailsType has binding name 'ns3__GetAccessPermissionDetailsResponseDetailsType' for type 'ns3:GetAccessPermissionDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetAccessPermissionDetailsResponseDetailsType (279)
#endif

/* ns3__SetAccessPermissionsRequestDetailsType has binding name 'ns3__SetAccessPermissionsRequestDetailsType' for type 'ns3:SetAccessPermissionsRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType
#define SOAP_TYPE_ns3__SetAccessPermissionsRequestDetailsType (278)
#endif

/* ns3__GetAuthDetailsResponseDetailsType has binding name 'ns3__GetAuthDetailsResponseDetailsType' for type 'ns3:GetAuthDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetAuthDetailsResponseDetailsType (277)
#endif

/* ns3__SetAuthFlowParamRequestDetailsType has binding name 'ns3__SetAuthFlowParamRequestDetailsType' for type 'ns3:SetAuthFlowParamRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType
#define SOAP_TYPE_ns3__SetAuthFlowParamRequestDetailsType (276)
#endif

/* ns3__GetMobileStatusRequestDetailsType has binding name 'ns3__GetMobileStatusRequestDetailsType' for type 'ns3:GetMobileStatusRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType
#define SOAP_TYPE_ns3__GetMobileStatusRequestDetailsType (275)
#endif

/* ns3__CreateMobilePaymentRequestDetailsType has binding name 'ns3__CreateMobilePaymentRequestDetailsType' for type 'ns3:CreateMobilePaymentRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType
#define SOAP_TYPE_ns3__CreateMobilePaymentRequestDetailsType (274)
#endif

/* ns3__DoDirectPaymentRequestDetailsType has binding name 'ns3__DoDirectPaymentRequestDetailsType' for type 'ns3:DoDirectPaymentRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType
#define SOAP_TYPE_ns3__DoDirectPaymentRequestDetailsType (273)
#endif

/* ns3__DoCaptureResponseDetailsType has binding name 'ns3__DoCaptureResponseDetailsType' for type 'ns3:DoCaptureResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__DoCaptureResponseDetailsType
#define SOAP_TYPE_ns3__DoCaptureResponseDetailsType (272)
#endif

/* ns3__DoExpressCheckoutPaymentResponseDetailsType has binding name 'ns3__DoExpressCheckoutPaymentResponseDetailsType' for type 'ns3:DoExpressCheckoutPaymentResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_ns3__DoExpressCheckoutPaymentResponseDetailsType (271)
#endif

/* ns3__DoExpressCheckoutPaymentRequestDetailsType has binding name 'ns3__DoExpressCheckoutPaymentRequestDetailsType' for type 'ns3:DoExpressCheckoutPaymentRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType
#define SOAP_TYPE_ns3__DoExpressCheckoutPaymentRequestDetailsType (270)
#endif

/* ns3__AuthorizationResponseType has binding name 'ns3__AuthorizationResponseType' for type 'ns3:AuthorizationResponseType' */
#ifndef SOAP_TYPE_ns3__AuthorizationResponseType
#define SOAP_TYPE_ns3__AuthorizationResponseType (269)
#endif

/* ns3__SetDataResponseType has binding name 'ns3__SetDataResponseType' for type 'ns3:SetDataResponseType' */
#ifndef SOAP_TYPE_ns3__SetDataResponseType
#define SOAP_TYPE_ns3__SetDataResponseType (268)
#endif

/* ns3__ExecuteCheckoutOperationsResponseDetailsType has binding name 'ns3__ExecuteCheckoutOperationsResponseDetailsType' for type 'ns3:ExecuteCheckoutOperationsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType
#define SOAP_TYPE_ns3__ExecuteCheckoutOperationsResponseDetailsType (267)
#endif

/* ns3__GetExpressCheckoutDetailsResponseDetailsType has binding name 'ns3__GetExpressCheckoutDetailsResponseDetailsType' for type 'ns3:GetExpressCheckoutDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType
#define SOAP_TYPE_ns3__GetExpressCheckoutDetailsResponseDetailsType (266)
#endif

/* ns3__BillingAgreementDetailsType has binding name 'ns3__BillingAgreementDetailsType' for type 'ns3:BillingAgreementDetailsType' */
#ifndef SOAP_TYPE_ns3__BillingAgreementDetailsType
#define SOAP_TYPE_ns3__BillingAgreementDetailsType (265)
#endif

/* ns3__FundingSourceDetailsType has binding name 'ns3__FundingSourceDetailsType' for type 'ns3:FundingSourceDetailsType' */
#ifndef SOAP_TYPE_ns3__FundingSourceDetailsType
#define SOAP_TYPE_ns3__FundingSourceDetailsType (264)
#endif

/* ns3__IdentityTokenInfoType has binding name 'ns3__IdentityTokenInfoType' for type 'ns3:IdentityTokenInfoType' */
#ifndef SOAP_TYPE_ns3__IdentityTokenInfoType
#define SOAP_TYPE_ns3__IdentityTokenInfoType (263)
#endif

/* ns3__RememberMeIDInfoType has binding name 'ns3__RememberMeIDInfoType' for type 'ns3:RememberMeIDInfoType' */
#ifndef SOAP_TYPE_ns3__RememberMeIDInfoType
#define SOAP_TYPE_ns3__RememberMeIDInfoType (262)
#endif

/* ns3__MobileIDInfoType has binding name 'ns3__MobileIDInfoType' for type 'ns3:MobileIDInfoType' */
#ifndef SOAP_TYPE_ns3__MobileIDInfoType
#define SOAP_TYPE_ns3__MobileIDInfoType (261)
#endif

/* ns3__IdentificationInfoType has binding name 'ns3__IdentificationInfoType' for type 'ns3:IdentificationInfoType' */
#ifndef SOAP_TYPE_ns3__IdentificationInfoType
#define SOAP_TYPE_ns3__IdentificationInfoType (260)
#endif

/* ns3__BuyerDetailType has binding name 'ns3__BuyerDetailType' for type 'ns3:BuyerDetailType' */
#ifndef SOAP_TYPE_ns3__BuyerDetailType
#define SOAP_TYPE_ns3__BuyerDetailType (259)
#endif

/* ns3__PaymentDirectivesType has binding name 'ns3__PaymentDirectivesType' for type 'ns3:PaymentDirectivesType' */
#ifndef SOAP_TYPE_ns3__PaymentDirectivesType
#define SOAP_TYPE_ns3__PaymentDirectivesType (258)
#endif

/* ns3__OrderDetailsType has binding name 'ns3__OrderDetailsType' for type 'ns3:OrderDetailsType' */
#ifndef SOAP_TYPE_ns3__OrderDetailsType
#define SOAP_TYPE_ns3__OrderDetailsType (257)
#endif

/* ns3__InfoSharingDirectivesType has binding name 'ns3__InfoSharingDirectivesType' for type 'ns3:InfoSharingDirectivesType' */
#ifndef SOAP_TYPE_ns3__InfoSharingDirectivesType
#define SOAP_TYPE_ns3__InfoSharingDirectivesType (256)
#endif

/* ns3__BillingApprovalDetailsType has binding name 'ns3__BillingApprovalDetailsType' for type 'ns3:BillingApprovalDetailsType' */
#ifndef SOAP_TYPE_ns3__BillingApprovalDetailsType
#define SOAP_TYPE_ns3__BillingApprovalDetailsType (255)
#endif

/* ns3__AuthorizationRequestType has binding name 'ns3__AuthorizationRequestType' for type 'ns3:AuthorizationRequestType' */
#ifndef SOAP_TYPE_ns3__AuthorizationRequestType
#define SOAP_TYPE_ns3__AuthorizationRequestType (254)
#endif

/* ns3__SetDataRequestType has binding name 'ns3__SetDataRequestType' for type 'ns3:SetDataRequestType' */
#ifndef SOAP_TYPE_ns3__SetDataRequestType
#define SOAP_TYPE_ns3__SetDataRequestType (253)
#endif

/* ns3__ExecuteCheckoutOperationsRequestDetailsType has binding name 'ns3__ExecuteCheckoutOperationsRequestDetailsType' for type 'ns3:ExecuteCheckoutOperationsRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType
#define SOAP_TYPE_ns3__ExecuteCheckoutOperationsRequestDetailsType (252)
#endif

/* ns3__SetExpressCheckoutRequestDetailsType has binding name 'ns3__SetExpressCheckoutRequestDetailsType' for type 'ns3:SetExpressCheckoutRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType
#define SOAP_TYPE_ns3__SetExpressCheckoutRequestDetailsType (251)
#endif

/* ns3__GetIncentiveEvaluationResponseDetailsType has binding name 'ns3__GetIncentiveEvaluationResponseDetailsType' for type 'ns3:GetIncentiveEvaluationResponseDetailsType' */
#ifndef SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType
#define SOAP_TYPE_ns3__GetIncentiveEvaluationResponseDetailsType (250)
#endif

/* ns3__GetIncentiveEvaluationRequestDetailsType has binding name 'ns3__GetIncentiveEvaluationRequestDetailsType' for type 'ns3:GetIncentiveEvaluationRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType
#define SOAP_TYPE_ns3__GetIncentiveEvaluationRequestDetailsType (249)
#endif

/* ns3__IncentiveRequestDetailsType has binding name 'ns3__IncentiveRequestDetailsType' for type 'ns3:IncentiveRequestDetailsType' */
#ifndef SOAP_TYPE_ns3__IncentiveRequestDetailsType
#define SOAP_TYPE_ns3__IncentiveRequestDetailsType (248)
#endif

/* ns3__IncentiveBucketType has binding name 'ns3__IncentiveBucketType' for type 'ns3:IncentiveBucketType' */
#ifndef SOAP_TYPE_ns3__IncentiveBucketType
#define SOAP_TYPE_ns3__IncentiveBucketType (247)
#endif

/* ns3__IncentiveItemType has binding name 'ns3__IncentiveItemType' for type 'ns3:IncentiveItemType' */
#ifndef SOAP_TYPE_ns3__IncentiveItemType
#define SOAP_TYPE_ns3__IncentiveItemType (246)
#endif

/* ns3__IncentiveDetailType has binding name 'ns3__IncentiveDetailType' for type 'ns3:IncentiveDetailType' */
#ifndef SOAP_TYPE_ns3__IncentiveDetailType
#define SOAP_TYPE_ns3__IncentiveDetailType (245)
#endif

/* ns3__IncentiveAppliedToType has binding name 'ns3__IncentiveAppliedToType' for type 'ns3:IncentiveAppliedToType' */
#ifndef SOAP_TYPE_ns3__IncentiveAppliedToType
#define SOAP_TYPE_ns3__IncentiveAppliedToType (244)
#endif

/* ns3__PersonNameType has binding name 'ns3__PersonNameType' for type 'ns3:PersonNameType' */
#ifndef SOAP_TYPE_ns3__PersonNameType
#define SOAP_TYPE_ns3__PersonNameType (243)
#endif

/* ns3__AddressType has binding name 'ns3__AddressType' for type 'ns3:AddressType' */
#ifndef SOAP_TYPE_ns3__AddressType
#define SOAP_TYPE_ns3__AddressType (242)
#endif

/* ns3__PhoneNumberType has binding name 'ns3__PhoneNumberType' for type 'ns3:PhoneNumberType' */
#ifndef SOAP_TYPE_ns3__PhoneNumberType
#define SOAP_TYPE_ns3__PhoneNumberType (241)
#endif

/* ns3__AbstractResponseType has binding name 'ns3__AbstractResponseType' for type 'ns3:AbstractResponseType' */
#ifndef SOAP_TYPE_ns3__AbstractResponseType
#define SOAP_TYPE_ns3__AbstractResponseType (240)
#endif

/* ns3__AbstractRequestType has binding name 'ns3__AbstractRequestType' for type 'ns3:AbstractRequestType' */
#ifndef SOAP_TYPE_ns3__AbstractRequestType
#define SOAP_TYPE_ns3__AbstractRequestType (239)
#endif

/* ns3__FaultDetailsType has binding name 'ns3__FaultDetailsType' for type 'ns3:FaultDetailsType' */
#ifndef SOAP_TYPE_ns3__FaultDetailsType
#define SOAP_TYPE_ns3__FaultDetailsType (238)
#endif

/* ns3__ErrorType has binding name 'ns3__ErrorType' for type 'ns3:ErrorType' */
#ifndef SOAP_TYPE_ns3__ErrorType
#define SOAP_TYPE_ns3__ErrorType (237)
#endif

/* ns3__ErrorParameterType has binding name 'ns3__ErrorParameterType' for type 'ns3:ErrorParameterType' */
#ifndef SOAP_TYPE_ns3__ErrorParameterType
#define SOAP_TYPE_ns3__ErrorParameterType (236)
#endif

/* ns3__PaginationResultType has binding name 'ns3__PaginationResultType' for type 'ns3:PaginationResultType' */
#ifndef SOAP_TYPE_ns3__PaginationResultType
#define SOAP_TYPE_ns3__PaginationResultType (235)
#endif

/* ns3__ModifiedFieldType has binding name 'ns3__ModifiedFieldType' for type 'ns3:ModifiedFieldType' */
#ifndef SOAP_TYPE_ns3__ModifiedFieldType
#define SOAP_TYPE_ns3__ModifiedFieldType (234)
#endif

/* ns3__PaginationType has binding name 'ns3__PaginationType' for type 'ns3:PaginationType' */
#ifndef SOAP_TYPE_ns3__PaginationType
#define SOAP_TYPE_ns3__PaginationType (233)
#endif

/* ns3__CategoryArrayType has binding name 'ns3__CategoryArrayType' for type 'ns3:CategoryArrayType' */
#ifndef SOAP_TYPE_ns3__CategoryArrayType
#define SOAP_TYPE_ns3__CategoryArrayType (232)
#endif

/* ns3__ItemArrayType has binding name 'ns3__ItemArrayType' for type 'ns3:ItemArrayType' */
#ifndef SOAP_TYPE_ns3__ItemArrayType
#define SOAP_TYPE_ns3__ItemArrayType (231)
#endif

/* ns3__SchedulingInfoType has binding name 'ns3__SchedulingInfoType' for type 'ns3:SchedulingInfoType' */
#ifndef SOAP_TYPE_ns3__SchedulingInfoType
#define SOAP_TYPE_ns3__SchedulingInfoType (230)
#endif

/* ns3__VATDetailsType has binding name 'ns3__VATDetailsType' for type 'ns3:VATDetailsType' */
#ifndef SOAP_TYPE_ns3__VATDetailsType
#define SOAP_TYPE_ns3__VATDetailsType (229)
#endif

/* ns3__UserType has binding name 'ns3__UserType' for type 'ns3:UserType' */
#ifndef SOAP_TYPE_ns3__UserType
#define SOAP_TYPE_ns3__UserType (228)
#endif

/* ns3__TransactionStatusType has binding name 'ns3__TransactionStatusType' for type 'ns3:TransactionStatusType' */
#ifndef SOAP_TYPE_ns3__TransactionStatusType
#define SOAP_TYPE_ns3__TransactionStatusType (227)
#endif

/* ns3__PaymentType has binding name 'ns3__PaymentType' for type 'ns3:PaymentType' */
#ifndef SOAP_TYPE_ns3__PaymentType
#define SOAP_TYPE_ns3__PaymentType (226)
#endif

/* ns3__PaymentMeansType has binding name 'ns3__PaymentMeansType' for type 'ns3:PaymentMeansType' */
#ifndef SOAP_TYPE_ns3__PaymentMeansType
#define SOAP_TYPE_ns3__PaymentMeansType (225)
#endif

/* ns3__TransactionType has binding name 'ns3__TransactionType' for type 'ns3:TransactionType' */
#ifndef SOAP_TYPE_ns3__TransactionType
#define SOAP_TYPE_ns3__TransactionType (224)
#endif

/* ns3__TransactionsType has binding name 'ns3__TransactionsType' for type 'ns3:TransactionsType' */
#ifndef SOAP_TYPE_ns3__TransactionsType
#define SOAP_TYPE_ns3__TransactionsType (223)
#endif

/* ns3__ItemType has binding name 'ns3__ItemType' for type 'ns3:ItemType' */
#ifndef SOAP_TYPE_ns3__ItemType
#define SOAP_TYPE_ns3__ItemType (222)
#endif

/* ns3__ListingDetailsType has binding name 'ns3__ListingDetailsType' for type 'ns3:ListingDetailsType' */
#ifndef SOAP_TYPE_ns3__ListingDetailsType
#define SOAP_TYPE_ns3__ListingDetailsType (221)
#endif

/* ns3__ReviseStatusType has binding name 'ns3__ReviseStatusType' for type 'ns3:ReviseStatusType' */
#ifndef SOAP_TYPE_ns3__ReviseStatusType
#define SOAP_TYPE_ns3__ReviseStatusType (220)
#endif

/* ns3__SellingStatusType has binding name 'ns3__SellingStatusType' for type 'ns3:SellingStatusType' */
#ifndef SOAP_TYPE_ns3__SellingStatusType
#define SOAP_TYPE_ns3__SellingStatusType (219)
#endif

/* ns3__CharityType has binding name 'ns3__CharityType' for type 'ns3:CharityType' */
#ifndef SOAP_TYPE_ns3__CharityType
#define SOAP_TYPE_ns3__CharityType (218)
#endif

/* ns3__ListingDesignerType has binding name 'ns3__ListingDesignerType' for type 'ns3:ListingDesignerType' */
#ifndef SOAP_TYPE_ns3__ListingDesignerType
#define SOAP_TYPE_ns3__ListingDesignerType (217)
#endif

/* ns3__StorefrontType has binding name 'ns3__StorefrontType' for type 'ns3:StorefrontType' */
#ifndef SOAP_TYPE_ns3__StorefrontType
#define SOAP_TYPE_ns3__StorefrontType (216)
#endif

/* ns3__CategoryType has binding name 'ns3__CategoryType' for type 'ns3:CategoryType' */
#ifndef SOAP_TYPE_ns3__CategoryType
#define SOAP_TYPE_ns3__CategoryType (215)
#endif

/* ns3__ListOfAttributeSetType has binding name 'ns3__ListOfAttributeSetType' for type 'ns3:ListOfAttributeSetType' */
#ifndef SOAP_TYPE_ns3__ListOfAttributeSetType
#define SOAP_TYPE_ns3__ListOfAttributeSetType (214)
#endif

/* ns3__AttributeSetType has binding name 'ns3__AttributeSetType' for type 'ns3:AttributeSetType' */
#ifndef SOAP_TYPE_ns3__AttributeSetType
#define SOAP_TYPE_ns3__AttributeSetType (213)
#endif

/* ns3__AttributeType has binding name 'ns3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (212)
#endif

/* ns3__ValType has binding name 'ns3__ValType' for type 'ns3:ValType' */
#ifndef SOAP_TYPE_ns3__ValType
#define SOAP_TYPE_ns3__ValType (211)
#endif

/* ns3__VendorHostedPictureType has binding name 'ns3__VendorHostedPictureType' for type 'ns3:VendorHostedPictureType' */
#ifndef SOAP_TYPE_ns3__VendorHostedPictureType
#define SOAP_TYPE_ns3__VendorHostedPictureType (210)
#endif

/* ns3__SiteHostedPictureType has binding name 'ns3__SiteHostedPictureType' for type 'ns3:SiteHostedPictureType' */
#ifndef SOAP_TYPE_ns3__SiteHostedPictureType
#define SOAP_TYPE_ns3__SiteHostedPictureType (209)
#endif

/* ns3__ShippingDetailsType has binding name 'ns3__ShippingDetailsType' for type 'ns3:ShippingDetailsType' */
#ifndef SOAP_TYPE_ns3__ShippingDetailsType
#define SOAP_TYPE_ns3__ShippingDetailsType (208)
#endif

/* ns3__SalesTaxType has binding name 'ns3__SalesTaxType' for type 'ns3:SalesTaxType' */
#ifndef SOAP_TYPE_ns3__SalesTaxType
#define SOAP_TYPE_ns3__SalesTaxType (207)
#endif

/* ns3__FlatShippingRateType has binding name 'ns3__FlatShippingRateType' for type 'ns3:FlatShippingRateType' */
#ifndef SOAP_TYPE_ns3__FlatShippingRateType
#define SOAP_TYPE_ns3__FlatShippingRateType (206)
#endif

/* ns3__CalculatedShippingRateType has binding name 'ns3__CalculatedShippingRateType' for type 'ns3:CalculatedShippingRateType' */
#ifndef SOAP_TYPE_ns3__CalculatedShippingRateType
#define SOAP_TYPE_ns3__CalculatedShippingRateType (205)
#endif

/* ns3__ShippingCarrierDetailsType has binding name 'ns3__ShippingCarrierDetailsType' for type 'ns3:ShippingCarrierDetailsType' */
#ifndef SOAP_TYPE_ns3__ShippingCarrierDetailsType
#define SOAP_TYPE_ns3__ShippingCarrierDetailsType (204)
#endif

/* ns3__FeesType has binding name 'ns3__FeesType' for type 'ns3:FeesType' */
#ifndef SOAP_TYPE_ns3__FeesType
#define SOAP_TYPE_ns3__FeesType (203)
#endif

/* ns3__FeeType has binding name 'ns3__FeeType' for type 'ns3:FeeType' */
#ifndef SOAP_TYPE_ns3__FeeType
#define SOAP_TYPE_ns3__FeeType (202)
#endif

/* ns3__SellerType has binding name 'ns3__SellerType' for type 'ns3:SellerType' */
#ifndef SOAP_TYPE_ns3__SellerType
#define SOAP_TYPE_ns3__SellerType (201)
#endif

/* ns3__BuyerType has binding name 'ns3__BuyerType' for type 'ns3:BuyerType' */
#ifndef SOAP_TYPE_ns3__BuyerType
#define SOAP_TYPE_ns3__BuyerType (200)
#endif

/* ns3__AccountSummaryType has binding name 'ns3__AccountSummaryType' for type 'ns3:AccountSummaryType' */
#ifndef SOAP_TYPE_ns3__AccountSummaryType
#define SOAP_TYPE_ns3__AccountSummaryType (199)
#endif

/* ns3__CrossPromotionsType has binding name 'ns3__CrossPromotionsType' for type 'ns3:CrossPromotionsType' */
#ifndef SOAP_TYPE_ns3__CrossPromotionsType
#define SOAP_TYPE_ns3__CrossPromotionsType (198)
#endif

/* ns3__PromotedItemType has binding name 'ns3__PromotedItemType' for type 'ns3:PromotedItemType' */
#ifndef SOAP_TYPE_ns3__PromotedItemType
#define SOAP_TYPE_ns3__PromotedItemType (197)
#endif

/* ns3__AdditionalAccountType has binding name 'ns3__AdditionalAccountType' for type 'ns3:AdditionalAccountType' */
#ifndef SOAP_TYPE_ns3__AdditionalAccountType
#define SOAP_TYPE_ns3__AdditionalAccountType (196)
#endif

/* ns3__AccountEntryType has binding name 'ns3__AccountEntryType' for type 'ns3:AccountEntryType' */
#ifndef SOAP_TYPE_ns3__AccountEntryType
#define SOAP_TYPE_ns3__AccountEntryType (195)
#endif

/* ns2__QuantityType has binding name 'ns2__QuantityType' for type 'ns2:QuantityType' */
#ifndef SOAP_TYPE_ns2__QuantityType
#define SOAP_TYPE_ns2__QuantityType (194)
#endif

/* ns2__MeasureType has binding name 'ns2__MeasureType' for type 'ns2:MeasureType' */
#ifndef SOAP_TYPE_ns2__MeasureType
#define SOAP_TYPE_ns2__MeasureType (193)
#endif

/* ns2__BasicAmountType has binding name 'ns2__BasicAmountType' for type 'ns2:BasicAmountType' */
#ifndef SOAP_TYPE_ns2__BasicAmountType
#define SOAP_TYPE_ns2__BasicAmountType (192)
#endif

/* ns2__AmountType has binding name 'ns2__AmountType' for type 'ns2:AmountType' */
#ifndef SOAP_TYPE_ns2__AmountType
#define SOAP_TYPE_ns2__AmountType (191)
#endif

/* _ns1__ExternalRememberMeOptOutReq has binding name '_ns1__ExternalRememberMeOptOutReq' for type '' */
#ifndef SOAP_TYPE__ns1__ExternalRememberMeOptOutReq
#define SOAP_TYPE__ns1__ExternalRememberMeOptOutReq (190)
#endif

/* _ns1__ReverseTransactionReq has binding name '_ns1__ReverseTransactionReq' for type '' */
#ifndef SOAP_TYPE__ns1__ReverseTransactionReq
#define SOAP_TYPE__ns1__ReverseTransactionReq (189)
#endif

/* _ns1__GetPalDetailsReq has binding name '_ns1__GetPalDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetPalDetailsReq
#define SOAP_TYPE__ns1__GetPalDetailsReq (188)
#endif

/* _ns1__UpdateRecurringPaymentsProfileReq has binding name '_ns1__UpdateRecurringPaymentsProfileReq' for type '' */
#ifndef SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq
#define SOAP_TYPE__ns1__UpdateRecurringPaymentsProfileReq (187)
#endif

/* _ns1__BillOutstandingAmountReq has binding name '_ns1__BillOutstandingAmountReq' for type '' */
#ifndef SOAP_TYPE__ns1__BillOutstandingAmountReq
#define SOAP_TYPE__ns1__BillOutstandingAmountReq (186)
#endif

/* _ns1__ManageRecurringPaymentsProfileStatusReq has binding name '_ns1__ManageRecurringPaymentsProfileStatusReq' for type '' */
#ifndef SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq
#define SOAP_TYPE__ns1__ManageRecurringPaymentsProfileStatusReq (185)
#endif

/* _ns1__GetRecurringPaymentsProfileDetailsReq has binding name '_ns1__GetRecurringPaymentsProfileDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq
#define SOAP_TYPE__ns1__GetRecurringPaymentsProfileDetailsReq (184)
#endif

/* _ns1__CreateRecurringPaymentsProfileReq has binding name '_ns1__CreateRecurringPaymentsProfileReq' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq
#define SOAP_TYPE__ns1__CreateRecurringPaymentsProfileReq (183)
#endif

/* _ns1__DoNonReferencedCreditReq has binding name '_ns1__DoNonReferencedCreditReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoNonReferencedCreditReq
#define SOAP_TYPE__ns1__DoNonReferencedCreditReq (182)
#endif

/* _ns1__DoReferenceTransactionReq has binding name '_ns1__DoReferenceTransactionReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoReferenceTransactionReq
#define SOAP_TYPE__ns1__DoReferenceTransactionReq (181)
#endif

/* _ns1__CreateBillingAgreementReq has binding name '_ns1__CreateBillingAgreementReq' for type '' */
#ifndef SOAP_TYPE__ns1__CreateBillingAgreementReq
#define SOAP_TYPE__ns1__CreateBillingAgreementReq (180)
#endif

/* _ns1__GetBillingAgreementCustomerDetailsReq has binding name '_ns1__GetBillingAgreementCustomerDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq
#define SOAP_TYPE__ns1__GetBillingAgreementCustomerDetailsReq (179)
#endif

/* _ns1__SetCustomerBillingAgreementReq has binding name '_ns1__SetCustomerBillingAgreementReq' for type '' */
#ifndef SOAP_TYPE__ns1__SetCustomerBillingAgreementReq
#define SOAP_TYPE__ns1__SetCustomerBillingAgreementReq (178)
#endif

/* _ns1__GetBalanceReq has binding name '_ns1__GetBalanceReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetBalanceReq
#define SOAP_TYPE__ns1__GetBalanceReq (177)
#endif

/* _ns1__DoMobileCheckoutPaymentReq has binding name '_ns1__DoMobileCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoMobileCheckoutPaymentReq (176)
#endif

/* _ns1__SetMobileCheckoutReq has binding name '_ns1__SetMobileCheckoutReq' for type '' */
#ifndef SOAP_TYPE__ns1__SetMobileCheckoutReq
#define SOAP_TYPE__ns1__SetMobileCheckoutReq (175)
#endif

/* _ns1__GetMobileStatusReq has binding name '_ns1__GetMobileStatusReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetMobileStatusReq
#define SOAP_TYPE__ns1__GetMobileStatusReq (174)
#endif

/* _ns1__CreateMobilePaymentReq has binding name '_ns1__CreateMobilePaymentReq' for type '' */
#ifndef SOAP_TYPE__ns1__CreateMobilePaymentReq
#define SOAP_TYPE__ns1__CreateMobilePaymentReq (173)
#endif

/* _ns1__DoUATPAuthorizationReq has binding name '_ns1__DoUATPAuthorizationReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoUATPAuthorizationReq
#define SOAP_TYPE__ns1__DoUATPAuthorizationReq (172)
#endif

/* _ns1__UpdateAuthorizationReq has binding name '_ns1__UpdateAuthorizationReq' for type '' */
#ifndef SOAP_TYPE__ns1__UpdateAuthorizationReq
#define SOAP_TYPE__ns1__UpdateAuthorizationReq (171)
#endif

/* _ns1__DoAuthorizationReq has binding name '_ns1__DoAuthorizationReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoAuthorizationReq
#define SOAP_TYPE__ns1__DoAuthorizationReq (170)
#endif

/* _ns1__DoVoidReq has binding name '_ns1__DoVoidReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoVoidReq
#define SOAP_TYPE__ns1__DoVoidReq (169)
#endif

/* _ns1__DoReauthorizationReq has binding name '_ns1__DoReauthorizationReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoReauthorizationReq
#define SOAP_TYPE__ns1__DoReauthorizationReq (168)
#endif

/* _ns1__DoCaptureReq has binding name '_ns1__DoCaptureReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoCaptureReq
#define SOAP_TYPE__ns1__DoCaptureReq (167)
#endif

/* _ns1__DoCancelReq has binding name '_ns1__DoCancelReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoCancelReq
#define SOAP_TYPE__ns1__DoCancelReq (166)
#endif

/* _ns1__DoDirectPaymentReq has binding name '_ns1__DoDirectPaymentReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoDirectPaymentReq
#define SOAP_TYPE__ns1__DoDirectPaymentReq (165)
#endif

/* _ns1__ManagePendingTransactionStatusReq has binding name '_ns1__ManagePendingTransactionStatusReq' for type '' */
#ifndef SOAP_TYPE__ns1__ManagePendingTransactionStatusReq
#define SOAP_TYPE__ns1__ManagePendingTransactionStatusReq (164)
#endif

/* _ns1__DoUATPExpressCheckoutPaymentReq has binding name '_ns1__DoUATPExpressCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoUATPExpressCheckoutPaymentReq (163)
#endif

/* _ns1__DoExpressCheckoutPaymentReq has binding name '_ns1__DoExpressCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq
#define SOAP_TYPE__ns1__DoExpressCheckoutPaymentReq (162)
#endif

/* _ns1__GetExpressCheckoutDetailsReq has binding name '_ns1__GetExpressCheckoutDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq
#define SOAP_TYPE__ns1__GetExpressCheckoutDetailsReq (161)
#endif

/* _ns1__ExecuteCheckoutOperationsReq has binding name '_ns1__ExecuteCheckoutOperationsReq' for type '' */
#ifndef SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq
#define SOAP_TYPE__ns1__ExecuteCheckoutOperationsReq (160)
#endif

/* _ns1__SetExpressCheckoutReq has binding name '_ns1__SetExpressCheckoutReq' for type '' */
#ifndef SOAP_TYPE__ns1__SetExpressCheckoutReq
#define SOAP_TYPE__ns1__SetExpressCheckoutReq (159)
#endif

/* _ns1__GetIncentiveEvaluationReq has binding name '_ns1__GetIncentiveEvaluationReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetIncentiveEvaluationReq
#define SOAP_TYPE__ns1__GetIncentiveEvaluationReq (158)
#endif

/* _ns1__GetAccessPermissionDetailsReq has binding name '_ns1__GetAccessPermissionDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetAccessPermissionDetailsReq
#define SOAP_TYPE__ns1__GetAccessPermissionDetailsReq (157)
#endif

/* _ns1__UpdateAccessPermissionsReq has binding name '_ns1__UpdateAccessPermissionsReq' for type '' */
#ifndef SOAP_TYPE__ns1__UpdateAccessPermissionsReq
#define SOAP_TYPE__ns1__UpdateAccessPermissionsReq (156)
#endif

/* _ns1__SetAccessPermissionsReq has binding name '_ns1__SetAccessPermissionsReq' for type '' */
#ifndef SOAP_TYPE__ns1__SetAccessPermissionsReq
#define SOAP_TYPE__ns1__SetAccessPermissionsReq (155)
#endif

/* _ns1__GetAuthDetailsReq has binding name '_ns1__GetAuthDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetAuthDetailsReq
#define SOAP_TYPE__ns1__GetAuthDetailsReq (154)
#endif

/* _ns1__SetAuthFlowParamReq has binding name '_ns1__SetAuthFlowParamReq' for type '' */
#ifndef SOAP_TYPE__ns1__SetAuthFlowParamReq
#define SOAP_TYPE__ns1__SetAuthFlowParamReq (153)
#endif

/* _ns1__GetBoardingDetailsReq has binding name '_ns1__GetBoardingDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetBoardingDetailsReq
#define SOAP_TYPE__ns1__GetBoardingDetailsReq (152)
#endif

/* _ns1__EnterBoardingReq has binding name '_ns1__EnterBoardingReq' for type '' */
#ifndef SOAP_TYPE__ns1__EnterBoardingReq
#define SOAP_TYPE__ns1__EnterBoardingReq (151)
#endif

/* _ns1__AddressVerifyReq has binding name '_ns1__AddressVerifyReq' for type '' */
#ifndef SOAP_TYPE__ns1__AddressVerifyReq
#define SOAP_TYPE__ns1__AddressVerifyReq (150)
#endif

/* _ns1__BillAgreementUpdateReq has binding name '_ns1__BillAgreementUpdateReq' for type '' */
#ifndef SOAP_TYPE__ns1__BillAgreementUpdateReq
#define SOAP_TYPE__ns1__BillAgreementUpdateReq (149)
#endif

/* _ns1__MassPayReq has binding name '_ns1__MassPayReq' for type '' */
#ifndef SOAP_TYPE__ns1__MassPayReq
#define SOAP_TYPE__ns1__MassPayReq (148)
#endif

/* _ns1__TransactionSearchReq has binding name '_ns1__TransactionSearchReq' for type '' */
#ifndef SOAP_TYPE__ns1__TransactionSearchReq
#define SOAP_TYPE__ns1__TransactionSearchReq (147)
#endif

/* _ns1__BillUserReq has binding name '_ns1__BillUserReq' for type '' */
#ifndef SOAP_TYPE__ns1__BillUserReq
#define SOAP_TYPE__ns1__BillUserReq (146)
#endif

/* _ns1__GetTransactionDetailsReq has binding name '_ns1__GetTransactionDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__GetTransactionDetailsReq
#define SOAP_TYPE__ns1__GetTransactionDetailsReq (145)
#endif

/* _ns1__CancelRecoupReq has binding name '_ns1__CancelRecoupReq' for type '' */
#ifndef SOAP_TYPE__ns1__CancelRecoupReq
#define SOAP_TYPE__ns1__CancelRecoupReq (144)
#endif

/* _ns1__CompleteRecoupReq has binding name '_ns1__CompleteRecoupReq' for type '' */
#ifndef SOAP_TYPE__ns1__CompleteRecoupReq
#define SOAP_TYPE__ns1__CompleteRecoupReq (143)
#endif

/* _ns1__InitiateRecoupReq has binding name '_ns1__InitiateRecoupReq' for type '' */
#ifndef SOAP_TYPE__ns1__InitiateRecoupReq
#define SOAP_TYPE__ns1__InitiateRecoupReq (142)
#endif

/* _ns1__RefundTransactionReq has binding name '_ns1__RefundTransactionReq' for type '' */
#ifndef SOAP_TYPE__ns1__RefundTransactionReq
#define SOAP_TYPE__ns1__RefundTransactionReq (141)
#endif

/* _ns1__BMButtonSearchReq has binding name '_ns1__BMButtonSearchReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMButtonSearchReq
#define SOAP_TYPE__ns1__BMButtonSearchReq (140)
#endif

/* _ns1__BMGetInventoryReq has binding name '_ns1__BMGetInventoryReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMGetInventoryReq
#define SOAP_TYPE__ns1__BMGetInventoryReq (139)
#endif

/* _ns1__BMSetInventoryReq has binding name '_ns1__BMSetInventoryReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMSetInventoryReq
#define SOAP_TYPE__ns1__BMSetInventoryReq (138)
#endif

/* _ns1__BMGetButtonDetailsReq has binding name '_ns1__BMGetButtonDetailsReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMGetButtonDetailsReq
#define SOAP_TYPE__ns1__BMGetButtonDetailsReq (137)
#endif

/* _ns1__BMManageButtonStatusReq has binding name '_ns1__BMManageButtonStatusReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMManageButtonStatusReq
#define SOAP_TYPE__ns1__BMManageButtonStatusReq (136)
#endif

/* _ns1__BMUpdateButtonReq has binding name '_ns1__BMUpdateButtonReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMUpdateButtonReq
#define SOAP_TYPE__ns1__BMUpdateButtonReq (135)
#endif

/* _ns1__BMCreateButtonReq has binding name '_ns1__BMCreateButtonReq' for type '' */
#ifndef SOAP_TYPE__ns1__BMCreateButtonReq
#define SOAP_TYPE__ns1__BMCreateButtonReq (134)
#endif

/* ns1__ExternalRememberMeOptOutResponseType has binding name 'ns1__ExternalRememberMeOptOutResponseType' for type 'ns1:ExternalRememberMeOptOutResponseType' */
#ifndef SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType
#define SOAP_TYPE_ns1__ExternalRememberMeOptOutResponseType (133)
#endif

/* ns1__ExternalRememberMeOptOutRequestType has binding name 'ns1__ExternalRememberMeOptOutRequestType' for type 'ns1:ExternalRememberMeOptOutRequestType' */
#ifndef SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType
#define SOAP_TYPE_ns1__ExternalRememberMeOptOutRequestType (132)
#endif

/* ns1__ReverseTransactionResponseType has binding name 'ns1__ReverseTransactionResponseType' for type 'ns1:ReverseTransactionResponseType' */
#ifndef SOAP_TYPE_ns1__ReverseTransactionResponseType
#define SOAP_TYPE_ns1__ReverseTransactionResponseType (131)
#endif

/* ns1__ReverseTransactionRequestType has binding name 'ns1__ReverseTransactionRequestType' for type 'ns1:ReverseTransactionRequestType' */
#ifndef SOAP_TYPE_ns1__ReverseTransactionRequestType
#define SOAP_TYPE_ns1__ReverseTransactionRequestType (130)
#endif

/* ns1__GetPalDetailsResponseType has binding name 'ns1__GetPalDetailsResponseType' for type 'ns1:GetPalDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetPalDetailsResponseType
#define SOAP_TYPE_ns1__GetPalDetailsResponseType (129)
#endif

/* ns1__GetPalDetailsRequestType has binding name 'ns1__GetPalDetailsRequestType' for type 'ns1:GetPalDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetPalDetailsRequestType
#define SOAP_TYPE_ns1__GetPalDetailsRequestType (128)
#endif

/* ns1__UpdateRecurringPaymentsProfileResponseType has binding name 'ns1__UpdateRecurringPaymentsProfileResponseType' for type 'ns1:UpdateRecurringPaymentsProfileResponseType' */
#ifndef SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType
#define SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileResponseType (127)
#endif

/* ns1__UpdateRecurringPaymentsProfileRequestType has binding name 'ns1__UpdateRecurringPaymentsProfileRequestType' for type 'ns1:UpdateRecurringPaymentsProfileRequestType' */
#ifndef SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_ns1__UpdateRecurringPaymentsProfileRequestType (126)
#endif

/* ns1__BillOutstandingAmountResponseType has binding name 'ns1__BillOutstandingAmountResponseType' for type 'ns1:BillOutstandingAmountResponseType' */
#ifndef SOAP_TYPE_ns1__BillOutstandingAmountResponseType
#define SOAP_TYPE_ns1__BillOutstandingAmountResponseType (125)
#endif

/* ns1__BillOutstandingAmountRequestType has binding name 'ns1__BillOutstandingAmountRequestType' for type 'ns1:BillOutstandingAmountRequestType' */
#ifndef SOAP_TYPE_ns1__BillOutstandingAmountRequestType
#define SOAP_TYPE_ns1__BillOutstandingAmountRequestType (124)
#endif

/* ns1__ManageRecurringPaymentsProfileStatusResponseType has binding name 'ns1__ManageRecurringPaymentsProfileStatusResponseType' for type 'ns1:ManageRecurringPaymentsProfileStatusResponseType' */
#ifndef SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType
#define SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusResponseType (123)
#endif

/* ns1__ManageRecurringPaymentsProfileStatusRequestType has binding name 'ns1__ManageRecurringPaymentsProfileStatusRequestType' for type 'ns1:ManageRecurringPaymentsProfileStatusRequestType' */
#ifndef SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType
#define SOAP_TYPE_ns1__ManageRecurringPaymentsProfileStatusRequestType (122)
#endif

/* ns1__GetRecurringPaymentsProfileDetailsResponseType has binding name 'ns1__GetRecurringPaymentsProfileDetailsResponseType' for type 'ns1:GetRecurringPaymentsProfileDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType
#define SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsResponseType (121)
#endif

/* ns1__GetRecurringPaymentsProfileDetailsRequestType has binding name 'ns1__GetRecurringPaymentsProfileDetailsRequestType' for type 'ns1:GetRecurringPaymentsProfileDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType
#define SOAP_TYPE_ns1__GetRecurringPaymentsProfileDetailsRequestType (120)
#endif

/* ns1__CreateRecurringPaymentsProfileResponseType has binding name 'ns1__CreateRecurringPaymentsProfileResponseType' for type 'ns1:CreateRecurringPaymentsProfileResponseType' */
#ifndef SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType
#define SOAP_TYPE_ns1__CreateRecurringPaymentsProfileResponseType (119)
#endif

/* ns1__CreateRecurringPaymentsProfileRequestType has binding name 'ns1__CreateRecurringPaymentsProfileRequestType' for type 'ns1:CreateRecurringPaymentsProfileRequestType' */
#ifndef SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_ns1__CreateRecurringPaymentsProfileRequestType (118)
#endif

/* ns1__DoNonReferencedCreditResponseType has binding name 'ns1__DoNonReferencedCreditResponseType' for type 'ns1:DoNonReferencedCreditResponseType' */
#ifndef SOAP_TYPE_ns1__DoNonReferencedCreditResponseType
#define SOAP_TYPE_ns1__DoNonReferencedCreditResponseType (117)
#endif

/* ns1__DoNonReferencedCreditRequestType has binding name 'ns1__DoNonReferencedCreditRequestType' for type 'ns1:DoNonReferencedCreditRequestType' */
#ifndef SOAP_TYPE_ns1__DoNonReferencedCreditRequestType
#define SOAP_TYPE_ns1__DoNonReferencedCreditRequestType (116)
#endif

/* ns1__DoReferenceTransactionResponseType has binding name 'ns1__DoReferenceTransactionResponseType' for type 'ns1:DoReferenceTransactionResponseType' */
#ifndef SOAP_TYPE_ns1__DoReferenceTransactionResponseType
#define SOAP_TYPE_ns1__DoReferenceTransactionResponseType (115)
#endif

/* ns1__DoReferenceTransactionRequestType has binding name 'ns1__DoReferenceTransactionRequestType' for type 'ns1:DoReferenceTransactionRequestType' */
#ifndef SOAP_TYPE_ns1__DoReferenceTransactionRequestType
#define SOAP_TYPE_ns1__DoReferenceTransactionRequestType (114)
#endif

/* ns1__CreateBillingAgreementResponseType has binding name 'ns1__CreateBillingAgreementResponseType' for type 'ns1:CreateBillingAgreementResponseType' */
#ifndef SOAP_TYPE_ns1__CreateBillingAgreementResponseType
#define SOAP_TYPE_ns1__CreateBillingAgreementResponseType (113)
#endif

/* ns1__CreateBillingAgreementRequestType has binding name 'ns1__CreateBillingAgreementRequestType' for type 'ns1:CreateBillingAgreementRequestType' */
#ifndef SOAP_TYPE_ns1__CreateBillingAgreementRequestType
#define SOAP_TYPE_ns1__CreateBillingAgreementRequestType (112)
#endif

/* ns1__GetBillingAgreementCustomerDetailsResponseType has binding name 'ns1__GetBillingAgreementCustomerDetailsResponseType' for type 'ns1:GetBillingAgreementCustomerDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType
#define SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsResponseType (111)
#endif

/* ns1__GetBillingAgreementCustomerDetailsRequestType has binding name 'ns1__GetBillingAgreementCustomerDetailsRequestType' for type 'ns1:GetBillingAgreementCustomerDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType
#define SOAP_TYPE_ns1__GetBillingAgreementCustomerDetailsRequestType (110)
#endif

/* ns1__SetCustomerBillingAgreementResponseType has binding name 'ns1__SetCustomerBillingAgreementResponseType' for type 'ns1:SetCustomerBillingAgreementResponseType' */
#ifndef SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType
#define SOAP_TYPE_ns1__SetCustomerBillingAgreementResponseType (109)
#endif

/* ns1__SetCustomerBillingAgreementRequestType has binding name 'ns1__SetCustomerBillingAgreementRequestType' for type 'ns1:SetCustomerBillingAgreementRequestType' */
#ifndef SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType
#define SOAP_TYPE_ns1__SetCustomerBillingAgreementRequestType (108)
#endif

/* ns1__GetBalanceResponseType has binding name 'ns1__GetBalanceResponseType' for type 'ns1:GetBalanceResponseType' */
#ifndef SOAP_TYPE_ns1__GetBalanceResponseType
#define SOAP_TYPE_ns1__GetBalanceResponseType (107)
#endif

/* ns1__GetBalanceRequestType has binding name 'ns1__GetBalanceRequestType' for type 'ns1:GetBalanceRequestType' */
#ifndef SOAP_TYPE_ns1__GetBalanceRequestType
#define SOAP_TYPE_ns1__GetBalanceRequestType (106)
#endif

/* ns1__DoMobileCheckoutPaymentResponseType has binding name 'ns1__DoMobileCheckoutPaymentResponseType' for type 'ns1:DoMobileCheckoutPaymentResponseType' */
#ifndef SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoMobileCheckoutPaymentResponseType (105)
#endif

/* ns1__DoMobileCheckoutPaymentRequestType has binding name 'ns1__DoMobileCheckoutPaymentRequestType' for type 'ns1:DoMobileCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoMobileCheckoutPaymentRequestType (104)
#endif

/* ns1__SetMobileCheckoutResponseType has binding name 'ns1__SetMobileCheckoutResponseType' for type 'ns1:SetMobileCheckoutResponseType' */
#ifndef SOAP_TYPE_ns1__SetMobileCheckoutResponseType
#define SOAP_TYPE_ns1__SetMobileCheckoutResponseType (103)
#endif

/* ns1__SetMobileCheckoutRequestType has binding name 'ns1__SetMobileCheckoutRequestType' for type 'ns1:SetMobileCheckoutRequestType' */
#ifndef SOAP_TYPE_ns1__SetMobileCheckoutRequestType
#define SOAP_TYPE_ns1__SetMobileCheckoutRequestType (102)
#endif

/* ns1__GetMobileStatusResponseType has binding name 'ns1__GetMobileStatusResponseType' for type 'ns1:GetMobileStatusResponseType' */
#ifndef SOAP_TYPE_ns1__GetMobileStatusResponseType
#define SOAP_TYPE_ns1__GetMobileStatusResponseType (101)
#endif

/* ns1__GetMobileStatusRequestType has binding name 'ns1__GetMobileStatusRequestType' for type 'ns1:GetMobileStatusRequestType' */
#ifndef SOAP_TYPE_ns1__GetMobileStatusRequestType
#define SOAP_TYPE_ns1__GetMobileStatusRequestType (100)
#endif

/* ns1__CreateMobilePaymentResponseType has binding name 'ns1__CreateMobilePaymentResponseType' for type 'ns1:CreateMobilePaymentResponseType' */
#ifndef SOAP_TYPE_ns1__CreateMobilePaymentResponseType
#define SOAP_TYPE_ns1__CreateMobilePaymentResponseType (99)
#endif

/* ns1__CreateMobilePaymentRequestType has binding name 'ns1__CreateMobilePaymentRequestType' for type 'ns1:CreateMobilePaymentRequestType' */
#ifndef SOAP_TYPE_ns1__CreateMobilePaymentRequestType
#define SOAP_TYPE_ns1__CreateMobilePaymentRequestType (98)
#endif

/* ns1__DoUATPAuthorizationResponseType has binding name 'ns1__DoUATPAuthorizationResponseType' for type 'ns1:DoUATPAuthorizationResponseType' */
#ifndef SOAP_TYPE_ns1__DoUATPAuthorizationResponseType
#define SOAP_TYPE_ns1__DoUATPAuthorizationResponseType (97)
#endif

/* ns1__DoUATPAuthorizationRequestType has binding name 'ns1__DoUATPAuthorizationRequestType' for type 'ns1:DoUATPAuthorizationRequestType' */
#ifndef SOAP_TYPE_ns1__DoUATPAuthorizationRequestType
#define SOAP_TYPE_ns1__DoUATPAuthorizationRequestType (96)
#endif

/* ns1__UpdateAuthorizationResponseType has binding name 'ns1__UpdateAuthorizationResponseType' for type 'ns1:UpdateAuthorizationResponseType' */
#ifndef SOAP_TYPE_ns1__UpdateAuthorizationResponseType
#define SOAP_TYPE_ns1__UpdateAuthorizationResponseType (95)
#endif

/* ns1__UpdateAuthorizationRequestType has binding name 'ns1__UpdateAuthorizationRequestType' for type 'ns1:UpdateAuthorizationRequestType' */
#ifndef SOAP_TYPE_ns1__UpdateAuthorizationRequestType
#define SOAP_TYPE_ns1__UpdateAuthorizationRequestType (94)
#endif

/* ns1__DoAuthorizationResponseType has binding name 'ns1__DoAuthorizationResponseType' for type 'ns1:DoAuthorizationResponseType' */
#ifndef SOAP_TYPE_ns1__DoAuthorizationResponseType
#define SOAP_TYPE_ns1__DoAuthorizationResponseType (93)
#endif

/* ns1__DoAuthorizationRequestType has binding name 'ns1__DoAuthorizationRequestType' for type 'ns1:DoAuthorizationRequestType' */
#ifndef SOAP_TYPE_ns1__DoAuthorizationRequestType
#define SOAP_TYPE_ns1__DoAuthorizationRequestType (92)
#endif

/* ns1__DoVoidResponseType has binding name 'ns1__DoVoidResponseType' for type 'ns1:DoVoidResponseType' */
#ifndef SOAP_TYPE_ns1__DoVoidResponseType
#define SOAP_TYPE_ns1__DoVoidResponseType (91)
#endif

/* ns1__DoVoidRequestType has binding name 'ns1__DoVoidRequestType' for type 'ns1:DoVoidRequestType' */
#ifndef SOAP_TYPE_ns1__DoVoidRequestType
#define SOAP_TYPE_ns1__DoVoidRequestType (90)
#endif

/* ns1__DoReauthorizationResponseType has binding name 'ns1__DoReauthorizationResponseType' for type 'ns1:DoReauthorizationResponseType' */
#ifndef SOAP_TYPE_ns1__DoReauthorizationResponseType
#define SOAP_TYPE_ns1__DoReauthorizationResponseType (89)
#endif

/* ns1__DoReauthorizationRequestType has binding name 'ns1__DoReauthorizationRequestType' for type 'ns1:DoReauthorizationRequestType' */
#ifndef SOAP_TYPE_ns1__DoReauthorizationRequestType
#define SOAP_TYPE_ns1__DoReauthorizationRequestType (88)
#endif

/* ns1__DoCaptureResponseType has binding name 'ns1__DoCaptureResponseType' for type 'ns1:DoCaptureResponseType' */
#ifndef SOAP_TYPE_ns1__DoCaptureResponseType
#define SOAP_TYPE_ns1__DoCaptureResponseType (87)
#endif

/* ns1__DoCaptureRequestType has binding name 'ns1__DoCaptureRequestType' for type 'ns1:DoCaptureRequestType' */
#ifndef SOAP_TYPE_ns1__DoCaptureRequestType
#define SOAP_TYPE_ns1__DoCaptureRequestType (86)
#endif

/* ns1__DoCancelResponseType has binding name 'ns1__DoCancelResponseType' for type 'ns1:DoCancelResponseType' */
#ifndef SOAP_TYPE_ns1__DoCancelResponseType
#define SOAP_TYPE_ns1__DoCancelResponseType (85)
#endif

/* ns1__DoCancelRequestType has binding name 'ns1__DoCancelRequestType' for type 'ns1:DoCancelRequestType' */
#ifndef SOAP_TYPE_ns1__DoCancelRequestType
#define SOAP_TYPE_ns1__DoCancelRequestType (84)
#endif

/* ns1__DoDirectPaymentResponseType has binding name 'ns1__DoDirectPaymentResponseType' for type 'ns1:DoDirectPaymentResponseType' */
#ifndef SOAP_TYPE_ns1__DoDirectPaymentResponseType
#define SOAP_TYPE_ns1__DoDirectPaymentResponseType (83)
#endif

/* ns1__DoDirectPaymentRequestType has binding name 'ns1__DoDirectPaymentRequestType' for type 'ns1:DoDirectPaymentRequestType' */
#ifndef SOAP_TYPE_ns1__DoDirectPaymentRequestType
#define SOAP_TYPE_ns1__DoDirectPaymentRequestType (82)
#endif

/* ns1__ManagePendingTransactionStatusResponseType has binding name 'ns1__ManagePendingTransactionStatusResponseType' for type 'ns1:ManagePendingTransactionStatusResponseType' */
#ifndef SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType
#define SOAP_TYPE_ns1__ManagePendingTransactionStatusResponseType (81)
#endif

/* ns1__ManagePendingTransactionStatusRequestType has binding name 'ns1__ManagePendingTransactionStatusRequestType' for type 'ns1:ManagePendingTransactionStatusRequestType' */
#ifndef SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType
#define SOAP_TYPE_ns1__ManagePendingTransactionStatusRequestType (80)
#endif

/* ns1__DoUATPExpressCheckoutPaymentResponseType has binding name 'ns1__DoUATPExpressCheckoutPaymentResponseType' for type 'ns1:DoUATPExpressCheckoutPaymentResponseType' */
#ifndef SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentResponseType (79)
#endif

/* ns1__DoUATPExpressCheckoutPaymentRequestType has binding name 'ns1__DoUATPExpressCheckoutPaymentRequestType' for type 'ns1:DoUATPExpressCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoUATPExpressCheckoutPaymentRequestType (78)
#endif

/* ns1__DoExpressCheckoutPaymentResponseType has binding name 'ns1__DoExpressCheckoutPaymentResponseType' for type 'ns1:DoExpressCheckoutPaymentResponseType' */
#ifndef SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType
#define SOAP_TYPE_ns1__DoExpressCheckoutPaymentResponseType (77)
#endif

/* ns1__DoExpressCheckoutPaymentRequestType has binding name 'ns1__DoExpressCheckoutPaymentRequestType' for type 'ns1:DoExpressCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType
#define SOAP_TYPE_ns1__DoExpressCheckoutPaymentRequestType (76)
#endif

/* ns1__GetExpressCheckoutDetailsResponseType has binding name 'ns1__GetExpressCheckoutDetailsResponseType' for type 'ns1:GetExpressCheckoutDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType
#define SOAP_TYPE_ns1__GetExpressCheckoutDetailsResponseType (75)
#endif

/* ns1__GetExpressCheckoutDetailsRequestType has binding name 'ns1__GetExpressCheckoutDetailsRequestType' for type 'ns1:GetExpressCheckoutDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType
#define SOAP_TYPE_ns1__GetExpressCheckoutDetailsRequestType (74)
#endif

/* ns1__ExecuteCheckoutOperationsResponseType has binding name 'ns1__ExecuteCheckoutOperationsResponseType' for type 'ns1:ExecuteCheckoutOperationsResponseType' */
#ifndef SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType
#define SOAP_TYPE_ns1__ExecuteCheckoutOperationsResponseType (73)
#endif

/* ns1__ExecuteCheckoutOperationsRequestType has binding name 'ns1__ExecuteCheckoutOperationsRequestType' for type 'ns1:ExecuteCheckoutOperationsRequestType' */
#ifndef SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType
#define SOAP_TYPE_ns1__ExecuteCheckoutOperationsRequestType (72)
#endif

/* ns1__SetExpressCheckoutResponseType has binding name 'ns1__SetExpressCheckoutResponseType' for type 'ns1:SetExpressCheckoutResponseType' */
#ifndef SOAP_TYPE_ns1__SetExpressCheckoutResponseType
#define SOAP_TYPE_ns1__SetExpressCheckoutResponseType (71)
#endif

/* ns1__SetExpressCheckoutRequestType has binding name 'ns1__SetExpressCheckoutRequestType' for type 'ns1:SetExpressCheckoutRequestType' */
#ifndef SOAP_TYPE_ns1__SetExpressCheckoutRequestType
#define SOAP_TYPE_ns1__SetExpressCheckoutRequestType (70)
#endif

/* ns1__GetIncentiveEvaluationResponseType has binding name 'ns1__GetIncentiveEvaluationResponseType' for type 'ns1:GetIncentiveEvaluationResponseType' */
#ifndef SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType
#define SOAP_TYPE_ns1__GetIncentiveEvaluationResponseType (69)
#endif

/* ns1__GetIncentiveEvaluationRequestType has binding name 'ns1__GetIncentiveEvaluationRequestType' for type 'ns1:GetIncentiveEvaluationRequestType' */
#ifndef SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType
#define SOAP_TYPE_ns1__GetIncentiveEvaluationRequestType (68)
#endif

/* ns1__GetAccessPermissionDetailsResponseType has binding name 'ns1__GetAccessPermissionDetailsResponseType' for type 'ns1:GetAccessPermissionDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType
#define SOAP_TYPE_ns1__GetAccessPermissionDetailsResponseType (67)
#endif

/* ns1__GetAccessPermissionDetailsRequestType has binding name 'ns1__GetAccessPermissionDetailsRequestType' for type 'ns1:GetAccessPermissionDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType
#define SOAP_TYPE_ns1__GetAccessPermissionDetailsRequestType (66)
#endif

/* ns1__UpdateAccessPermissionsResponseType has binding name 'ns1__UpdateAccessPermissionsResponseType' for type 'ns1:UpdateAccessPermissionsResponseType' */
#ifndef SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType
#define SOAP_TYPE_ns1__UpdateAccessPermissionsResponseType (65)
#endif

/* ns1__UpdateAccessPermissionsRequestType has binding name 'ns1__UpdateAccessPermissionsRequestType' for type 'ns1:UpdateAccessPermissionsRequestType' */
#ifndef SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType
#define SOAP_TYPE_ns1__UpdateAccessPermissionsRequestType (64)
#endif

/* ns1__SetAccessPermissionsResponseType has binding name 'ns1__SetAccessPermissionsResponseType' for type 'ns1:SetAccessPermissionsResponseType' */
#ifndef SOAP_TYPE_ns1__SetAccessPermissionsResponseType
#define SOAP_TYPE_ns1__SetAccessPermissionsResponseType (63)
#endif

/* ns1__SetAccessPermissionsRequestType has binding name 'ns1__SetAccessPermissionsRequestType' for type 'ns1:SetAccessPermissionsRequestType' */
#ifndef SOAP_TYPE_ns1__SetAccessPermissionsRequestType
#define SOAP_TYPE_ns1__SetAccessPermissionsRequestType (62)
#endif

/* ns1__GetAuthDetailsResponseType has binding name 'ns1__GetAuthDetailsResponseType' for type 'ns1:GetAuthDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetAuthDetailsResponseType
#define SOAP_TYPE_ns1__GetAuthDetailsResponseType (61)
#endif

/* ns1__GetAuthDetailsRequestType has binding name 'ns1__GetAuthDetailsRequestType' for type 'ns1:GetAuthDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetAuthDetailsRequestType
#define SOAP_TYPE_ns1__GetAuthDetailsRequestType (60)
#endif

/* ns1__SetAuthFlowParamResponseType has binding name 'ns1__SetAuthFlowParamResponseType' for type 'ns1:SetAuthFlowParamResponseType' */
#ifndef SOAP_TYPE_ns1__SetAuthFlowParamResponseType
#define SOAP_TYPE_ns1__SetAuthFlowParamResponseType (59)
#endif

/* ns1__SetAuthFlowParamRequestType has binding name 'ns1__SetAuthFlowParamRequestType' for type 'ns1:SetAuthFlowParamRequestType' */
#ifndef SOAP_TYPE_ns1__SetAuthFlowParamRequestType
#define SOAP_TYPE_ns1__SetAuthFlowParamRequestType (58)
#endif

/* ns1__GetBoardingDetailsResponseType has binding name 'ns1__GetBoardingDetailsResponseType' for type 'ns1:GetBoardingDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetBoardingDetailsResponseType
#define SOAP_TYPE_ns1__GetBoardingDetailsResponseType (57)
#endif

/* ns1__GetBoardingDetailsRequestType has binding name 'ns1__GetBoardingDetailsRequestType' for type 'ns1:GetBoardingDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetBoardingDetailsRequestType
#define SOAP_TYPE_ns1__GetBoardingDetailsRequestType (56)
#endif

/* ns1__EnterBoardingResponseType has binding name 'ns1__EnterBoardingResponseType' for type 'ns1:EnterBoardingResponseType' */
#ifndef SOAP_TYPE_ns1__EnterBoardingResponseType
#define SOAP_TYPE_ns1__EnterBoardingResponseType (55)
#endif

/* ns1__EnterBoardingRequestType has binding name 'ns1__EnterBoardingRequestType' for type 'ns1:EnterBoardingRequestType' */
#ifndef SOAP_TYPE_ns1__EnterBoardingRequestType
#define SOAP_TYPE_ns1__EnterBoardingRequestType (54)
#endif

/* ns1__AddressVerifyResponseType has binding name 'ns1__AddressVerifyResponseType' for type 'ns1:AddressVerifyResponseType' */
#ifndef SOAP_TYPE_ns1__AddressVerifyResponseType
#define SOAP_TYPE_ns1__AddressVerifyResponseType (53)
#endif

/* ns1__AddressVerifyRequestType has binding name 'ns1__AddressVerifyRequestType' for type 'ns1:AddressVerifyRequestType' */
#ifndef SOAP_TYPE_ns1__AddressVerifyRequestType
#define SOAP_TYPE_ns1__AddressVerifyRequestType (52)
#endif

/* ns1__BAUpdateResponseType has binding name 'ns1__BAUpdateResponseType' for type 'ns1:BAUpdateResponseType' */
#ifndef SOAP_TYPE_ns1__BAUpdateResponseType
#define SOAP_TYPE_ns1__BAUpdateResponseType (51)
#endif

/* ns1__BAUpdateRequestType has binding name 'ns1__BAUpdateRequestType' for type 'ns1:BAUpdateRequestType' */
#ifndef SOAP_TYPE_ns1__BAUpdateRequestType
#define SOAP_TYPE_ns1__BAUpdateRequestType (50)
#endif

/* ns1__MassPayRequestItemType has binding name 'ns1__MassPayRequestItemType' for type 'ns1:MassPayRequestItemType' */
#ifndef SOAP_TYPE_ns1__MassPayRequestItemType
#define SOAP_TYPE_ns1__MassPayRequestItemType (49)
#endif

/* ns1__MassPayResponseType has binding name 'ns1__MassPayResponseType' for type 'ns1:MassPayResponseType' */
#ifndef SOAP_TYPE_ns1__MassPayResponseType
#define SOAP_TYPE_ns1__MassPayResponseType (48)
#endif

/* ns1__MassPayRequestType has binding name 'ns1__MassPayRequestType' for type 'ns1:MassPayRequestType' */
#ifndef SOAP_TYPE_ns1__MassPayRequestType
#define SOAP_TYPE_ns1__MassPayRequestType (47)
#endif

/* ns1__TransactionSearchResponseType has binding name 'ns1__TransactionSearchResponseType' for type 'ns1:TransactionSearchResponseType' */
#ifndef SOAP_TYPE_ns1__TransactionSearchResponseType
#define SOAP_TYPE_ns1__TransactionSearchResponseType (46)
#endif

/* ns1__TransactionSearchRequestType has binding name 'ns1__TransactionSearchRequestType' for type 'ns1:TransactionSearchRequestType' */
#ifndef SOAP_TYPE_ns1__TransactionSearchRequestType
#define SOAP_TYPE_ns1__TransactionSearchRequestType (45)
#endif

/* ns1__BillUserResponseType has binding name 'ns1__BillUserResponseType' for type 'ns1:BillUserResponseType' */
#ifndef SOAP_TYPE_ns1__BillUserResponseType
#define SOAP_TYPE_ns1__BillUserResponseType (44)
#endif

/* ns1__BillUserRequestType has binding name 'ns1__BillUserRequestType' for type 'ns1:BillUserRequestType' */
#ifndef SOAP_TYPE_ns1__BillUserRequestType
#define SOAP_TYPE_ns1__BillUserRequestType (43)
#endif

/* ns1__GetTransactionDetailsResponseType has binding name 'ns1__GetTransactionDetailsResponseType' for type 'ns1:GetTransactionDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__GetTransactionDetailsResponseType
#define SOAP_TYPE_ns1__GetTransactionDetailsResponseType (42)
#endif

/* ns1__GetTransactionDetailsRequestType has binding name 'ns1__GetTransactionDetailsRequestType' for type 'ns1:GetTransactionDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__GetTransactionDetailsRequestType
#define SOAP_TYPE_ns1__GetTransactionDetailsRequestType (41)
#endif

/* ns1__CancelRecoupResponseType has binding name 'ns1__CancelRecoupResponseType' for type 'ns1:CancelRecoupResponseType' */
#ifndef SOAP_TYPE_ns1__CancelRecoupResponseType
#define SOAP_TYPE_ns1__CancelRecoupResponseType (40)
#endif

/* ns1__CancelRecoupRequestType has binding name 'ns1__CancelRecoupRequestType' for type 'ns1:CancelRecoupRequestType' */
#ifndef SOAP_TYPE_ns1__CancelRecoupRequestType
#define SOAP_TYPE_ns1__CancelRecoupRequestType (39)
#endif

/* ns1__CompleteRecoupResponseType has binding name 'ns1__CompleteRecoupResponseType' for type 'ns1:CompleteRecoupResponseType' */
#ifndef SOAP_TYPE_ns1__CompleteRecoupResponseType
#define SOAP_TYPE_ns1__CompleteRecoupResponseType (38)
#endif

/* ns1__CompleteRecoupRequestType has binding name 'ns1__CompleteRecoupRequestType' for type 'ns1:CompleteRecoupRequestType' */
#ifndef SOAP_TYPE_ns1__CompleteRecoupRequestType
#define SOAP_TYPE_ns1__CompleteRecoupRequestType (37)
#endif

/* ns1__InitiateRecoupResponseType has binding name 'ns1__InitiateRecoupResponseType' for type 'ns1:InitiateRecoupResponseType' */
#ifndef SOAP_TYPE_ns1__InitiateRecoupResponseType
#define SOAP_TYPE_ns1__InitiateRecoupResponseType (36)
#endif

/* ns1__InitiateRecoupRequestType has binding name 'ns1__InitiateRecoupRequestType' for type 'ns1:InitiateRecoupRequestType' */
#ifndef SOAP_TYPE_ns1__InitiateRecoupRequestType
#define SOAP_TYPE_ns1__InitiateRecoupRequestType (35)
#endif

/* ns1__RefundTransactionResponseType has binding name 'ns1__RefundTransactionResponseType' for type 'ns1:RefundTransactionResponseType' */
#ifndef SOAP_TYPE_ns1__RefundTransactionResponseType
#define SOAP_TYPE_ns1__RefundTransactionResponseType (34)
#endif

/* ns1__RefundTransactionRequestType has binding name 'ns1__RefundTransactionRequestType' for type 'ns1:RefundTransactionRequestType' */
#ifndef SOAP_TYPE_ns1__RefundTransactionRequestType
#define SOAP_TYPE_ns1__RefundTransactionRequestType (33)
#endif

/* ns1__BMButtonSearchResponseType has binding name 'ns1__BMButtonSearchResponseType' for type 'ns1:BMButtonSearchResponseType' */
#ifndef SOAP_TYPE_ns1__BMButtonSearchResponseType
#define SOAP_TYPE_ns1__BMButtonSearchResponseType (32)
#endif

/* ns1__BMButtonSearchRequestType has binding name 'ns1__BMButtonSearchRequestType' for type 'ns1:BMButtonSearchRequestType' */
#ifndef SOAP_TYPE_ns1__BMButtonSearchRequestType
#define SOAP_TYPE_ns1__BMButtonSearchRequestType (31)
#endif

/* ns1__BMGetInventoryResponseType has binding name 'ns1__BMGetInventoryResponseType' for type 'ns1:BMGetInventoryResponseType' */
#ifndef SOAP_TYPE_ns1__BMGetInventoryResponseType
#define SOAP_TYPE_ns1__BMGetInventoryResponseType (30)
#endif

/* ns1__BMGetInventoryRequestType has binding name 'ns1__BMGetInventoryRequestType' for type 'ns1:BMGetInventoryRequestType' */
#ifndef SOAP_TYPE_ns1__BMGetInventoryRequestType
#define SOAP_TYPE_ns1__BMGetInventoryRequestType (29)
#endif

/* ns1__BMSetInventoryResponseType has binding name 'ns1__BMSetInventoryResponseType' for type 'ns1:BMSetInventoryResponseType' */
#ifndef SOAP_TYPE_ns1__BMSetInventoryResponseType
#define SOAP_TYPE_ns1__BMSetInventoryResponseType (28)
#endif

/* ns1__BMSetInventoryRequestType has binding name 'ns1__BMSetInventoryRequestType' for type 'ns1:BMSetInventoryRequestType' */
#ifndef SOAP_TYPE_ns1__BMSetInventoryRequestType
#define SOAP_TYPE_ns1__BMSetInventoryRequestType (27)
#endif

/* ns1__BMGetButtonDetailsResponseType has binding name 'ns1__BMGetButtonDetailsResponseType' for type 'ns1:BMGetButtonDetailsResponseType' */
#ifndef SOAP_TYPE_ns1__BMGetButtonDetailsResponseType
#define SOAP_TYPE_ns1__BMGetButtonDetailsResponseType (26)
#endif

/* ns1__BMGetButtonDetailsRequestType has binding name 'ns1__BMGetButtonDetailsRequestType' for type 'ns1:BMGetButtonDetailsRequestType' */
#ifndef SOAP_TYPE_ns1__BMGetButtonDetailsRequestType
#define SOAP_TYPE_ns1__BMGetButtonDetailsRequestType (25)
#endif

/* ns1__BMManageButtonStatusResponseType has binding name 'ns1__BMManageButtonStatusResponseType' for type 'ns1:BMManageButtonStatusResponseType' */
#ifndef SOAP_TYPE_ns1__BMManageButtonStatusResponseType
#define SOAP_TYPE_ns1__BMManageButtonStatusResponseType (24)
#endif

/* ns1__BMManageButtonStatusRequestType has binding name 'ns1__BMManageButtonStatusRequestType' for type 'ns1:BMManageButtonStatusRequestType' */
#ifndef SOAP_TYPE_ns1__BMManageButtonStatusRequestType
#define SOAP_TYPE_ns1__BMManageButtonStatusRequestType (23)
#endif

/* ns1__BMUpdateButtonResponseType has binding name 'ns1__BMUpdateButtonResponseType' for type 'ns1:BMUpdateButtonResponseType' */
#ifndef SOAP_TYPE_ns1__BMUpdateButtonResponseType
#define SOAP_TYPE_ns1__BMUpdateButtonResponseType (22)
#endif

/* ns1__BMUpdateButtonRequestType has binding name 'ns1__BMUpdateButtonRequestType' for type 'ns1:BMUpdateButtonRequestType' */
#ifndef SOAP_TYPE_ns1__BMUpdateButtonRequestType
#define SOAP_TYPE_ns1__BMUpdateButtonRequestType (21)
#endif

/* ns1__BMCreateButtonResponseType has binding name 'ns1__BMCreateButtonResponseType' for type 'ns1:BMCreateButtonResponseType' */
#ifndef SOAP_TYPE_ns1__BMCreateButtonResponseType
#define SOAP_TYPE_ns1__BMCreateButtonResponseType (20)
#endif

/* ns1__BMCreateButtonRequestType has binding name 'ns1__BMCreateButtonRequestType' for type 'ns1:BMCreateButtonRequestType' */
#ifndef SOAP_TYPE_ns1__BMCreateButtonRequestType
#define SOAP_TYPE_ns1__BMCreateButtonRequestType (19)
#endif

/* ns1__OptionDetailsType has binding name 'ns1__OptionDetailsType' for type 'ns1:OptionDetailsType' */
#ifndef SOAP_TYPE_ns1__OptionDetailsType
#define SOAP_TYPE_ns1__OptionDetailsType (18)
#endif

/* ns1__OptionSelectionDetailsType has binding name 'ns1__OptionSelectionDetailsType' for type 'ns1:OptionSelectionDetailsType' */
#ifndef SOAP_TYPE_ns1__OptionSelectionDetailsType
#define SOAP_TYPE_ns1__OptionSelectionDetailsType (17)
#endif

/* ns1__InstallmentDetailsType has binding name 'ns1__InstallmentDetailsType' for type 'ns1:InstallmentDetailsType' */
#ifndef SOAP_TYPE_ns1__InstallmentDetailsType
#define SOAP_TYPE_ns1__InstallmentDetailsType (16)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (15)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (14)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (13)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (11)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (10)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1194)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1193)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1190)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1188)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (958)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (1196)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (1195)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (1189)
#endif

/* _ns1__ExternalRememberMeOptOutReq * has binding name 'PointerTo_ns1__ExternalRememberMeOptOutReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ExternalRememberMeOptOutReq
#define SOAP_TYPE_PointerTo_ns1__ExternalRememberMeOptOutReq (1184)
#endif

/* _ns1__ReverseTransactionReq * has binding name 'PointerTo_ns1__ReverseTransactionReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReverseTransactionReq
#define SOAP_TYPE_PointerTo_ns1__ReverseTransactionReq (1180)
#endif

/* _ns1__DoNonReferencedCreditReq * has binding name 'PointerTo_ns1__DoNonReferencedCreditReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoNonReferencedCreditReq
#define SOAP_TYPE_PointerTo_ns1__DoNonReferencedCreditReq (1176)
#endif

/* _ns1__UpdateRecurringPaymentsProfileReq * has binding name 'PointerTo_ns1__UpdateRecurringPaymentsProfileReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdateRecurringPaymentsProfileReq
#define SOAP_TYPE_PointerTo_ns1__UpdateRecurringPaymentsProfileReq (1172)
#endif

/* _ns1__BillOutstandingAmountReq * has binding name 'PointerTo_ns1__BillOutstandingAmountReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BillOutstandingAmountReq
#define SOAP_TYPE_PointerTo_ns1__BillOutstandingAmountReq (1168)
#endif

/* _ns1__ManageRecurringPaymentsProfileStatusReq * has binding name 'PointerTo_ns1__ManageRecurringPaymentsProfileStatusReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ManageRecurringPaymentsProfileStatusReq
#define SOAP_TYPE_PointerTo_ns1__ManageRecurringPaymentsProfileStatusReq (1164)
#endif

/* _ns1__GetRecurringPaymentsProfileDetailsReq * has binding name 'PointerTo_ns1__GetRecurringPaymentsProfileDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRecurringPaymentsProfileDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetRecurringPaymentsProfileDetailsReq (1160)
#endif

/* _ns1__CreateRecurringPaymentsProfileReq * has binding name 'PointerTo_ns1__CreateRecurringPaymentsProfileReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateRecurringPaymentsProfileReq
#define SOAP_TYPE_PointerTo_ns1__CreateRecurringPaymentsProfileReq (1156)
#endif

/* _ns1__DoReferenceTransactionReq * has binding name 'PointerTo_ns1__DoReferenceTransactionReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoReferenceTransactionReq
#define SOAP_TYPE_PointerTo_ns1__DoReferenceTransactionReq (1152)
#endif

/* _ns1__CreateBillingAgreementReq * has binding name 'PointerTo_ns1__CreateBillingAgreementReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateBillingAgreementReq
#define SOAP_TYPE_PointerTo_ns1__CreateBillingAgreementReq (1148)
#endif

/* _ns1__GetBillingAgreementCustomerDetailsReq * has binding name 'PointerTo_ns1__GetBillingAgreementCustomerDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetBillingAgreementCustomerDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetBillingAgreementCustomerDetailsReq (1144)
#endif

/* _ns1__SetCustomerBillingAgreementReq * has binding name 'PointerTo_ns1__SetCustomerBillingAgreementReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetCustomerBillingAgreementReq
#define SOAP_TYPE_PointerTo_ns1__SetCustomerBillingAgreementReq (1140)
#endif

/* _ns1__DoUATPAuthorizationReq * has binding name 'PointerTo_ns1__DoUATPAuthorizationReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoUATPAuthorizationReq
#define SOAP_TYPE_PointerTo_ns1__DoUATPAuthorizationReq (1136)
#endif

/* _ns1__UpdateAuthorizationReq * has binding name 'PointerTo_ns1__UpdateAuthorizationReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdateAuthorizationReq
#define SOAP_TYPE_PointerTo_ns1__UpdateAuthorizationReq (1132)
#endif

/* _ns1__DoAuthorizationReq * has binding name 'PointerTo_ns1__DoAuthorizationReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoAuthorizationReq
#define SOAP_TYPE_PointerTo_ns1__DoAuthorizationReq (1128)
#endif

/* _ns1__DoVoidReq * has binding name 'PointerTo_ns1__DoVoidReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoVoidReq
#define SOAP_TYPE_PointerTo_ns1__DoVoidReq (1124)
#endif

/* _ns1__DoReauthorizationReq * has binding name 'PointerTo_ns1__DoReauthorizationReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoReauthorizationReq
#define SOAP_TYPE_PointerTo_ns1__DoReauthorizationReq (1120)
#endif

/* _ns1__DoCaptureReq * has binding name 'PointerTo_ns1__DoCaptureReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoCaptureReq
#define SOAP_TYPE_PointerTo_ns1__DoCaptureReq (1116)
#endif

/* _ns1__DoCancelReq * has binding name 'PointerTo_ns1__DoCancelReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoCancelReq
#define SOAP_TYPE_PointerTo_ns1__DoCancelReq (1112)
#endif

/* _ns1__ManagePendingTransactionStatusReq * has binding name 'PointerTo_ns1__ManagePendingTransactionStatusReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ManagePendingTransactionStatusReq
#define SOAP_TYPE_PointerTo_ns1__ManagePendingTransactionStatusReq (1108)
#endif

/* _ns1__DoDirectPaymentReq * has binding name 'PointerTo_ns1__DoDirectPaymentReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoDirectPaymentReq
#define SOAP_TYPE_PointerTo_ns1__DoDirectPaymentReq (1104)
#endif

/* _ns1__GetExpressCheckoutDetailsReq * has binding name 'PointerTo_ns1__GetExpressCheckoutDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetExpressCheckoutDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetExpressCheckoutDetailsReq (1100)
#endif

/* _ns1__ExecuteCheckoutOperationsReq * has binding name 'PointerTo_ns1__ExecuteCheckoutOperationsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ExecuteCheckoutOperationsReq
#define SOAP_TYPE_PointerTo_ns1__ExecuteCheckoutOperationsReq (1096)
#endif

/* _ns1__SetExpressCheckoutReq * has binding name 'PointerTo_ns1__SetExpressCheckoutReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetExpressCheckoutReq
#define SOAP_TYPE_PointerTo_ns1__SetExpressCheckoutReq (1092)
#endif

/* _ns1__GetIncentiveEvaluationReq * has binding name 'PointerTo_ns1__GetIncentiveEvaluationReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetIncentiveEvaluationReq
#define SOAP_TYPE_PointerTo_ns1__GetIncentiveEvaluationReq (1088)
#endif

/* _ns1__GetAccessPermissionDetailsReq * has binding name 'PointerTo_ns1__GetAccessPermissionDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAccessPermissionDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetAccessPermissionDetailsReq (1084)
#endif

/* _ns1__UpdateAccessPermissionsReq * has binding name 'PointerTo_ns1__UpdateAccessPermissionsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdateAccessPermissionsReq
#define SOAP_TYPE_PointerTo_ns1__UpdateAccessPermissionsReq (1080)
#endif

/* _ns1__SetAccessPermissionsReq * has binding name 'PointerTo_ns1__SetAccessPermissionsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetAccessPermissionsReq
#define SOAP_TYPE_PointerTo_ns1__SetAccessPermissionsReq (1076)
#endif

/* _ns1__GetAuthDetailsReq * has binding name 'PointerTo_ns1__GetAuthDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAuthDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetAuthDetailsReq (1072)
#endif

/* _ns1__SetAuthFlowParamReq * has binding name 'PointerTo_ns1__SetAuthFlowParamReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetAuthFlowParamReq
#define SOAP_TYPE_PointerTo_ns1__SetAuthFlowParamReq (1068)
#endif

/* _ns1__DoUATPExpressCheckoutPaymentReq * has binding name 'PointerTo_ns1__DoUATPExpressCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoUATPExpressCheckoutPaymentReq
#define SOAP_TYPE_PointerTo_ns1__DoUATPExpressCheckoutPaymentReq (1064)
#endif

/* _ns1__DoExpressCheckoutPaymentReq * has binding name 'PointerTo_ns1__DoExpressCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoExpressCheckoutPaymentReq
#define SOAP_TYPE_PointerTo_ns1__DoExpressCheckoutPaymentReq (1060)
#endif

/* _ns1__GetPalDetailsReq * has binding name 'PointerTo_ns1__GetPalDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPalDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetPalDetailsReq (1056)
#endif

/* _ns1__GetBalanceReq * has binding name 'PointerTo_ns1__GetBalanceReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetBalanceReq
#define SOAP_TYPE_PointerTo_ns1__GetBalanceReq (1052)
#endif

/* _ns1__DoMobileCheckoutPaymentReq * has binding name 'PointerTo_ns1__DoMobileCheckoutPaymentReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoMobileCheckoutPaymentReq
#define SOAP_TYPE_PointerTo_ns1__DoMobileCheckoutPaymentReq (1048)
#endif

/* _ns1__SetMobileCheckoutReq * has binding name 'PointerTo_ns1__SetMobileCheckoutReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetMobileCheckoutReq
#define SOAP_TYPE_PointerTo_ns1__SetMobileCheckoutReq (1044)
#endif

/* _ns1__GetMobileStatusReq * has binding name 'PointerTo_ns1__GetMobileStatusReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetMobileStatusReq
#define SOAP_TYPE_PointerTo_ns1__GetMobileStatusReq (1040)
#endif

/* _ns1__CreateMobilePaymentReq * has binding name 'PointerTo_ns1__CreateMobilePaymentReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateMobilePaymentReq
#define SOAP_TYPE_PointerTo_ns1__CreateMobilePaymentReq (1036)
#endif

/* _ns1__GetBoardingDetailsReq * has binding name 'PointerTo_ns1__GetBoardingDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetBoardingDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetBoardingDetailsReq (1032)
#endif

/* _ns1__EnterBoardingReq * has binding name 'PointerTo_ns1__EnterBoardingReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EnterBoardingReq
#define SOAP_TYPE_PointerTo_ns1__EnterBoardingReq (1028)
#endif

/* _ns1__AddressVerifyReq * has binding name 'PointerTo_ns1__AddressVerifyReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AddressVerifyReq
#define SOAP_TYPE_PointerTo_ns1__AddressVerifyReq (1024)
#endif

/* _ns1__BillAgreementUpdateReq * has binding name 'PointerTo_ns1__BillAgreementUpdateReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BillAgreementUpdateReq
#define SOAP_TYPE_PointerTo_ns1__BillAgreementUpdateReq (1020)
#endif

/* _ns1__MassPayReq * has binding name 'PointerTo_ns1__MassPayReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MassPayReq
#define SOAP_TYPE_PointerTo_ns1__MassPayReq (1016)
#endif

/* _ns1__TransactionSearchReq * has binding name 'PointerTo_ns1__TransactionSearchReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__TransactionSearchReq
#define SOAP_TYPE_PointerTo_ns1__TransactionSearchReq (1012)
#endif

/* _ns1__BillUserReq * has binding name 'PointerTo_ns1__BillUserReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BillUserReq
#define SOAP_TYPE_PointerTo_ns1__BillUserReq (1008)
#endif

/* _ns1__BMButtonSearchReq * has binding name 'PointerTo_ns1__BMButtonSearchReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMButtonSearchReq
#define SOAP_TYPE_PointerTo_ns1__BMButtonSearchReq (1004)
#endif

/* _ns1__BMManageButtonStatusReq * has binding name 'PointerTo_ns1__BMManageButtonStatusReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMManageButtonStatusReq
#define SOAP_TYPE_PointerTo_ns1__BMManageButtonStatusReq (1000)
#endif

/* _ns1__BMGetInventoryReq * has binding name 'PointerTo_ns1__BMGetInventoryReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMGetInventoryReq
#define SOAP_TYPE_PointerTo_ns1__BMGetInventoryReq (996)
#endif

/* _ns1__BMGetButtonDetailsReq * has binding name 'PointerTo_ns1__BMGetButtonDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMGetButtonDetailsReq
#define SOAP_TYPE_PointerTo_ns1__BMGetButtonDetailsReq (992)
#endif

/* _ns1__BMSetInventoryReq * has binding name 'PointerTo_ns1__BMSetInventoryReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMSetInventoryReq
#define SOAP_TYPE_PointerTo_ns1__BMSetInventoryReq (988)
#endif

/* _ns1__BMUpdateButtonReq * has binding name 'PointerTo_ns1__BMUpdateButtonReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMUpdateButtonReq
#define SOAP_TYPE_PointerTo_ns1__BMUpdateButtonReq (984)
#endif

/* _ns1__BMCreateButtonReq * has binding name 'PointerTo_ns1__BMCreateButtonReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BMCreateButtonReq
#define SOAP_TYPE_PointerTo_ns1__BMCreateButtonReq (980)
#endif

/* _ns1__GetTransactionDetailsReq * has binding name 'PointerTo_ns1__GetTransactionDetailsReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTransactionDetailsReq
#define SOAP_TYPE_PointerTo_ns1__GetTransactionDetailsReq (976)
#endif

/* _ns1__CancelRecoupReq * has binding name 'PointerTo_ns1__CancelRecoupReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CancelRecoupReq
#define SOAP_TYPE_PointerTo_ns1__CancelRecoupReq (972)
#endif

/* _ns1__CompleteRecoupReq * has binding name 'PointerTo_ns1__CompleteRecoupReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CompleteRecoupReq
#define SOAP_TYPE_PointerTo_ns1__CompleteRecoupReq (968)
#endif

/* _ns1__InitiateRecoupReq * has binding name 'PointerTo_ns1__InitiateRecoupReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InitiateRecoupReq
#define SOAP_TYPE_PointerTo_ns1__InitiateRecoupReq (964)
#endif

/* _ns1__RefundTransactionReq * has binding name 'PointerTo_ns1__RefundTransactionReq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RefundTransactionReq
#define SOAP_TYPE_PointerTo_ns1__RefundTransactionReq (960)
#endif

/* ns3__CustomSecurityHeaderType * has binding name 'PointerTons3__CustomSecurityHeaderType' for type 'ns3:CustomSecurityHeaderType' */
#ifndef SOAP_TYPE_PointerTons3__CustomSecurityHeaderType
#define SOAP_TYPE_PointerTons3__CustomSecurityHeaderType (959)
#endif

/* std::string * has binding name 'PointerToxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_PointerToxsd__token
#define SOAP_TYPE_PointerToxsd__token (957)
#endif

/* ns3__ReverseTransactionResponseDetailsType * has binding name 'PointerTons3__ReverseTransactionResponseDetailsType' for type 'ns3:ReverseTransactionResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ReverseTransactionResponseDetailsType
#define SOAP_TYPE_PointerTons3__ReverseTransactionResponseDetailsType (956)
#endif

/* ns3__ReverseTransactionRequestDetailsType * has binding name 'PointerTons3__ReverseTransactionRequestDetailsType' for type 'ns3:ReverseTransactionRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ReverseTransactionRequestDetailsType
#define SOAP_TYPE_PointerTons3__ReverseTransactionRequestDetailsType (955)
#endif

/* ns3__UpdateRecurringPaymentsProfileResponseDetailsType * has binding name 'PointerTons3__UpdateRecurringPaymentsProfileResponseDetailsType' for type 'ns3:UpdateRecurringPaymentsProfileResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__UpdateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_PointerTons3__UpdateRecurringPaymentsProfileResponseDetailsType (954)
#endif

/* ns3__UpdateRecurringPaymentsProfileRequestDetailsType * has binding name 'PointerTons3__UpdateRecurringPaymentsProfileRequestDetailsType' for type 'ns3:UpdateRecurringPaymentsProfileRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__UpdateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_PointerTons3__UpdateRecurringPaymentsProfileRequestDetailsType (953)
#endif

/* ns3__BillOutstandingAmountResponseDetailsType * has binding name 'PointerTons3__BillOutstandingAmountResponseDetailsType' for type 'ns3:BillOutstandingAmountResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BillOutstandingAmountResponseDetailsType
#define SOAP_TYPE_PointerTons3__BillOutstandingAmountResponseDetailsType (952)
#endif

/* ns3__BillOutstandingAmountRequestDetailsType * has binding name 'PointerTons3__BillOutstandingAmountRequestDetailsType' for type 'ns3:BillOutstandingAmountRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BillOutstandingAmountRequestDetailsType
#define SOAP_TYPE_PointerTons3__BillOutstandingAmountRequestDetailsType (951)
#endif

/* ns3__ManageRecurringPaymentsProfileStatusResponseDetailsType * has binding name 'PointerTons3__ManageRecurringPaymentsProfileStatusResponseDetailsType' for type 'ns3:ManageRecurringPaymentsProfileStatusResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ManageRecurringPaymentsProfileStatusResponseDetailsType
#define SOAP_TYPE_PointerTons3__ManageRecurringPaymentsProfileStatusResponseDetailsType (950)
#endif

/* ns3__ManageRecurringPaymentsProfileStatusRequestDetailsType * has binding name 'PointerTons3__ManageRecurringPaymentsProfileStatusRequestDetailsType' for type 'ns3:ManageRecurringPaymentsProfileStatusRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ManageRecurringPaymentsProfileStatusRequestDetailsType
#define SOAP_TYPE_PointerTons3__ManageRecurringPaymentsProfileStatusRequestDetailsType (949)
#endif

/* ns3__GetRecurringPaymentsProfileDetailsResponseDetailsType * has binding name 'PointerTons3__GetRecurringPaymentsProfileDetailsResponseDetailsType' for type 'ns3:GetRecurringPaymentsProfileDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetRecurringPaymentsProfileDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetRecurringPaymentsProfileDetailsResponseDetailsType (948)
#endif

/* ns3__CreateRecurringPaymentsProfileResponseDetailsType * has binding name 'PointerTons3__CreateRecurringPaymentsProfileResponseDetailsType' for type 'ns3:CreateRecurringPaymentsProfileResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__CreateRecurringPaymentsProfileResponseDetailsType
#define SOAP_TYPE_PointerTons3__CreateRecurringPaymentsProfileResponseDetailsType (947)
#endif

/* ns3__CreateRecurringPaymentsProfileRequestDetailsType * has binding name 'PointerTons3__CreateRecurringPaymentsProfileRequestDetailsType' for type 'ns3:CreateRecurringPaymentsProfileRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__CreateRecurringPaymentsProfileRequestDetailsType
#define SOAP_TYPE_PointerTons3__CreateRecurringPaymentsProfileRequestDetailsType (946)
#endif

/* ns3__DoNonReferencedCreditResponseDetailsType * has binding name 'PointerTons3__DoNonReferencedCreditResponseDetailsType' for type 'ns3:DoNonReferencedCreditResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoNonReferencedCreditResponseDetailsType
#define SOAP_TYPE_PointerTons3__DoNonReferencedCreditResponseDetailsType (945)
#endif

/* ns3__DoNonReferencedCreditRequestDetailsType * has binding name 'PointerTons3__DoNonReferencedCreditRequestDetailsType' for type 'ns3:DoNonReferencedCreditRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoNonReferencedCreditRequestDetailsType
#define SOAP_TYPE_PointerTons3__DoNonReferencedCreditRequestDetailsType (944)
#endif

/* ns3__DoReferenceTransactionResponseDetailsType * has binding name 'PointerTons3__DoReferenceTransactionResponseDetailsType' for type 'ns3:DoReferenceTransactionResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoReferenceTransactionResponseDetailsType
#define SOAP_TYPE_PointerTons3__DoReferenceTransactionResponseDetailsType (943)
#endif

/* ns3__DoReferenceTransactionRequestDetailsType * has binding name 'PointerTons3__DoReferenceTransactionRequestDetailsType' for type 'ns3:DoReferenceTransactionRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoReferenceTransactionRequestDetailsType
#define SOAP_TYPE_PointerTons3__DoReferenceTransactionRequestDetailsType (942)
#endif

/* ns3__GetBillingAgreementCustomerDetailsResponseDetailsType * has binding name 'PointerTons3__GetBillingAgreementCustomerDetailsResponseDetailsType' for type 'ns3:GetBillingAgreementCustomerDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetBillingAgreementCustomerDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetBillingAgreementCustomerDetailsResponseDetailsType (941)
#endif

/* ns3__SetCustomerBillingAgreementRequestDetailsType * has binding name 'PointerTons3__SetCustomerBillingAgreementRequestDetailsType' for type 'ns3:SetCustomerBillingAgreementRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SetCustomerBillingAgreementRequestDetailsType
#define SOAP_TYPE_PointerTons3__SetCustomerBillingAgreementRequestDetailsType (940)
#endif

/* ns3__DoMobileCheckoutPaymentResponseDetailsType * has binding name 'PointerTons3__DoMobileCheckoutPaymentResponseDetailsType' for type 'ns3:DoMobileCheckoutPaymentResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoMobileCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_PointerTons3__DoMobileCheckoutPaymentResponseDetailsType (938)
#endif

/* ns3__SetMobileCheckoutRequestDetailsType * has binding name 'PointerTons3__SetMobileCheckoutRequestDetailsType' for type 'ns3:SetMobileCheckoutRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SetMobileCheckoutRequestDetailsType
#define SOAP_TYPE_PointerTons3__SetMobileCheckoutRequestDetailsType (937)
#endif

/* ns3__GetMobileStatusRequestDetailsType * has binding name 'PointerTons3__GetMobileStatusRequestDetailsType' for type 'ns3:GetMobileStatusRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetMobileStatusRequestDetailsType
#define SOAP_TYPE_PointerTons3__GetMobileStatusRequestDetailsType (936)
#endif

/* ns3__CreateMobilePaymentRequestDetailsType * has binding name 'PointerTons3__CreateMobilePaymentRequestDetailsType' for type 'ns3:CreateMobilePaymentRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__CreateMobilePaymentRequestDetailsType
#define SOAP_TYPE_PointerTons3__CreateMobilePaymentRequestDetailsType (935)
#endif

/* ns3__UATPDetailsType * has binding name 'PointerTons3__UATPDetailsType' for type 'ns3:UATPDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__UATPDetailsType
#define SOAP_TYPE_PointerTons3__UATPDetailsType (934)
#endif

/* enum ns3__TransactionEntityType * has binding name 'PointerTons3__TransactionEntityType' for type 'ns3:TransactionEntityType' */
#ifndef SOAP_TYPE_PointerTons3__TransactionEntityType
#define SOAP_TYPE_PointerTons3__TransactionEntityType (933)
#endif

/* ns3__AuthorizationInfoType * has binding name 'PointerTons3__AuthorizationInfoType' for type 'ns3:AuthorizationInfoType' */
#ifndef SOAP_TYPE_PointerTons3__AuthorizationInfoType
#define SOAP_TYPE_PointerTons3__AuthorizationInfoType (932)
#endif

/* ns3__DoCaptureResponseDetailsType * has binding name 'PointerTons3__DoCaptureResponseDetailsType' for type 'ns3:DoCaptureResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoCaptureResponseDetailsType
#define SOAP_TYPE_PointerTons3__DoCaptureResponseDetailsType (931)
#endif

/* ns3__DoDirectPaymentRequestDetailsType * has binding name 'PointerTons3__DoDirectPaymentRequestDetailsType' for type 'ns3:DoDirectPaymentRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoDirectPaymentRequestDetailsType
#define SOAP_TYPE_PointerTons3__DoDirectPaymentRequestDetailsType (930)
#endif

/* ns3__DoExpressCheckoutPaymentResponseDetailsType * has binding name 'PointerTons3__DoExpressCheckoutPaymentResponseDetailsType' for type 'ns3:DoExpressCheckoutPaymentResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoExpressCheckoutPaymentResponseDetailsType
#define SOAP_TYPE_PointerTons3__DoExpressCheckoutPaymentResponseDetailsType (929)
#endif

/* ns3__DoExpressCheckoutPaymentRequestDetailsType * has binding name 'PointerTons3__DoExpressCheckoutPaymentRequestDetailsType' for type 'ns3:DoExpressCheckoutPaymentRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DoExpressCheckoutPaymentRequestDetailsType
#define SOAP_TYPE_PointerTons3__DoExpressCheckoutPaymentRequestDetailsType (928)
#endif

/* ns3__GetExpressCheckoutDetailsResponseDetailsType * has binding name 'PointerTons3__GetExpressCheckoutDetailsResponseDetailsType' for type 'ns3:GetExpressCheckoutDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetExpressCheckoutDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetExpressCheckoutDetailsResponseDetailsType (927)
#endif

/* ns3__ExecuteCheckoutOperationsResponseDetailsType * has binding name 'PointerTons3__ExecuteCheckoutOperationsResponseDetailsType' for type 'ns3:ExecuteCheckoutOperationsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExecuteCheckoutOperationsResponseDetailsType
#define SOAP_TYPE_PointerTons3__ExecuteCheckoutOperationsResponseDetailsType (926)
#endif

/* ns3__ExecuteCheckoutOperationsRequestDetailsType * has binding name 'PointerTons3__ExecuteCheckoutOperationsRequestDetailsType' for type 'ns3:ExecuteCheckoutOperationsRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExecuteCheckoutOperationsRequestDetailsType
#define SOAP_TYPE_PointerTons3__ExecuteCheckoutOperationsRequestDetailsType (925)
#endif

/* ns3__SetExpressCheckoutRequestDetailsType * has binding name 'PointerTons3__SetExpressCheckoutRequestDetailsType' for type 'ns3:SetExpressCheckoutRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SetExpressCheckoutRequestDetailsType
#define SOAP_TYPE_PointerTons3__SetExpressCheckoutRequestDetailsType (924)
#endif

/* ns3__GetIncentiveEvaluationResponseDetailsType * has binding name 'PointerTons3__GetIncentiveEvaluationResponseDetailsType' for type 'ns3:GetIncentiveEvaluationResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetIncentiveEvaluationResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetIncentiveEvaluationResponseDetailsType (923)
#endif

/* ns3__GetIncentiveEvaluationRequestDetailsType * has binding name 'PointerTons3__GetIncentiveEvaluationRequestDetailsType' for type 'ns3:GetIncentiveEvaluationRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetIncentiveEvaluationRequestDetailsType
#define SOAP_TYPE_PointerTons3__GetIncentiveEvaluationRequestDetailsType (922)
#endif

/* ns3__GetAccessPermissionDetailsResponseDetailsType * has binding name 'PointerTons3__GetAccessPermissionDetailsResponseDetailsType' for type 'ns3:GetAccessPermissionDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetAccessPermissionDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetAccessPermissionDetailsResponseDetailsType (921)
#endif

/* ns3__SetAccessPermissionsRequestDetailsType * has binding name 'PointerTons3__SetAccessPermissionsRequestDetailsType' for type 'ns3:SetAccessPermissionsRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SetAccessPermissionsRequestDetailsType
#define SOAP_TYPE_PointerTons3__SetAccessPermissionsRequestDetailsType (920)
#endif

/* ns3__GetAuthDetailsResponseDetailsType * has binding name 'PointerTons3__GetAuthDetailsResponseDetailsType' for type 'ns3:GetAuthDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetAuthDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetAuthDetailsResponseDetailsType (919)
#endif

/* ns3__SetAuthFlowParamRequestDetailsType * has binding name 'PointerTons3__SetAuthFlowParamRequestDetailsType' for type 'ns3:SetAuthFlowParamRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SetAuthFlowParamRequestDetailsType
#define SOAP_TYPE_PointerTons3__SetAuthFlowParamRequestDetailsType (918)
#endif

/* ns3__GetBoardingDetailsResponseDetailsType * has binding name 'PointerTons3__GetBoardingDetailsResponseDetailsType' for type 'ns3:GetBoardingDetailsResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__GetBoardingDetailsResponseDetailsType
#define SOAP_TYPE_PointerTons3__GetBoardingDetailsResponseDetailsType (917)
#endif

/* ns3__EnterBoardingRequestDetailsType * has binding name 'PointerTons3__EnterBoardingRequestDetailsType' for type 'ns3:EnterBoardingRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__EnterBoardingRequestDetailsType
#define SOAP_TYPE_PointerTons3__EnterBoardingRequestDetailsType (916)
#endif

/* enum ns3__MatchStatusCodeType * has binding name 'PointerTons3__MatchStatusCodeType' for type 'ns3:MatchStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__MatchStatusCodeType
#define SOAP_TYPE_PointerTons3__MatchStatusCodeType (915)
#endif

/* ns3__BAUpdateResponseDetailsType * has binding name 'PointerTons3__BAUpdateResponseDetailsType' for type 'ns3:BAUpdateResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BAUpdateResponseDetailsType
#define SOAP_TYPE_PointerTons3__BAUpdateResponseDetailsType (914)
#endif

/* enum ns3__MerchantPullStatusCodeType * has binding name 'PointerTons3__MerchantPullStatusCodeType' for type 'ns3:MerchantPullStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantPullStatusCodeType
#define SOAP_TYPE_PointerTons3__MerchantPullStatusCodeType (913)
#endif

/* ns1__MassPayRequestItemType * has binding name 'PointerTons1__MassPayRequestItemType' for type 'ns1:MassPayRequestItemType' */
#ifndef SOAP_TYPE_PointerTons1__MassPayRequestItemType
#define SOAP_TYPE_PointerTons1__MassPayRequestItemType (911)
#endif

/* enum ns3__ReceiverInfoCodeType * has binding name 'PointerTons3__ReceiverInfoCodeType' for type 'ns3:ReceiverInfoCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ReceiverInfoCodeType
#define SOAP_TYPE_PointerTons3__ReceiverInfoCodeType (910)
#endif

/* ns3__PaymentTransactionSearchResultType * has binding name 'PointerTons3__PaymentTransactionSearchResultType' for type 'ns3:PaymentTransactionSearchResultType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentTransactionSearchResultType
#define SOAP_TYPE_PointerTons3__PaymentTransactionSearchResultType (908)
#endif

/* enum ns3__PaymentTransactionStatusCodeType * has binding name 'PointerTons3__PaymentTransactionStatusCodeType' for type 'ns3:PaymentTransactionStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentTransactionStatusCodeType
#define SOAP_TYPE_PointerTons3__PaymentTransactionStatusCodeType (907)
#endif

/* enum ns3__PaymentTransactionClassCodeType * has binding name 'PointerTons3__PaymentTransactionClassCodeType' for type 'ns3:PaymentTransactionClassCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentTransactionClassCodeType
#define SOAP_TYPE_PointerTons3__PaymentTransactionClassCodeType (906)
#endif

/* ns3__MerchantPullPaymentResponseType * has binding name 'PointerTons3__MerchantPullPaymentResponseType' for type 'ns3:MerchantPullPaymentResponseType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantPullPaymentResponseType
#define SOAP_TYPE_PointerTons3__MerchantPullPaymentResponseType (905)
#endif

/* ns3__MerchantPullPaymentType * has binding name 'PointerTons3__MerchantPullPaymentType' for type 'ns3:MerchantPullPaymentType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantPullPaymentType
#define SOAP_TYPE_PointerTons3__MerchantPullPaymentType (904)
#endif

/* ns3__ThreeDSecureInfoType * has binding name 'PointerTons3__ThreeDSecureInfoType' for type 'ns3:ThreeDSecureInfoType' */
#ifndef SOAP_TYPE_PointerTons3__ThreeDSecureInfoType
#define SOAP_TYPE_PointerTons3__ThreeDSecureInfoType (903)
#endif

/* ns3__PaymentTransactionType * has binding name 'PointerTons3__PaymentTransactionType' for type 'ns3:PaymentTransactionType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentTransactionType
#define SOAP_TYPE_PointerTons3__PaymentTransactionType (902)
#endif

/* ns4__EnhancedCancelRecoupRequestDetailsType * has binding name 'PointerTons4__EnhancedCancelRecoupRequestDetailsType' for type 'ns4:EnhancedCancelRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedCancelRecoupRequestDetailsType
#define SOAP_TYPE_PointerTons4__EnhancedCancelRecoupRequestDetailsType (901)
#endif

/* ns4__EnhancedCompleteRecoupResponseDetailsType * has binding name 'PointerTons4__EnhancedCompleteRecoupResponseDetailsType' for type 'ns4:EnhancedCompleteRecoupResponseDetailsType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedCompleteRecoupResponseDetailsType
#define SOAP_TYPE_PointerTons4__EnhancedCompleteRecoupResponseDetailsType (900)
#endif

/* ns4__EnhancedCompleteRecoupRequestDetailsType * has binding name 'PointerTons4__EnhancedCompleteRecoupRequestDetailsType' for type 'ns4:EnhancedCompleteRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedCompleteRecoupRequestDetailsType
#define SOAP_TYPE_PointerTons4__EnhancedCompleteRecoupRequestDetailsType (899)
#endif

/* ns4__EnhancedInitiateRecoupRequestDetailsType * has binding name 'PointerTons4__EnhancedInitiateRecoupRequestDetailsType' for type 'ns4:EnhancedInitiateRecoupRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedInitiateRecoupRequestDetailsType
#define SOAP_TYPE_PointerTons4__EnhancedInitiateRecoupRequestDetailsType (898)
#endif

/* ns3__RefundInfoType * has binding name 'PointerTons3__RefundInfoType' for type 'ns3:RefundInfoType' */
#ifndef SOAP_TYPE_PointerTons3__RefundInfoType
#define SOAP_TYPE_PointerTons3__RefundInfoType (897)
#endif

/* ns3__MerchantStoreDetailsType * has binding name 'PointerTons3__MerchantStoreDetailsType' for type 'ns3:MerchantStoreDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantStoreDetailsType
#define SOAP_TYPE_PointerTons3__MerchantStoreDetailsType (895)
#endif

/* enum ns3__RefundType * has binding name 'PointerTons3__RefundType' for type 'ns3:RefundType' */
#ifndef SOAP_TYPE_PointerTons3__RefundType
#define SOAP_TYPE_PointerTons3__RefundType (894)
#endif

/* ns3__ButtonSearchResultType * has binding name 'PointerTons3__ButtonSearchResultType' for type 'ns3:ButtonSearchResultType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonSearchResultType
#define SOAP_TYPE_PointerTons3__ButtonSearchResultType (892)
#endif

/* ns3__OptionTrackingDetailsType * has binding name 'PointerTons3__OptionTrackingDetailsType' for type 'ns3:OptionTrackingDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__OptionTrackingDetailsType
#define SOAP_TYPE_PointerTons3__OptionTrackingDetailsType (890)
#endif

/* ns3__ItemTrackingDetailsType * has binding name 'PointerTons3__ItemTrackingDetailsType' for type 'ns3:ItemTrackingDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ItemTrackingDetailsType
#define SOAP_TYPE_PointerTons3__ItemTrackingDetailsType (889)
#endif

/* enum ns3__ButtonStatusType * has binding name 'PointerTons3__ButtonStatusType' for type 'ns3:ButtonStatusType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonStatusType
#define SOAP_TYPE_PointerTons3__ButtonStatusType (888)
#endif

/* enum ns3__SubscribeTextType * has binding name 'PointerTons3__SubscribeTextType' for type 'ns3:SubscribeTextType' */
#ifndef SOAP_TYPE_PointerTons3__SubscribeTextType
#define SOAP_TYPE_PointerTons3__SubscribeTextType (887)
#endif

/* enum ns3__BuyNowTextType * has binding name 'PointerTons3__BuyNowTextType' for type 'ns3:BuyNowTextType' */
#ifndef SOAP_TYPE_PointerTons3__BuyNowTextType
#define SOAP_TYPE_PointerTons3__BuyNowTextType (886)
#endif

/* enum ns3__ButtonImageType * has binding name 'PointerTons3__ButtonImageType' for type 'ns3:ButtonImageType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonImageType
#define SOAP_TYPE_PointerTons3__ButtonImageType (885)
#endif

/* ns1__OptionDetailsType * has binding name 'PointerTons1__OptionDetailsType' for type 'ns1:OptionDetailsType' */
#ifndef SOAP_TYPE_PointerTons1__OptionDetailsType
#define SOAP_TYPE_PointerTons1__OptionDetailsType (883)
#endif

/* enum ns3__ButtonSubTypeType * has binding name 'PointerTons3__ButtonSubTypeType' for type 'ns3:ButtonSubTypeType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonSubTypeType
#define SOAP_TYPE_PointerTons3__ButtonSubTypeType (882)
#endif

/* enum ns3__ButtonCodeType * has binding name 'PointerTons3__ButtonCodeType' for type 'ns3:ButtonCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonCodeType
#define SOAP_TYPE_PointerTons3__ButtonCodeType (881)
#endif

/* enum ns3__ButtonTypeType * has binding name 'PointerTons3__ButtonTypeType' for type 'ns3:ButtonTypeType' */
#ifndef SOAP_TYPE_PointerTons3__ButtonTypeType
#define SOAP_TYPE_PointerTons3__ButtonTypeType (880)
#endif

/* enum ns3__WalletItemType * has binding name 'PointerTons3__WalletItemType' for type 'ns3:WalletItemType' */
#ifndef SOAP_TYPE_PointerTons3__WalletItemType
#define SOAP_TYPE_PointerTons3__WalletItemType (879)
#endif

/* ns3__TupleType * has binding name 'PointerTons3__TupleType' for type 'ns3:TupleType' */
#ifndef SOAP_TYPE_PointerTons3__TupleType
#define SOAP_TYPE_PointerTons3__TupleType (877)
#endif

/* enum ns3__CoupleType * has binding name 'PointerTons3__CoupleType' for type 'ns3:CoupleType' */
#ifndef SOAP_TYPE_PointerTons3__CoupleType
#define SOAP_TYPE_PointerTons3__CoupleType (876)
#endif

/* enum ns3__PaymentStatusCodeType * has binding name 'PointerTons3__PaymentStatusCodeType' for type 'ns3:PaymentStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentStatusCodeType
#define SOAP_TYPE_PointerTons3__PaymentStatusCodeType (875)
#endif

/* ns3__AdditionalFeeType * has binding name 'PointerTons3__AdditionalFeeType' for type 'ns3:AdditionalFeeType' */
#ifndef SOAP_TYPE_PointerTons3__AdditionalFeeType
#define SOAP_TYPE_PointerTons3__AdditionalFeeType (873)
#endif

/* ns3__DiscountType * has binding name 'PointerTons3__DiscountType' for type 'ns3:DiscountType' */
#ifndef SOAP_TYPE_PointerTons3__DiscountType
#define SOAP_TYPE_PointerTons3__DiscountType (871)
#endif

/* enum ns3__UnitOfMeasure * has binding name 'PointerTons3__UnitOfMeasure' for type 'ns3:UnitOfMeasure' */
#ifndef SOAP_TYPE_PointerTons3__UnitOfMeasure
#define SOAP_TYPE_PointerTons3__UnitOfMeasure (870)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (869)
#endif

/* enum ns3__RedeemedOfferType * has binding name 'PointerTons3__RedeemedOfferType' for type 'ns3:RedeemedOfferType' */
#ifndef SOAP_TYPE_PointerTons3__RedeemedOfferType
#define SOAP_TYPE_PointerTons3__RedeemedOfferType (867)
#endif

/* ns3__ExternalRememberMeOwnerDetailsType * has binding name 'PointerTons3__ExternalRememberMeOwnerDetailsType' for type 'ns3:ExternalRememberMeOwnerDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExternalRememberMeOwnerDetailsType
#define SOAP_TYPE_PointerTons3__ExternalRememberMeOwnerDetailsType (866)
#endif

/* ns3__FlightDetailsType * has binding name 'PointerTons3__FlightDetailsType' for type 'ns3:FlightDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__FlightDetailsType
#define SOAP_TYPE_PointerTons3__FlightDetailsType (864)
#endif

/* ns3__AirlineItineraryType * has binding name 'PointerTons3__AirlineItineraryType' for type 'ns3:AirlineItineraryType' */
#ifndef SOAP_TYPE_PointerTons3__AirlineItineraryType
#define SOAP_TYPE_PointerTons3__AirlineItineraryType (863)
#endif

/* ns3__RiskFilterListType * has binding name 'PointerTons3__RiskFilterListType' for type 'ns3:RiskFilterListType' */
#ifndef SOAP_TYPE_PointerTons3__RiskFilterListType
#define SOAP_TYPE_PointerTons3__RiskFilterListType (862)
#endif

/* ns3__RiskFilterDetailsType * has binding name 'PointerTons3__RiskFilterDetailsType' for type 'ns3:RiskFilterDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__RiskFilterDetailsType
#define SOAP_TYPE_PointerTons3__RiskFilterDetailsType (860)
#endif

/* ns3__BillingPeriodDetailsType_USCOREUpdate * has binding name 'PointerTons3__BillingPeriodDetailsType_USCOREUpdate' for type 'ns3:BillingPeriodDetailsType_Update' */
#ifndef SOAP_TYPE_PointerTons3__BillingPeriodDetailsType_USCOREUpdate
#define SOAP_TYPE_PointerTons3__BillingPeriodDetailsType_USCOREUpdate (859)
#endif

/* ns3__RecurringPaymentsSummaryType * has binding name 'PointerTons3__RecurringPaymentsSummaryType' for type 'ns3:RecurringPaymentsSummaryType' */
#ifndef SOAP_TYPE_PointerTons3__RecurringPaymentsSummaryType
#define SOAP_TYPE_PointerTons3__RecurringPaymentsSummaryType (858)
#endif

/* enum ns3__RecurringPaymentsProfileStatusType * has binding name 'PointerTons3__RecurringPaymentsProfileStatusType' for type 'ns3:RecurringPaymentsProfileStatusType' */
#ifndef SOAP_TYPE_PointerTons3__RecurringPaymentsProfileStatusType
#define SOAP_TYPE_PointerTons3__RecurringPaymentsProfileStatusType (857)
#endif

/* ns3__ScheduleDetailsType * has binding name 'PointerTons3__ScheduleDetailsType' for type 'ns3:ScheduleDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ScheduleDetailsType
#define SOAP_TYPE_PointerTons3__ScheduleDetailsType (856)
#endif

/* ns3__RecurringPaymentsProfileDetailsType * has binding name 'PointerTons3__RecurringPaymentsProfileDetailsType' for type 'ns3:RecurringPaymentsProfileDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__RecurringPaymentsProfileDetailsType
#define SOAP_TYPE_PointerTons3__RecurringPaymentsProfileDetailsType (855)
#endif

/* enum ns3__AutoBillType * has binding name 'PointerTons3__AutoBillType' for type 'ns3:AutoBillType' */
#ifndef SOAP_TYPE_PointerTons3__AutoBillType
#define SOAP_TYPE_PointerTons3__AutoBillType (854)
#endif

/* ns3__ActivationDetailsType * has binding name 'PointerTons3__ActivationDetailsType' for type 'ns3:ActivationDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ActivationDetailsType
#define SOAP_TYPE_PointerTons3__ActivationDetailsType (853)
#endif

/* ns3__BillingPeriodDetailsType * has binding name 'PointerTons3__BillingPeriodDetailsType' for type 'ns3:BillingPeriodDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BillingPeriodDetailsType
#define SOAP_TYPE_PointerTons3__BillingPeriodDetailsType (852)
#endif

/* enum ns3__FailedPaymentActionType * has binding name 'PointerTons3__FailedPaymentActionType' for type 'ns3:FailedPaymentActionType' */
#ifndef SOAP_TYPE_PointerTons3__FailedPaymentActionType
#define SOAP_TYPE_PointerTons3__FailedPaymentActionType (851)
#endif

/* ns3__APICredentialsType * has binding name 'PointerTons3__APICredentialsType' for type 'ns3:APICredentialsType' */
#ifndef SOAP_TYPE_PointerTons3__APICredentialsType
#define SOAP_TYPE_PointerTons3__APICredentialsType (850)
#endif

/* enum ns3__UserWithdrawalLimitTypeType * has binding name 'PointerTons3__UserWithdrawalLimitTypeType' for type 'ns3:UserWithdrawalLimitTypeType' */
#ifndef SOAP_TYPE_PointerTons3__UserWithdrawalLimitTypeType
#define SOAP_TYPE_PointerTons3__UserWithdrawalLimitTypeType (849)
#endif

/* enum ns3__PercentageRevenueFromOnlineSalesType * has binding name 'PointerTons3__PercentageRevenueFromOnlineSalesType' for type 'ns3:PercentageRevenueFromOnlineSalesType' */
#ifndef SOAP_TYPE_PointerTons3__PercentageRevenueFromOnlineSalesType
#define SOAP_TYPE_PointerTons3__PercentageRevenueFromOnlineSalesType (848)
#endif

/* enum ns3__SalesVenueType * has binding name 'PointerTons3__SalesVenueType' for type 'ns3:SalesVenueType' */
#ifndef SOAP_TYPE_PointerTons3__SalesVenueType
#define SOAP_TYPE_PointerTons3__SalesVenueType (847)
#endif

/* enum ns3__AverageMonthlyVolumeType * has binding name 'PointerTons3__AverageMonthlyVolumeType' for type 'ns3:AverageMonthlyVolumeType' */
#ifndef SOAP_TYPE_PointerTons3__AverageMonthlyVolumeType
#define SOAP_TYPE_PointerTons3__AverageMonthlyVolumeType (846)
#endif

/* enum ns3__AverageTransactionPriceType * has binding name 'PointerTons3__AverageTransactionPriceType' for type 'ns3:AverageTransactionPriceType' */
#ifndef SOAP_TYPE_PointerTons3__AverageTransactionPriceType
#define SOAP_TYPE_PointerTons3__AverageTransactionPriceType (845)
#endif

/* enum ns3__BusinessSubCategoryType * has binding name 'PointerTons3__BusinessSubCategoryType' for type 'ns3:BusinessSubCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__BusinessSubCategoryType
#define SOAP_TYPE_PointerTons3__BusinessSubCategoryType (844)
#endif

/* enum ns3__BusinessCategoryType * has binding name 'PointerTons3__BusinessCategoryType' for type 'ns3:BusinessCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__BusinessCategoryType
#define SOAP_TYPE_PointerTons3__BusinessCategoryType (843)
#endif

/* enum ns3__BusinessTypeType * has binding name 'PointerTons3__BusinessTypeType' for type 'ns3:BusinessTypeType' */
#ifndef SOAP_TYPE_PointerTons3__BusinessTypeType
#define SOAP_TYPE_PointerTons3__BusinessTypeType (842)
#endif

/* ns3__BankAccountDetailsType * has binding name 'PointerTons3__BankAccountDetailsType' for type 'ns3:BankAccountDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BankAccountDetailsType
#define SOAP_TYPE_PointerTons3__BankAccountDetailsType (841)
#endif

/* ns3__BusinessOwnerInfoType * has binding name 'PointerTons3__BusinessOwnerInfoType' for type 'ns3:BusinessOwnerInfoType' */
#ifndef SOAP_TYPE_PointerTons3__BusinessOwnerInfoType
#define SOAP_TYPE_PointerTons3__BusinessOwnerInfoType (840)
#endif

/* ns3__BusinessInfoType * has binding name 'PointerTons3__BusinessInfoType' for type 'ns3:BusinessInfoType' */
#ifndef SOAP_TYPE_PointerTons3__BusinessInfoType
#define SOAP_TYPE_PointerTons3__BusinessInfoType (839)
#endif

/* enum ns3__MarketingCategoryType * has binding name 'PointerTons3__MarketingCategoryType' for type 'ns3:MarketingCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__MarketingCategoryType
#define SOAP_TYPE_PointerTons3__MarketingCategoryType (838)
#endif

/* ns3__SenderDetailsType * has binding name 'PointerTons3__SenderDetailsType' for type 'ns3:SenderDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SenderDetailsType
#define SOAP_TYPE_PointerTons3__SenderDetailsType (837)
#endif

/* ns3__ReferenceCreditCardDetailsType * has binding name 'PointerTons3__ReferenceCreditCardDetailsType' for type 'ns3:ReferenceCreditCardDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ReferenceCreditCardDetailsType
#define SOAP_TYPE_PointerTons3__ReferenceCreditCardDetailsType (836)
#endif

/* ns3__DeviceDetailsType * has binding name 'PointerTons3__DeviceDetailsType' for type 'ns3:DeviceDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DeviceDetailsType
#define SOAP_TYPE_PointerTons3__DeviceDetailsType (835)
#endif

/* ns3__UserIdPasswordType * has binding name 'PointerTons3__UserIdPasswordType' for type 'ns3:UserIdPasswordType' */
#ifndef SOAP_TYPE_PointerTons3__UserIdPasswordType
#define SOAP_TYPE_PointerTons3__UserIdPasswordType (834)
#endif

/* ns3__CreditCardNumberTypeType * has binding name 'PointerTons3__CreditCardNumberTypeType' for type 'ns3:CreditCardNumberTypeType' */
#ifndef SOAP_TYPE_PointerTons3__CreditCardNumberTypeType
#define SOAP_TYPE_PointerTons3__CreditCardNumberTypeType (833)
#endif

/* enum ns3__CreditCardTypeType * has binding name 'PointerTons3__CreditCardTypeType' for type 'ns3:CreditCardTypeType' */
#ifndef SOAP_TYPE_PointerTons3__CreditCardTypeType
#define SOAP_TYPE_PointerTons3__CreditCardTypeType (832)
#endif

/* ns3__ThreeDSecureResponseType * has binding name 'PointerTons3__ThreeDSecureResponseType' for type 'ns3:ThreeDSecureResponseType' */
#ifndef SOAP_TYPE_PointerTons3__ThreeDSecureResponseType
#define SOAP_TYPE_PointerTons3__ThreeDSecureResponseType (831)
#endif

/* ns3__ThreeDSecureRequestType * has binding name 'PointerTons3__ThreeDSecureRequestType' for type 'ns3:ThreeDSecureRequestType' */
#ifndef SOAP_TYPE_PointerTons3__ThreeDSecureRequestType
#define SOAP_TYPE_PointerTons3__ThreeDSecureRequestType (830)
#endif

/* ns3__IncentiveAppliedDetailsType * has binding name 'PointerTons3__IncentiveAppliedDetailsType' for type 'ns3:IncentiveAppliedDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveAppliedDetailsType
#define SOAP_TYPE_PointerTons3__IncentiveAppliedDetailsType (828)
#endif

/* enum ns3__IncentiveAppliedStatusType * has binding name 'PointerTons3__IncentiveAppliedStatusType' for type 'ns3:IncentiveAppliedStatusType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveAppliedStatusType
#define SOAP_TYPE_PointerTons3__IncentiveAppliedStatusType (827)
#endif

/* enum ns3__IncentiveSiteAppliedOnType * has binding name 'PointerTons3__IncentiveSiteAppliedOnType' for type 'ns3:IncentiveSiteAppliedOnType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveSiteAppliedOnType
#define SOAP_TYPE_PointerTons3__IncentiveSiteAppliedOnType (826)
#endif

/* ns3__MerchantDataType * has binding name 'PointerTons3__MerchantDataType' for type 'ns3:MerchantDataType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantDataType
#define SOAP_TYPE_PointerTons3__MerchantDataType (824)
#endif

/* ns3__DiscountInfoType * has binding name 'PointerTons3__DiscountInfoType' for type 'ns3:DiscountInfoType' */
#ifndef SOAP_TYPE_PointerTons3__DiscountInfoType
#define SOAP_TYPE_PointerTons3__DiscountInfoType (822)
#endif

/* enum ns3__PaymentReasonType * has binding name 'PointerTons3__PaymentReasonType' for type 'ns3:PaymentReasonType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentReasonType
#define SOAP_TYPE_PointerTons3__PaymentReasonType (821)
#endif

/* enum ns3__RecurringFlagType * has binding name 'PointerTons3__RecurringFlagType' for type 'ns3:RecurringFlagType' */
#ifndef SOAP_TYPE_PointerTons3__RecurringFlagType
#define SOAP_TYPE_PointerTons3__RecurringFlagType (820)
#endif

/* ns4__EnhancedPaymentDataType * has binding name 'PointerTons4__EnhancedPaymentDataType' for type 'ns4:EnhancedPaymentDataType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedPaymentDataType
#define SOAP_TYPE_PointerTons4__EnhancedPaymentDataType (819)
#endif

/* enum ns3__AllowedPaymentMethodType * has binding name 'PointerTons3__AllowedPaymentMethodType' for type 'ns3:AllowedPaymentMethodType' */
#ifndef SOAP_TYPE_PointerTons3__AllowedPaymentMethodType
#define SOAP_TYPE_PointerTons3__AllowedPaymentMethodType (818)
#endif

/* ns3__PaymentDetailsItemType * has binding name 'PointerTons3__PaymentDetailsItemType' for type 'ns3:PaymentDetailsItemType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentDetailsItemType
#define SOAP_TYPE_PointerTons3__PaymentDetailsItemType (816)
#endif

/* enum ns3__LocationType * has binding name 'PointerTons3__LocationType' for type 'ns3:LocationType' */
#ifndef SOAP_TYPE_PointerTons3__LocationType
#define SOAP_TYPE_PointerTons3__LocationType (815)
#endif

/* enum ns3__PaymentCategoryType * has binding name 'PointerTons3__PaymentCategoryType' for type 'ns3:PaymentCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentCategoryType
#define SOAP_TYPE_PointerTons3__PaymentCategoryType (814)
#endif

/* ns3__AuctionInfoType * has binding name 'PointerTons3__AuctionInfoType' for type 'ns3:AuctionInfoType' */
#ifndef SOAP_TYPE_PointerTons3__AuctionInfoType
#define SOAP_TYPE_PointerTons3__AuctionInfoType (813)
#endif

/* ns3__SubscriptionInfoType * has binding name 'PointerTons3__SubscriptionInfoType' for type 'ns3:SubscriptionInfoType' */
#ifndef SOAP_TYPE_PointerTons3__SubscriptionInfoType
#define SOAP_TYPE_PointerTons3__SubscriptionInfoType (812)
#endif

/* ns3__PaymentItemType * has binding name 'PointerTons3__PaymentItemType' for type 'ns3:PaymentItemType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentItemType
#define SOAP_TYPE_PointerTons3__PaymentItemType (810)
#endif

/* ns3__OptionType * has binding name 'PointerTons3__OptionType' for type 'ns3:OptionType' */
#ifndef SOAP_TYPE_PointerTons3__OptionType
#define SOAP_TYPE_PointerTons3__OptionType (808)
#endif

/* ns3__InvoiceItemType * has binding name 'PointerTons3__InvoiceItemType' for type 'ns3:InvoiceItemType' */
#ifndef SOAP_TYPE_PointerTons3__InvoiceItemType
#define SOAP_TYPE_PointerTons3__InvoiceItemType (807)
#endif

/* enum ns3__ItemCategoryType * has binding name 'PointerTons3__ItemCategoryType' for type 'ns3:ItemCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__ItemCategoryType
#define SOAP_TYPE_PointerTons3__ItemCategoryType (806)
#endif

/* ns4__EnhancedItemDataType * has binding name 'PointerTons4__EnhancedItemDataType' for type 'ns4:EnhancedItemDataType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedItemDataType
#define SOAP_TYPE_PointerTons4__EnhancedItemDataType (805)
#endif

/* ns3__EbayItemPaymentDetailsItemType * has binding name 'PointerTons3__EbayItemPaymentDetailsItemType' for type 'ns3:EbayItemPaymentDetailsItemType' */
#ifndef SOAP_TYPE_PointerTons3__EbayItemPaymentDetailsItemType
#define SOAP_TYPE_PointerTons3__EbayItemPaymentDetailsItemType (804)
#endif

/* ns3__SubscriptionTermsType * has binding name 'PointerTons3__SubscriptionTermsType' for type 'ns3:SubscriptionTermsType' */
#ifndef SOAP_TYPE_PointerTons3__SubscriptionTermsType
#define SOAP_TYPE_PointerTons3__SubscriptionTermsType (802)
#endif

/* ns3__OfferDetailsType * has binding name 'PointerTons3__OfferDetailsType' for type 'ns3:OfferDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__OfferDetailsType
#define SOAP_TYPE_PointerTons3__OfferDetailsType (801)
#endif

/* ns4__EnhancedPaymentInfoType * has binding name 'PointerTons4__EnhancedPaymentInfoType' for type 'ns4:EnhancedPaymentInfoType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedPaymentInfoType
#define SOAP_TYPE_PointerTons4__EnhancedPaymentInfoType (800)
#endif

/* ns3__FMFDetailsType * has binding name 'PointerTons3__FMFDetailsType' for type 'ns3:FMFDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__FMFDetailsType
#define SOAP_TYPE_PointerTons3__FMFDetailsType (799)
#endif

/* ns3__SellerDetailsType * has binding name 'PointerTons3__SellerDetailsType' for type 'ns3:SellerDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__SellerDetailsType
#define SOAP_TYPE_PointerTons3__SellerDetailsType (798)
#endif

/* enum ns3__POSTransactionCodeType * has binding name 'PointerTons3__POSTransactionCodeType' for type 'ns3:POSTransactionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__POSTransactionCodeType
#define SOAP_TYPE_PointerTons3__POSTransactionCodeType (797)
#endif

/* enum ns3__ReversalReasonCodeType * has binding name 'PointerTons3__ReversalReasonCodeType' for type 'ns3:ReversalReasonCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ReversalReasonCodeType
#define SOAP_TYPE_PointerTons3__ReversalReasonCodeType (796)
#endif

/* enum ns3__PendingStatusCodeType * has binding name 'PointerTons3__PendingStatusCodeType' for type 'ns3:PendingStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PendingStatusCodeType
#define SOAP_TYPE_PointerTons3__PendingStatusCodeType (795)
#endif

/* enum ns3__RefundSourceCodeType * has binding name 'PointerTons3__RefundSourceCodeType' for type 'ns3:RefundSourceCodeType' */
#ifndef SOAP_TYPE_PointerTons3__RefundSourceCodeType
#define SOAP_TYPE_PointerTons3__RefundSourceCodeType (794)
#endif

/* enum ns3__PaymentCodeType * has binding name 'PointerTons3__PaymentCodeType' for type 'ns3:PaymentCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentCodeType
#define SOAP_TYPE_PointerTons3__PaymentCodeType (793)
#endif

/* std::string * has binding name 'PointerTons3__TransactionId' for type 'ns3:TransactionId' */
#ifndef SOAP_TYPE_PointerTons3__TransactionId
#define SOAP_TYPE_PointerTons3__TransactionId (792)
#endif

/* ns3__BMLOfferInfoType * has binding name 'PointerTons3__BMLOfferInfoType' for type 'ns3:BMLOfferInfoType' */
#ifndef SOAP_TYPE_PointerTons3__BMLOfferInfoType
#define SOAP_TYPE_PointerTons3__BMLOfferInfoType (791)
#endif

/* ns4__EnhancedPayerInfoType * has binding name 'PointerTons4__EnhancedPayerInfoType' for type 'ns4:EnhancedPayerInfoType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedPayerInfoType
#define SOAP_TYPE_PointerTons4__EnhancedPayerInfoType (790)
#endif

/* ns3__TaxIdDetailsType * has binding name 'PointerTons3__TaxIdDetailsType' for type 'ns3:TaxIdDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__TaxIdDetailsType
#define SOAP_TYPE_PointerTons3__TaxIdDetailsType (789)
#endif

/* ns3__WalletItemsType * has binding name 'PointerTons3__WalletItemsType' for type 'ns3:WalletItemsType' */
#ifndef SOAP_TYPE_PointerTons3__WalletItemsType
#define SOAP_TYPE_PointerTons3__WalletItemsType (787)
#endif

/* ns3__PersonNameType * has binding name 'PointerTons3__PersonNameType' for type 'ns3:PersonNameType' */
#ifndef SOAP_TYPE_PointerTons3__PersonNameType
#define SOAP_TYPE_PointerTons3__PersonNameType (786)
#endif

/* enum ns3__PayPalUserStatusCodeType * has binding name 'PointerTons3__PayPalUserStatusCodeType' for type 'ns3:PayPalUserStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PayPalUserStatusCodeType
#define SOAP_TYPE_PointerTons3__PayPalUserStatusCodeType (785)
#endif

/* ns3__OfferCouponInfoType * has binding name 'PointerTons3__OfferCouponInfoType' for type 'ns3:OfferCouponInfoType' */
#ifndef SOAP_TYPE_PointerTons3__OfferCouponInfoType
#define SOAP_TYPE_PointerTons3__OfferCouponInfoType (784)
#endif

/* ns3__PaymentItemInfoType * has binding name 'PointerTons3__PaymentItemInfoType' for type 'ns3:PaymentItemInfoType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentItemInfoType
#define SOAP_TYPE_PointerTons3__PaymentItemInfoType (783)
#endif

/* ns3__ReceiverInfoType * has binding name 'PointerTons3__ReceiverInfoType' for type 'ns3:ReceiverInfoType' */
#ifndef SOAP_TYPE_PointerTons3__ReceiverInfoType
#define SOAP_TYPE_PointerTons3__ReceiverInfoType (782)
#endif

/* ns3__MerchantPullInfoType * has binding name 'PointerTons3__MerchantPullInfoType' for type 'ns3:MerchantPullInfoType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantPullInfoType
#define SOAP_TYPE_PointerTons3__MerchantPullInfoType (781)
#endif

/* ns3__PayeeInfoType * has binding name 'PointerTons3__PayeeInfoType' for type 'ns3:PayeeInfoType' */
#ifndef SOAP_TYPE_PointerTons3__PayeeInfoType
#define SOAP_TYPE_PointerTons3__PayeeInfoType (780)
#endif

/* ns3__PhoneNumberType * has binding name 'PointerTons3__PhoneNumberType' for type 'ns3:PhoneNumberType' */
#ifndef SOAP_TYPE_PointerTons3__PhoneNumberType
#define SOAP_TYPE_PointerTons3__PhoneNumberType (779)
#endif

/* ns3__CreditCardDetailsType * has binding name 'PointerTons3__CreditCardDetailsType' for type 'ns3:CreditCardDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__CreditCardDetailsType
#define SOAP_TYPE_PointerTons3__CreditCardDetailsType (778)
#endif

/* ns3__CoupledPaymentInfoType * has binding name 'PointerTons3__CoupledPaymentInfoType' for type 'ns3:CoupledPaymentInfoType' */
#ifndef SOAP_TYPE_PointerTons3__CoupledPaymentInfoType
#define SOAP_TYPE_PointerTons3__CoupledPaymentInfoType (776)
#endif

/* ns3__EnhancedDataType * has binding name 'PointerTons3__EnhancedDataType' for type 'ns3:EnhancedDataType' */
#ifndef SOAP_TYPE_PointerTons3__EnhancedDataType
#define SOAP_TYPE_PointerTons3__EnhancedDataType (775)
#endif

/* ns3__AuthorizationResponseType * has binding name 'PointerTons3__AuthorizationResponseType' for type 'ns3:AuthorizationResponseType' */
#ifndef SOAP_TYPE_PointerTons3__AuthorizationResponseType
#define SOAP_TYPE_PointerTons3__AuthorizationResponseType (773)
#endif

/* ns3__SetDataResponseType * has binding name 'PointerTons3__SetDataResponseType' for type 'ns3:SetDataResponseType' */
#ifndef SOAP_TYPE_PointerTons3__SetDataResponseType
#define SOAP_TYPE_PointerTons3__SetDataResponseType (772)
#endif

/* ns3__InstrumentDetailsType * has binding name 'PointerTons3__InstrumentDetailsType' for type 'ns3:InstrumentDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__InstrumentDetailsType
#define SOAP_TYPE_PointerTons3__InstrumentDetailsType (771)
#endif

/* ns3__PaymentInfoType * has binding name 'PointerTons3__PaymentInfoType' for type 'ns3:PaymentInfoType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentInfoType
#define SOAP_TYPE_PointerTons3__PaymentInfoType (769)
#endif

/* ns3__RefreshTokenStatusDetailsType * has binding name 'PointerTons3__RefreshTokenStatusDetailsType' for type 'ns3:RefreshTokenStatusDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__RefreshTokenStatusDetailsType
#define SOAP_TYPE_PointerTons3__RefreshTokenStatusDetailsType (768)
#endif

/* ns3__ExternalRememberMeStatusDetailsType * has binding name 'PointerTons3__ExternalRememberMeStatusDetailsType' for type 'ns3:ExternalRememberMeStatusDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExternalRememberMeStatusDetailsType
#define SOAP_TYPE_PointerTons3__ExternalRememberMeStatusDetailsType (767)
#endif

/* ns3__PaymentRequestInfoType * has binding name 'PointerTons3__PaymentRequestInfoType' for type 'ns3:PaymentRequestInfoType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentRequestInfoType
#define SOAP_TYPE_PointerTons3__PaymentRequestInfoType (765)
#endif

/* ns3__IncentiveDetailsType * has binding name 'PointerTons3__IncentiveDetailsType' for type 'ns3:IncentiveDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveDetailsType
#define SOAP_TYPE_PointerTons3__IncentiveDetailsType (763)
#endif

/* ns3__UserSelectedOptionType * has binding name 'PointerTons3__UserSelectedOptionType' for type 'ns3:UserSelectedOptionType' */
#ifndef SOAP_TYPE_PointerTons3__UserSelectedOptionType
#define SOAP_TYPE_PointerTons3__UserSelectedOptionType (762)
#endif

/* ns3__PayerInfoType * has binding name 'PointerTons3__PayerInfoType' for type 'ns3:PayerInfoType' */
#ifndef SOAP_TYPE_PointerTons3__PayerInfoType
#define SOAP_TYPE_PointerTons3__PayerInfoType (761)
#endif

/* enum ns3__UserSelectedFundingSourceType * has binding name 'PointerTons3__UserSelectedFundingSourceType' for type 'ns3:UserSelectedFundingSourceType' */
#ifndef SOAP_TYPE_PointerTons3__UserSelectedFundingSourceType
#define SOAP_TYPE_PointerTons3__UserSelectedFundingSourceType (760)
#endif

/* ns3__IdentityTokenInfoType * has binding name 'PointerTons3__IdentityTokenInfoType' for type 'ns3:IdentityTokenInfoType' */
#ifndef SOAP_TYPE_PointerTons3__IdentityTokenInfoType
#define SOAP_TYPE_PointerTons3__IdentityTokenInfoType (759)
#endif

/* ns3__RememberMeIDInfoType * has binding name 'PointerTons3__RememberMeIDInfoType' for type 'ns3:RememberMeIDInfoType' */
#ifndef SOAP_TYPE_PointerTons3__RememberMeIDInfoType
#define SOAP_TYPE_PointerTons3__RememberMeIDInfoType (758)
#endif

/* ns3__MobileIDInfoType * has binding name 'PointerTons3__MobileIDInfoType' for type 'ns3:MobileIDInfoType' */
#ifndef SOAP_TYPE_PointerTons3__MobileIDInfoType
#define SOAP_TYPE_PointerTons3__MobileIDInfoType (757)
#endif

/* ns3__IdentificationInfoType * has binding name 'PointerTons3__IdentificationInfoType' for type 'ns3:IdentificationInfoType' */
#ifndef SOAP_TYPE_PointerTons3__IdentificationInfoType
#define SOAP_TYPE_PointerTons3__IdentificationInfoType (756)
#endif

/* enum ns3__MerchantPullPaymentCodeType * has binding name 'PointerTons3__MerchantPullPaymentCodeType' for type 'ns3:MerchantPullPaymentCodeType' */
#ifndef SOAP_TYPE_PointerTons3__MerchantPullPaymentCodeType
#define SOAP_TYPE_PointerTons3__MerchantPullPaymentCodeType (755)
#endif

/* ns3__PaymentDirectivesType * has binding name 'PointerTons3__PaymentDirectivesType' for type 'ns3:PaymentDirectivesType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentDirectivesType
#define SOAP_TYPE_PointerTons3__PaymentDirectivesType (754)
#endif

/* ns3__OrderDetailsType * has binding name 'PointerTons3__OrderDetailsType' for type 'ns3:OrderDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__OrderDetailsType
#define SOAP_TYPE_PointerTons3__OrderDetailsType (753)
#endif

/* enum ns3__ApprovalSubTypeType * has binding name 'PointerTons3__ApprovalSubTypeType' for type 'ns3:ApprovalSubTypeType' */
#ifndef SOAP_TYPE_PointerTons3__ApprovalSubTypeType
#define SOAP_TYPE_PointerTons3__ApprovalSubTypeType (752)
#endif

/* enum ns3__UserChannelCodeType * has binding name 'PointerTons3__UserChannelCodeType' for type 'ns3:UserChannelCodeType' */
#ifndef SOAP_TYPE_PointerTons3__UserChannelCodeType
#define SOAP_TYPE_PointerTons3__UserChannelCodeType (751)
#endif

/* ns3__InfoSharingDirectivesType * has binding name 'PointerTons3__InfoSharingDirectivesType' for type 'ns3:InfoSharingDirectivesType' */
#ifndef SOAP_TYPE_PointerTons3__InfoSharingDirectivesType
#define SOAP_TYPE_PointerTons3__InfoSharingDirectivesType (750)
#endif

/* ns3__BuyerDetailType * has binding name 'PointerTons3__BuyerDetailType' for type 'ns3:BuyerDetailType' */
#ifndef SOAP_TYPE_PointerTons3__BuyerDetailType
#define SOAP_TYPE_PointerTons3__BuyerDetailType (749)
#endif

/* ns3__BillingApprovalDetailsType * has binding name 'PointerTons3__BillingApprovalDetailsType' for type 'ns3:BillingApprovalDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BillingApprovalDetailsType
#define SOAP_TYPE_PointerTons3__BillingApprovalDetailsType (747)
#endif

/* ns3__AuthorizationRequestType * has binding name 'PointerTons3__AuthorizationRequestType' for type 'ns3:AuthorizationRequestType' */
#ifndef SOAP_TYPE_PointerTons3__AuthorizationRequestType
#define SOAP_TYPE_PointerTons3__AuthorizationRequestType (746)
#endif

/* ns3__SetDataRequestType * has binding name 'PointerTons3__SetDataRequestType' for type 'ns3:SetDataRequestType' */
#ifndef SOAP_TYPE_PointerTons3__SetDataRequestType
#define SOAP_TYPE_PointerTons3__SetDataRequestType (745)
#endif

/* ns3__CoupledBucketsType * has binding name 'PointerTons3__CoupledBucketsType' for type 'ns3:CoupledBucketsType' */
#ifndef SOAP_TYPE_PointerTons3__CoupledBucketsType
#define SOAP_TYPE_PointerTons3__CoupledBucketsType (743)
#endif

/* ns3__ExternalPartnerTrackingDetailsType * has binding name 'PointerTons3__ExternalPartnerTrackingDetailsType' for type 'ns3:ExternalPartnerTrackingDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExternalPartnerTrackingDetailsType
#define SOAP_TYPE_PointerTons3__ExternalPartnerTrackingDetailsType (742)
#endif

/* ns3__DisplayControlDetailsType * has binding name 'PointerTons3__DisplayControlDetailsType' for type 'ns3:DisplayControlDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__DisplayControlDetailsType
#define SOAP_TYPE_PointerTons3__DisplayControlDetailsType (741)
#endif

/* ns3__FlowControlDetailsType * has binding name 'PointerTons3__FlowControlDetailsType' for type 'ns3:FlowControlDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__FlowControlDetailsType
#define SOAP_TYPE_PointerTons3__FlowControlDetailsType (740)
#endif

/* ns3__ExternalRememberMeOptInDetailsType * has binding name 'PointerTons3__ExternalRememberMeOptInDetailsType' for type 'ns3:ExternalRememberMeOptInDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ExternalRememberMeOptInDetailsType
#define SOAP_TYPE_PointerTons3__ExternalRememberMeOptInDetailsType (739)
#endif

/* ns3__IncentiveInfoType * has binding name 'PointerTons3__IncentiveInfoType' for type 'ns3:IncentiveInfoType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveInfoType
#define SOAP_TYPE_PointerTons3__IncentiveInfoType (737)
#endif

/* enum ns3__TotalType * has binding name 'PointerTons3__TotalType' for type 'ns3:TotalType' */
#ifndef SOAP_TYPE_PointerTons3__TotalType
#define SOAP_TYPE_PointerTons3__TotalType (736)
#endif

/* ns3__ShippingOptionType * has binding name 'PointerTons3__ShippingOptionType' for type 'ns3:ShippingOptionType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingOptionType
#define SOAP_TYPE_PointerTons3__ShippingOptionType (734)
#endif

/* ns3__PaymentDetailsType * has binding name 'PointerTons3__PaymentDetailsType' for type 'ns3:PaymentDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentDetailsType
#define SOAP_TYPE_PointerTons3__PaymentDetailsType (732)
#endif

/* ns3__BuyerDetailsType * has binding name 'PointerTons3__BuyerDetailsType' for type 'ns3:BuyerDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BuyerDetailsType
#define SOAP_TYPE_PointerTons3__BuyerDetailsType (731)
#endif

/* ns3__OtherPaymentMethodDetailsType * has binding name 'PointerTons3__OtherPaymentMethodDetailsType' for type 'ns3:OtherPaymentMethodDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__OtherPaymentMethodDetailsType
#define SOAP_TYPE_PointerTons3__OtherPaymentMethodDetailsType (729)
#endif

/* ns4__EnhancedCheckoutDataType * has binding name 'PointerTons4__EnhancedCheckoutDataType' for type 'ns4:EnhancedCheckoutDataType' */
#ifndef SOAP_TYPE_PointerTons4__EnhancedCheckoutDataType
#define SOAP_TYPE_PointerTons4__EnhancedCheckoutDataType (728)
#endif

/* ns3__FundingSourceDetailsType * has binding name 'PointerTons3__FundingSourceDetailsType' for type 'ns3:FundingSourceDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__FundingSourceDetailsType
#define SOAP_TYPE_PointerTons3__FundingSourceDetailsType (727)
#endif

/* enum ns3__ProductCategoryType * has binding name 'PointerTons3__ProductCategoryType' for type 'ns3:ProductCategoryType' */
#ifndef SOAP_TYPE_PointerTons3__ProductCategoryType
#define SOAP_TYPE_PointerTons3__ProductCategoryType (726)
#endif

/* ns3__BillingAgreementDetailsType * has binding name 'PointerTons3__BillingAgreementDetailsType' for type 'ns3:BillingAgreementDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__BillingAgreementDetailsType
#define SOAP_TYPE_PointerTons3__BillingAgreementDetailsType (724)
#endif

/* enum ns3__ChannelType * has binding name 'PointerTons3__ChannelType' for type 'ns3:ChannelType' */
#ifndef SOAP_TYPE_PointerTons3__ChannelType
#define SOAP_TYPE_PointerTons3__ChannelType (723)
#endif

/* enum ns3__LandingPageType * has binding name 'PointerTons3__LandingPageType' for type 'ns3:LandingPageType' */
#ifndef SOAP_TYPE_PointerTons3__LandingPageType
#define SOAP_TYPE_PointerTons3__LandingPageType (722)
#endif

/* enum ns3__SolutionTypeType * has binding name 'PointerTons3__SolutionTypeType' for type 'ns3:SolutionTypeType' */
#ifndef SOAP_TYPE_PointerTons3__SolutionTypeType
#define SOAP_TYPE_PointerTons3__SolutionTypeType (721)
#endif

/* enum ns3__PaymentActionCodeType * has binding name 'PointerTons3__PaymentActionCodeType' for type 'ns3:PaymentActionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentActionCodeType
#define SOAP_TYPE_PointerTons3__PaymentActionCodeType (720)
#endif

/* std::string * has binding name 'PointerTons3__ExpressCheckoutTokenType' for type 'ns3:ExpressCheckoutTokenType' */
#ifndef SOAP_TYPE_PointerTons3__ExpressCheckoutTokenType
#define SOAP_TYPE_PointerTons3__ExpressCheckoutTokenType (719)
#endif

/* ns3__IncentiveDetailType * has binding name 'PointerTons3__IncentiveDetailType' for type 'ns3:IncentiveDetailType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveDetailType
#define SOAP_TYPE_PointerTons3__IncentiveDetailType (717)
#endif

/* ns3__IncentiveRequestDetailsType * has binding name 'PointerTons3__IncentiveRequestDetailsType' for type 'ns3:IncentiveRequestDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveRequestDetailsType
#define SOAP_TYPE_PointerTons3__IncentiveRequestDetailsType (716)
#endif

/* ns3__IncentiveBucketType * has binding name 'PointerTons3__IncentiveBucketType' for type 'ns3:IncentiveBucketType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveBucketType
#define SOAP_TYPE_PointerTons3__IncentiveBucketType (714)
#endif

/* ns3__IncentiveApplyIndicationType * has binding name 'PointerTons3__IncentiveApplyIndicationType' for type 'ns3:IncentiveApplyIndicationType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveApplyIndicationType
#define SOAP_TYPE_PointerTons3__IncentiveApplyIndicationType (712)
#endif

/* enum ns3__IncentiveRequestDetailLevelCodeType * has binding name 'PointerTons3__IncentiveRequestDetailLevelCodeType' for type 'ns3:IncentiveRequestDetailLevelCodeType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveRequestDetailLevelCodeType
#define SOAP_TYPE_PointerTons3__IncentiveRequestDetailLevelCodeType (711)
#endif

/* enum ns3__IncentiveRequestCodeType * has binding name 'PointerTons3__IncentiveRequestCodeType' for type 'ns3:IncentiveRequestCodeType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveRequestCodeType
#define SOAP_TYPE_PointerTons3__IncentiveRequestCodeType (710)
#endif

/* ns3__IncentiveItemType * has binding name 'PointerTons3__IncentiveItemType' for type 'ns3:IncentiveItemType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveItemType
#define SOAP_TYPE_PointerTons3__IncentiveItemType (708)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (707)
#endif

/* ns3__IncentiveAppliedToType * has binding name 'PointerTons3__IncentiveAppliedToType' for type 'ns3:IncentiveAppliedToType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveAppliedToType
#define SOAP_TYPE_PointerTons3__IncentiveAppliedToType (705)
#endif

/* enum ns3__IncentiveTypeCodeType * has binding name 'PointerTons3__IncentiveTypeCodeType' for type 'ns3:IncentiveTypeCodeType' */
#ifndef SOAP_TYPE_PointerTons3__IncentiveTypeCodeType
#define SOAP_TYPE_PointerTons3__IncentiveTypeCodeType (704)
#endif

/* std::string * has binding name 'PointerTons3__SuffixType' for type 'ns3:SuffixType' */
#ifndef SOAP_TYPE_PointerTons3__SuffixType
#define SOAP_TYPE_PointerTons3__SuffixType (703)
#endif

/* std::string * has binding name 'PointerTons3__NameType' for type 'ns3:NameType' */
#ifndef SOAP_TYPE_PointerTons3__NameType
#define SOAP_TYPE_PointerTons3__NameType (702)
#endif

/* std::string * has binding name 'PointerTons3__SalutationType' for type 'ns3:SalutationType' */
#ifndef SOAP_TYPE_PointerTons3__SalutationType
#define SOAP_TYPE_PointerTons3__SalutationType (701)
#endif

/* enum ns3__AddressNormalizationStatusCodeType * has binding name 'PointerTons3__AddressNormalizationStatusCodeType' for type 'ns3:AddressNormalizationStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__AddressNormalizationStatusCodeType
#define SOAP_TYPE_PointerTons3__AddressNormalizationStatusCodeType (700)
#endif

/* enum ns3__AddressStatusCodeType * has binding name 'PointerTons3__AddressStatusCodeType' for type 'ns3:AddressStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__AddressStatusCodeType
#define SOAP_TYPE_PointerTons3__AddressStatusCodeType (699)
#endif

/* enum ns3__AddressOwnerCodeType * has binding name 'PointerTons3__AddressOwnerCodeType' for type 'ns3:AddressOwnerCodeType' */
#ifndef SOAP_TYPE_PointerTons3__AddressOwnerCodeType
#define SOAP_TYPE_PointerTons3__AddressOwnerCodeType (698)
#endif

/* ns3__ErrorType * has binding name 'PointerTons3__ErrorType' for type 'ns3:ErrorType' */
#ifndef SOAP_TYPE_PointerTons3__ErrorType
#define SOAP_TYPE_PointerTons3__ErrorType (696)
#endif

/* ns3__ErrorParameterType * has binding name 'PointerTons3__ErrorParameterType' for type 'ns3:ErrorParameterType' */
#ifndef SOAP_TYPE_PointerTons3__ErrorParameterType
#define SOAP_TYPE_PointerTons3__ErrorParameterType (693)
#endif

/* enum ns3__ModifyCodeType * has binding name 'PointerTons3__ModifyCodeType' for type 'ns3:ModifyCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ModifyCodeType
#define SOAP_TYPE_PointerTons3__ModifyCodeType (692)
#endif

/* ns3__SellerType * has binding name 'PointerTons3__SellerType' for type 'ns3:SellerType' */
#ifndef SOAP_TYPE_PointerTons3__SellerType
#define SOAP_TYPE_PointerTons3__SellerType (689)
#endif

/* ns3__BuyerType * has binding name 'PointerTons3__BuyerType' for type 'ns3:BuyerType' */
#ifndef SOAP_TYPE_PointerTons3__BuyerType
#define SOAP_TYPE_PointerTons3__BuyerType (688)
#endif

/* enum ns3__VATStatusCodeType * has binding name 'PointerTons3__VATStatusCodeType' for type 'ns3:VATStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__VATStatusCodeType
#define SOAP_TYPE_PointerTons3__VATStatusCodeType (687)
#endif

/* enum ns3__UserStatusCodeType * has binding name 'PointerTons3__UserStatusCodeType' for type 'ns3:UserStatusCodeType' */
#ifndef SOAP_TYPE_PointerTons3__UserStatusCodeType
#define SOAP_TYPE_PointerTons3__UserStatusCodeType (686)
#endif

/* enum ns3__FeedbackRatingStarCodeType * has binding name 'PointerTons3__FeedbackRatingStarCodeType' for type 'ns3:FeedbackRatingStarCodeType' */
#ifndef SOAP_TYPE_PointerTons3__FeedbackRatingStarCodeType
#define SOAP_TYPE_PointerTons3__FeedbackRatingStarCodeType (685)
#endif

/* enum ns3__BuyerPaymentMethodCodeType * has binding name 'PointerTons3__BuyerPaymentMethodCodeType' for type 'ns3:BuyerPaymentMethodCodeType' */
#ifndef SOAP_TYPE_PointerTons3__BuyerPaymentMethodCodeType
#define SOAP_TYPE_PointerTons3__BuyerPaymentMethodCodeType (684)
#endif

/* ns3__PaymentMeansType * has binding name 'PointerTons3__PaymentMeansType' for type 'ns3:PaymentMeansType' */
#ifndef SOAP_TYPE_PointerTons3__PaymentMeansType
#define SOAP_TYPE_PointerTons3__PaymentMeansType (683)
#endif

/* std::string * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_PointerToxsd__decimal
#define SOAP_TYPE_PointerToxsd__decimal (682)
#endif

/* ns3__TransactionStatusType * has binding name 'PointerTons3__TransactionStatusType' for type 'ns3:TransactionStatusType' */
#ifndef SOAP_TYPE_PointerTons3__TransactionStatusType
#define SOAP_TYPE_PointerTons3__TransactionStatusType (681)
#endif

/* ns3__ItemType * has binding name 'PointerTons3__ItemType' for type 'ns3:ItemType' */
#ifndef SOAP_TYPE_PointerTons3__ItemType
#define SOAP_TYPE_PointerTons3__ItemType (680)
#endif

/* enum ns3__DepositTypeCodeType * has binding name 'PointerTons3__DepositTypeCodeType' for type 'ns3:DepositTypeCodeType' */
#ifndef SOAP_TYPE_PointerTons3__DepositTypeCodeType
#define SOAP_TYPE_PointerTons3__DepositTypeCodeType (679)
#endif

/* ns3__TransactionType * has binding name 'PointerTons3__TransactionType' for type 'ns3:TransactionType' */
#ifndef SOAP_TYPE_PointerTons3__TransactionType
#define SOAP_TYPE_PointerTons3__TransactionType (677)
#endif

/* ns3__VendorHostedPictureType * has binding name 'PointerTons3__VendorHostedPictureType' for type 'ns3:VendorHostedPictureType' */
#ifndef SOAP_TYPE_PointerTons3__VendorHostedPictureType
#define SOAP_TYPE_PointerTons3__VendorHostedPictureType (676)
#endif

/* ns3__VATDetailsType * has binding name 'PointerTons3__VATDetailsType' for type 'ns3:VATDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__VATDetailsType
#define SOAP_TYPE_PointerTons3__VATDetailsType (675)
#endif

/* std::string * has binding name 'PointerTons2__UUIDType' for type 'ns2:UUIDType' */
#ifndef SOAP_TYPE_PointerTons2__UUIDType
#define SOAP_TYPE_PointerTons2__UUIDType (674)
#endif

/* std::chrono::nanoseconds * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (673)
#endif

/* ns3__StorefrontType * has binding name 'PointerTons3__StorefrontType' for type 'ns3:StorefrontType' */
#ifndef SOAP_TYPE_PointerTons3__StorefrontType
#define SOAP_TYPE_PointerTons3__StorefrontType (672)
#endif

/* enum ns3__SiteCodeType * has binding name 'PointerTons3__SiteCodeType' for type 'ns3:SiteCodeType' */
#ifndef SOAP_TYPE_PointerTons3__SiteCodeType
#define SOAP_TYPE_PointerTons3__SiteCodeType (671)
#endif

/* enum ns3__ShippingTermsCodeType * has binding name 'PointerTons3__ShippingTermsCodeType' for type 'ns3:ShippingTermsCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingTermsCodeType
#define SOAP_TYPE_PointerTons3__ShippingTermsCodeType (670)
#endif

/* ns3__ShippingDetailsType * has binding name 'PointerTons3__ShippingDetailsType' for type 'ns3:ShippingDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingDetailsType
#define SOAP_TYPE_PointerTons3__ShippingDetailsType (668)
#endif

/* enum ns3__ShippingOptionCodeType * has binding name 'PointerTons3__ShippingOptionCodeType' for type 'ns3:ShippingOptionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingOptionCodeType
#define SOAP_TYPE_PointerTons3__ShippingOptionCodeType (667)
#endif

/* ns3__SellingStatusType * has binding name 'PointerTons3__SellingStatusType' for type 'ns3:SellingStatusType' */
#ifndef SOAP_TYPE_PointerTons3__SellingStatusType
#define SOAP_TYPE_PointerTons3__SellingStatusType (666)
#endif

/* ns3__SiteHostedPictureType * has binding name 'PointerTons3__SiteHostedPictureType' for type 'ns3:SiteHostedPictureType' */
#ifndef SOAP_TYPE_PointerTons3__SiteHostedPictureType
#define SOAP_TYPE_PointerTons3__SiteHostedPictureType (665)
#endif

/* ns3__ReviseStatusType * has binding name 'PointerTons3__ReviseStatusType' for type 'ns3:ReviseStatusType' */
#ifndef SOAP_TYPE_PointerTons3__ReviseStatusType
#define SOAP_TYPE_PointerTons3__ReviseStatusType (664)
#endif

/* ns3__CategoryType * has binding name 'PointerTons3__CategoryType' for type 'ns3:CategoryType' */
#ifndef SOAP_TYPE_PointerTons3__CategoryType
#define SOAP_TYPE_PointerTons3__CategoryType (663)
#endif

/* enum ns3__ListingDurationCodeType * has binding name 'PointerTons3__ListingDurationCodeType' for type 'ns3:ListingDurationCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ListingDurationCodeType
#define SOAP_TYPE_PointerTons3__ListingDurationCodeType (660)
#endif

/* ns3__ListingDesignerType * has binding name 'PointerTons3__ListingDesignerType' for type 'ns3:ListingDesignerType' */
#ifndef SOAP_TYPE_PointerTons3__ListingDesignerType
#define SOAP_TYPE_PointerTons3__ListingDesignerType (659)
#endif

/* ns3__ListingDetailsType * has binding name 'PointerTons3__ListingDetailsType' for type 'ns3:ListingDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ListingDetailsType
#define SOAP_TYPE_PointerTons3__ListingDetailsType (658)
#endif

/* enum ns3__HitCounterCodeType * has binding name 'PointerTons3__HitCounterCodeType' for type 'ns3:HitCounterCodeType' */
#ifndef SOAP_TYPE_PointerTons3__HitCounterCodeType
#define SOAP_TYPE_PointerTons3__HitCounterCodeType (657)
#endif

/* enum ns3__EscrowCodeType * has binding name 'PointerTons3__EscrowCodeType' for type 'ns3:EscrowCodeType' */
#ifndef SOAP_TYPE_PointerTons3__EscrowCodeType
#define SOAP_TYPE_PointerTons3__EscrowCodeType (655)
#endif

/* ns3__CrossPromotionsType * has binding name 'PointerTons3__CrossPromotionsType' for type 'ns3:CrossPromotionsType' */
#ifndef SOAP_TYPE_PointerTons3__CrossPromotionsType
#define SOAP_TYPE_PointerTons3__CrossPromotionsType (654)
#endif

/* enum ns3__CountryCodeType * has binding name 'PointerTons3__CountryCodeType' for type 'ns3:CountryCodeType' */
#ifndef SOAP_TYPE_PointerTons3__CountryCodeType
#define SOAP_TYPE_PointerTons3__CountryCodeType (653)
#endif

/* ns3__CharityType * has binding name 'PointerTons3__CharityType' for type 'ns3:CharityType' */
#ifndef SOAP_TYPE_PointerTons3__CharityType
#define SOAP_TYPE_PointerTons3__CharityType (652)
#endif

/* enum ns3__BuyerProtectionCodeType * has binding name 'PointerTons3__BuyerProtectionCodeType' for type 'ns3:BuyerProtectionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__BuyerProtectionCodeType
#define SOAP_TYPE_PointerTons3__BuyerProtectionCodeType (651)
#endif

/* ns3__ListOfAttributeSetType * has binding name 'PointerTons3__ListOfAttributeSetType' for type 'ns3:ListOfAttributeSetType' */
#ifndef SOAP_TYPE_PointerTons3__ListOfAttributeSetType
#define SOAP_TYPE_PointerTons3__ListOfAttributeSetType (650)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (649)
#endif

/* std::string * has binding name 'PointerTons3__ItemIDType' for type 'ns3:ItemIDType' */
#ifndef SOAP_TYPE_PointerTons3__ItemIDType
#define SOAP_TYPE_PointerTons3__ItemIDType (648)
#endif

/* ns3__UserType * has binding name 'PointerTons3__UserType' for type 'ns3:UserType' */
#ifndef SOAP_TYPE_PointerTons3__UserType
#define SOAP_TYPE_PointerTons3__UserType (647)
#endif

/* ns3__AttributeSetType * has binding name 'PointerTons3__AttributeSetType' for type 'ns3:AttributeSetType' */
#ifndef SOAP_TYPE_PointerTons3__AttributeSetType
#define SOAP_TYPE_PointerTons3__AttributeSetType (644)
#endif

/* ns3__AttributeType * has binding name 'PointerTons3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_PointerTons3__AttributeType
#define SOAP_TYPE_PointerTons3__AttributeType (642)
#endif

/* ns3__ValType * has binding name 'PointerTons3__ValType' for type 'ns3:ValType' */
#ifndef SOAP_TYPE_PointerTons3__ValType
#define SOAP_TYPE_PointerTons3__ValType (640)
#endif

/* enum ns3__GalleryTypeCodeType * has binding name 'PointerTons3__GalleryTypeCodeType' for type 'ns3:GalleryTypeCodeType' */
#ifndef SOAP_TYPE_PointerTons3__GalleryTypeCodeType
#define SOAP_TYPE_PointerTons3__GalleryTypeCodeType (639)
#endif

/* enum ns3__PhotoDisplayCodeType * has binding name 'PointerTons3__PhotoDisplayCodeType' for type 'ns3:PhotoDisplayCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PhotoDisplayCodeType
#define SOAP_TYPE_PointerTons3__PhotoDisplayCodeType (638)
#endif

/* ns3__SalesTaxType * has binding name 'PointerTons3__SalesTaxType' for type 'ns3:SalesTaxType' */
#ifndef SOAP_TYPE_PointerTons3__SalesTaxType
#define SOAP_TYPE_PointerTons3__SalesTaxType (636)
#endif

/* ns3__FlatShippingRateType * has binding name 'PointerTons3__FlatShippingRateType' for type 'ns3:FlatShippingRateType' */
#ifndef SOAP_TYPE_PointerTons3__FlatShippingRateType
#define SOAP_TYPE_PointerTons3__FlatShippingRateType (634)
#endif

/* ns3__CalculatedShippingRateType * has binding name 'PointerTons3__CalculatedShippingRateType' for type 'ns3:CalculatedShippingRateType' */
#ifndef SOAP_TYPE_PointerTons3__CalculatedShippingRateType
#define SOAP_TYPE_PointerTons3__CalculatedShippingRateType (633)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (632)
#endif

/* enum ns3__ShippingServiceCodeType * has binding name 'PointerTons3__ShippingServiceCodeType' for type 'ns3:ShippingServiceCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingServiceCodeType
#define SOAP_TYPE_PointerTons3__ShippingServiceCodeType (630)
#endif

/* ns2__MeasureType * has binding name 'PointerTons2__MeasureType' for type 'ns2:MeasureType' */
#ifndef SOAP_TYPE_PointerTons2__MeasureType
#define SOAP_TYPE_PointerTons2__MeasureType (629)
#endif

/* enum ns3__ShippingPackageCodeType * has binding name 'PointerTons3__ShippingPackageCodeType' for type 'ns3:ShippingPackageCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingPackageCodeType
#define SOAP_TYPE_PointerTons3__ShippingPackageCodeType (628)
#endif

/* ns3__ShippingCarrierDetailsType * has binding name 'PointerTons3__ShippingCarrierDetailsType' for type 'ns3:ShippingCarrierDetailsType' */
#ifndef SOAP_TYPE_PointerTons3__ShippingCarrierDetailsType
#define SOAP_TYPE_PointerTons3__ShippingCarrierDetailsType (626)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (625)
#endif

/* enum ns3__InsuranceOptionCodeType * has binding name 'PointerTons3__InsuranceOptionCodeType' for type 'ns3:InsuranceOptionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__InsuranceOptionCodeType
#define SOAP_TYPE_PointerTons3__InsuranceOptionCodeType (624)
#endif

/* ns3__FeeType * has binding name 'PointerTons3__FeeType' for type 'ns3:FeeType' */
#ifndef SOAP_TYPE_PointerTons3__FeeType
#define SOAP_TYPE_PointerTons3__FeeType (622)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (621)
#endif

/* ns3__SchedulingInfoType * has binding name 'PointerTons3__SchedulingInfoType' for type 'ns3:SchedulingInfoType' */
#ifndef SOAP_TYPE_PointerTons3__SchedulingInfoType
#define SOAP_TYPE_PointerTons3__SchedulingInfoType (620)
#endif

/* enum ns3__CurrencyCodeType * has binding name 'PointerTons3__CurrencyCodeType' for type 'ns3:CurrencyCodeType' */
#ifndef SOAP_TYPE_PointerTons3__CurrencyCodeType
#define SOAP_TYPE_PointerTons3__CurrencyCodeType (619)
#endif

/* ns3__AddressType * has binding name 'PointerTons3__AddressType' for type 'ns3:AddressType' */
#ifndef SOAP_TYPE_PointerTons3__AddressType
#define SOAP_TYPE_PointerTons3__AddressType (618)
#endif

/* __ns3__union_AccountSummaryType * has binding name 'PointerTo__ns3__union_AccountSummaryType' for type '-ns3:union-AccountSummaryType' */
#ifndef SOAP_TYPE_PointerTo__ns3__union_AccountSummaryType
#define SOAP_TYPE_PointerTo__ns3__union_AccountSummaryType (617)
#endif

/* std::vector<ns3__AdditionalAccountType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTons3__AdditionalAccountType' for type 'ns3:AdditionalAccountType' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons3__AdditionalAccountType
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons3__AdditionalAccountType (615)
#endif

/* ns3__AdditionalAccountType * has binding name 'PointerTons3__AdditionalAccountType' for type 'ns3:AdditionalAccountType' */
#ifndef SOAP_TYPE_PointerTons3__AdditionalAccountType
#define SOAP_TYPE_PointerTons3__AdditionalAccountType (613)
#endif

/* ns3__PromotedItemType * has binding name 'PointerTons3__PromotedItemType' for type 'ns3:PromotedItemType' */
#ifndef SOAP_TYPE_PointerTons3__PromotedItemType
#define SOAP_TYPE_PointerTons3__PromotedItemType (610)
#endif

/* enum ns3__ListingTypeCodeType * has binding name 'PointerTons3__ListingTypeCodeType' for type 'ns3:ListingTypeCodeType' */
#ifndef SOAP_TYPE_PointerTons3__ListingTypeCodeType
#define SOAP_TYPE_PointerTons3__ListingTypeCodeType (608)
#endif

/* enum ns3__PromotionItemSelectionCodeType * has binding name 'PointerTons3__PromotionItemSelectionCodeType' for type 'ns3:PromotionItemSelectionCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PromotionItemSelectionCodeType
#define SOAP_TYPE_PointerTons3__PromotionItemSelectionCodeType (607)
#endif

/* enum ns3__PromotionItemPriceTypeCodeType * has binding name 'PointerTons3__PromotionItemPriceTypeCodeType' for type 'ns3:PromotionItemPriceTypeCodeType' */
#ifndef SOAP_TYPE_PointerTons3__PromotionItemPriceTypeCodeType
#define SOAP_TYPE_PointerTons3__PromotionItemPriceTypeCodeType (606)
#endif

/* ns2__AmountType * has binding name 'PointerTons2__AmountType' for type 'ns2:AmountType' */
#ifndef SOAP_TYPE_PointerTons2__AmountType
#define SOAP_TYPE_PointerTons2__AmountType (604)
#endif

/* ns1__ExternalRememberMeOptOutRequestType * has binding name 'PointerTons1__ExternalRememberMeOptOutRequestType' for type 'ns1:ExternalRememberMeOptOutRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ExternalRememberMeOptOutRequestType
#define SOAP_TYPE_PointerTons1__ExternalRememberMeOptOutRequestType (603)
#endif

/* ns1__ReverseTransactionRequestType * has binding name 'PointerTons1__ReverseTransactionRequestType' for type 'ns1:ReverseTransactionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ReverseTransactionRequestType
#define SOAP_TYPE_PointerTons1__ReverseTransactionRequestType (602)
#endif

/* ns1__GetPalDetailsRequestType * has binding name 'PointerTons1__GetPalDetailsRequestType' for type 'ns1:GetPalDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetPalDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetPalDetailsRequestType (601)
#endif

/* ns1__UpdateRecurringPaymentsProfileRequestType * has binding name 'PointerTons1__UpdateRecurringPaymentsProfileRequestType' for type 'ns1:UpdateRecurringPaymentsProfileRequestType' */
#ifndef SOAP_TYPE_PointerTons1__UpdateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_PointerTons1__UpdateRecurringPaymentsProfileRequestType (600)
#endif

/* ns1__BillOutstandingAmountRequestType * has binding name 'PointerTons1__BillOutstandingAmountRequestType' for type 'ns1:BillOutstandingAmountRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BillOutstandingAmountRequestType
#define SOAP_TYPE_PointerTons1__BillOutstandingAmountRequestType (599)
#endif

/* ns1__ManageRecurringPaymentsProfileStatusRequestType * has binding name 'PointerTons1__ManageRecurringPaymentsProfileStatusRequestType' for type 'ns1:ManageRecurringPaymentsProfileStatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ManageRecurringPaymentsProfileStatusRequestType
#define SOAP_TYPE_PointerTons1__ManageRecurringPaymentsProfileStatusRequestType (598)
#endif

/* ns1__GetRecurringPaymentsProfileDetailsRequestType * has binding name 'PointerTons1__GetRecurringPaymentsProfileDetailsRequestType' for type 'ns1:GetRecurringPaymentsProfileDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetRecurringPaymentsProfileDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetRecurringPaymentsProfileDetailsRequestType (597)
#endif

/* ns1__CreateRecurringPaymentsProfileRequestType * has binding name 'PointerTons1__CreateRecurringPaymentsProfileRequestType' for type 'ns1:CreateRecurringPaymentsProfileRequestType' */
#ifndef SOAP_TYPE_PointerTons1__CreateRecurringPaymentsProfileRequestType
#define SOAP_TYPE_PointerTons1__CreateRecurringPaymentsProfileRequestType (596)
#endif

/* ns1__DoNonReferencedCreditRequestType * has binding name 'PointerTons1__DoNonReferencedCreditRequestType' for type 'ns1:DoNonReferencedCreditRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoNonReferencedCreditRequestType
#define SOAP_TYPE_PointerTons1__DoNonReferencedCreditRequestType (595)
#endif

/* ns1__DoReferenceTransactionRequestType * has binding name 'PointerTons1__DoReferenceTransactionRequestType' for type 'ns1:DoReferenceTransactionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoReferenceTransactionRequestType
#define SOAP_TYPE_PointerTons1__DoReferenceTransactionRequestType (594)
#endif

/* ns1__CreateBillingAgreementRequestType * has binding name 'PointerTons1__CreateBillingAgreementRequestType' for type 'ns1:CreateBillingAgreementRequestType' */
#ifndef SOAP_TYPE_PointerTons1__CreateBillingAgreementRequestType
#define SOAP_TYPE_PointerTons1__CreateBillingAgreementRequestType (593)
#endif

/* ns1__GetBillingAgreementCustomerDetailsRequestType * has binding name 'PointerTons1__GetBillingAgreementCustomerDetailsRequestType' for type 'ns1:GetBillingAgreementCustomerDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetBillingAgreementCustomerDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetBillingAgreementCustomerDetailsRequestType (592)
#endif

/* ns1__SetCustomerBillingAgreementRequestType * has binding name 'PointerTons1__SetCustomerBillingAgreementRequestType' for type 'ns1:SetCustomerBillingAgreementRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SetCustomerBillingAgreementRequestType
#define SOAP_TYPE_PointerTons1__SetCustomerBillingAgreementRequestType (591)
#endif

/* ns1__GetBalanceRequestType * has binding name 'PointerTons1__GetBalanceRequestType' for type 'ns1:GetBalanceRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetBalanceRequestType
#define SOAP_TYPE_PointerTons1__GetBalanceRequestType (590)
#endif

/* ns1__DoMobileCheckoutPaymentRequestType * has binding name 'PointerTons1__DoMobileCheckoutPaymentRequestType' for type 'ns1:DoMobileCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoMobileCheckoutPaymentRequestType
#define SOAP_TYPE_PointerTons1__DoMobileCheckoutPaymentRequestType (589)
#endif

/* ns1__SetMobileCheckoutRequestType * has binding name 'PointerTons1__SetMobileCheckoutRequestType' for type 'ns1:SetMobileCheckoutRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SetMobileCheckoutRequestType
#define SOAP_TYPE_PointerTons1__SetMobileCheckoutRequestType (588)
#endif

/* ns1__GetMobileStatusRequestType * has binding name 'PointerTons1__GetMobileStatusRequestType' for type 'ns1:GetMobileStatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetMobileStatusRequestType
#define SOAP_TYPE_PointerTons1__GetMobileStatusRequestType (587)
#endif

/* ns1__CreateMobilePaymentRequestType * has binding name 'PointerTons1__CreateMobilePaymentRequestType' for type 'ns1:CreateMobilePaymentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__CreateMobilePaymentRequestType
#define SOAP_TYPE_PointerTons1__CreateMobilePaymentRequestType (586)
#endif

/* ns1__DoUATPAuthorizationRequestType * has binding name 'PointerTons1__DoUATPAuthorizationRequestType' for type 'ns1:DoUATPAuthorizationRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoUATPAuthorizationRequestType
#define SOAP_TYPE_PointerTons1__DoUATPAuthorizationRequestType (585)
#endif

/* ns1__UpdateAuthorizationRequestType * has binding name 'PointerTons1__UpdateAuthorizationRequestType' for type 'ns1:UpdateAuthorizationRequestType' */
#ifndef SOAP_TYPE_PointerTons1__UpdateAuthorizationRequestType
#define SOAP_TYPE_PointerTons1__UpdateAuthorizationRequestType (584)
#endif

/* ns1__DoAuthorizationRequestType * has binding name 'PointerTons1__DoAuthorizationRequestType' for type 'ns1:DoAuthorizationRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoAuthorizationRequestType
#define SOAP_TYPE_PointerTons1__DoAuthorizationRequestType (583)
#endif

/* ns1__DoVoidRequestType * has binding name 'PointerTons1__DoVoidRequestType' for type 'ns1:DoVoidRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoVoidRequestType
#define SOAP_TYPE_PointerTons1__DoVoidRequestType (582)
#endif

/* ns1__DoReauthorizationRequestType * has binding name 'PointerTons1__DoReauthorizationRequestType' for type 'ns1:DoReauthorizationRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoReauthorizationRequestType
#define SOAP_TYPE_PointerTons1__DoReauthorizationRequestType (581)
#endif

/* ns1__DoCaptureRequestType * has binding name 'PointerTons1__DoCaptureRequestType' for type 'ns1:DoCaptureRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoCaptureRequestType
#define SOAP_TYPE_PointerTons1__DoCaptureRequestType (580)
#endif

/* ns1__DoCancelRequestType * has binding name 'PointerTons1__DoCancelRequestType' for type 'ns1:DoCancelRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoCancelRequestType
#define SOAP_TYPE_PointerTons1__DoCancelRequestType (579)
#endif

/* ns1__DoDirectPaymentRequestType * has binding name 'PointerTons1__DoDirectPaymentRequestType' for type 'ns1:DoDirectPaymentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoDirectPaymentRequestType
#define SOAP_TYPE_PointerTons1__DoDirectPaymentRequestType (578)
#endif

/* ns1__ManagePendingTransactionStatusRequestType * has binding name 'PointerTons1__ManagePendingTransactionStatusRequestType' for type 'ns1:ManagePendingTransactionStatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ManagePendingTransactionStatusRequestType
#define SOAP_TYPE_PointerTons1__ManagePendingTransactionStatusRequestType (577)
#endif

/* ns1__DoUATPExpressCheckoutPaymentRequestType * has binding name 'PointerTons1__DoUATPExpressCheckoutPaymentRequestType' for type 'ns1:DoUATPExpressCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoUATPExpressCheckoutPaymentRequestType
#define SOAP_TYPE_PointerTons1__DoUATPExpressCheckoutPaymentRequestType (576)
#endif

/* ns1__DoExpressCheckoutPaymentRequestType * has binding name 'PointerTons1__DoExpressCheckoutPaymentRequestType' for type 'ns1:DoExpressCheckoutPaymentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DoExpressCheckoutPaymentRequestType
#define SOAP_TYPE_PointerTons1__DoExpressCheckoutPaymentRequestType (575)
#endif

/* ns1__GetExpressCheckoutDetailsRequestType * has binding name 'PointerTons1__GetExpressCheckoutDetailsRequestType' for type 'ns1:GetExpressCheckoutDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetExpressCheckoutDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetExpressCheckoutDetailsRequestType (574)
#endif

/* ns1__ExecuteCheckoutOperationsRequestType * has binding name 'PointerTons1__ExecuteCheckoutOperationsRequestType' for type 'ns1:ExecuteCheckoutOperationsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ExecuteCheckoutOperationsRequestType
#define SOAP_TYPE_PointerTons1__ExecuteCheckoutOperationsRequestType (573)
#endif

/* ns1__SetExpressCheckoutRequestType * has binding name 'PointerTons1__SetExpressCheckoutRequestType' for type 'ns1:SetExpressCheckoutRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SetExpressCheckoutRequestType
#define SOAP_TYPE_PointerTons1__SetExpressCheckoutRequestType (572)
#endif

/* ns1__GetIncentiveEvaluationRequestType * has binding name 'PointerTons1__GetIncentiveEvaluationRequestType' for type 'ns1:GetIncentiveEvaluationRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetIncentiveEvaluationRequestType
#define SOAP_TYPE_PointerTons1__GetIncentiveEvaluationRequestType (571)
#endif

/* ns1__GetAccessPermissionDetailsRequestType * has binding name 'PointerTons1__GetAccessPermissionDetailsRequestType' for type 'ns1:GetAccessPermissionDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetAccessPermissionDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetAccessPermissionDetailsRequestType (570)
#endif

/* ns1__UpdateAccessPermissionsRequestType * has binding name 'PointerTons1__UpdateAccessPermissionsRequestType' for type 'ns1:UpdateAccessPermissionsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__UpdateAccessPermissionsRequestType
#define SOAP_TYPE_PointerTons1__UpdateAccessPermissionsRequestType (569)
#endif

/* ns1__SetAccessPermissionsRequestType * has binding name 'PointerTons1__SetAccessPermissionsRequestType' for type 'ns1:SetAccessPermissionsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SetAccessPermissionsRequestType
#define SOAP_TYPE_PointerTons1__SetAccessPermissionsRequestType (568)
#endif

/* ns1__GetAuthDetailsRequestType * has binding name 'PointerTons1__GetAuthDetailsRequestType' for type 'ns1:GetAuthDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetAuthDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetAuthDetailsRequestType (567)
#endif

/* ns1__SetAuthFlowParamRequestType * has binding name 'PointerTons1__SetAuthFlowParamRequestType' for type 'ns1:SetAuthFlowParamRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SetAuthFlowParamRequestType
#define SOAP_TYPE_PointerTons1__SetAuthFlowParamRequestType (566)
#endif

/* ns1__GetBoardingDetailsRequestType * has binding name 'PointerTons1__GetBoardingDetailsRequestType' for type 'ns1:GetBoardingDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetBoardingDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetBoardingDetailsRequestType (565)
#endif

/* ns1__EnterBoardingRequestType * has binding name 'PointerTons1__EnterBoardingRequestType' for type 'ns1:EnterBoardingRequestType' */
#ifndef SOAP_TYPE_PointerTons1__EnterBoardingRequestType
#define SOAP_TYPE_PointerTons1__EnterBoardingRequestType (564)
#endif

/* ns1__AddressVerifyRequestType * has binding name 'PointerTons1__AddressVerifyRequestType' for type 'ns1:AddressVerifyRequestType' */
#ifndef SOAP_TYPE_PointerTons1__AddressVerifyRequestType
#define SOAP_TYPE_PointerTons1__AddressVerifyRequestType (563)
#endif

/* ns1__BAUpdateRequestType * has binding name 'PointerTons1__BAUpdateRequestType' for type 'ns1:BAUpdateRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BAUpdateRequestType
#define SOAP_TYPE_PointerTons1__BAUpdateRequestType (562)
#endif

/* ns1__MassPayRequestType * has binding name 'PointerTons1__MassPayRequestType' for type 'ns1:MassPayRequestType' */
#ifndef SOAP_TYPE_PointerTons1__MassPayRequestType
#define SOAP_TYPE_PointerTons1__MassPayRequestType (561)
#endif

/* ns1__TransactionSearchRequestType * has binding name 'PointerTons1__TransactionSearchRequestType' for type 'ns1:TransactionSearchRequestType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionSearchRequestType
#define SOAP_TYPE_PointerTons1__TransactionSearchRequestType (560)
#endif

/* ns1__BillUserRequestType * has binding name 'PointerTons1__BillUserRequestType' for type 'ns1:BillUserRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BillUserRequestType
#define SOAP_TYPE_PointerTons1__BillUserRequestType (559)
#endif

/* ns1__GetTransactionDetailsRequestType * has binding name 'PointerTons1__GetTransactionDetailsRequestType' for type 'ns1:GetTransactionDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GetTransactionDetailsRequestType
#define SOAP_TYPE_PointerTons1__GetTransactionDetailsRequestType (558)
#endif

/* ns1__CancelRecoupRequestType * has binding name 'PointerTons1__CancelRecoupRequestType' for type 'ns1:CancelRecoupRequestType' */
#ifndef SOAP_TYPE_PointerTons1__CancelRecoupRequestType
#define SOAP_TYPE_PointerTons1__CancelRecoupRequestType (557)
#endif

/* ns1__CompleteRecoupRequestType * has binding name 'PointerTons1__CompleteRecoupRequestType' for type 'ns1:CompleteRecoupRequestType' */
#ifndef SOAP_TYPE_PointerTons1__CompleteRecoupRequestType
#define SOAP_TYPE_PointerTons1__CompleteRecoupRequestType (556)
#endif

/* ns1__InitiateRecoupRequestType * has binding name 'PointerTons1__InitiateRecoupRequestType' for type 'ns1:InitiateRecoupRequestType' */
#ifndef SOAP_TYPE_PointerTons1__InitiateRecoupRequestType
#define SOAP_TYPE_PointerTons1__InitiateRecoupRequestType (555)
#endif

/* ns1__RefundTransactionRequestType * has binding name 'PointerTons1__RefundTransactionRequestType' for type 'ns1:RefundTransactionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__RefundTransactionRequestType
#define SOAP_TYPE_PointerTons1__RefundTransactionRequestType (554)
#endif

/* ns1__BMButtonSearchRequestType * has binding name 'PointerTons1__BMButtonSearchRequestType' for type 'ns1:BMButtonSearchRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMButtonSearchRequestType
#define SOAP_TYPE_PointerTons1__BMButtonSearchRequestType (553)
#endif

/* ns1__BMGetInventoryRequestType * has binding name 'PointerTons1__BMGetInventoryRequestType' for type 'ns1:BMGetInventoryRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMGetInventoryRequestType
#define SOAP_TYPE_PointerTons1__BMGetInventoryRequestType (552)
#endif

/* ns1__BMSetInventoryRequestType * has binding name 'PointerTons1__BMSetInventoryRequestType' for type 'ns1:BMSetInventoryRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMSetInventoryRequestType
#define SOAP_TYPE_PointerTons1__BMSetInventoryRequestType (551)
#endif

/* ns1__BMGetButtonDetailsRequestType * has binding name 'PointerTons1__BMGetButtonDetailsRequestType' for type 'ns1:BMGetButtonDetailsRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMGetButtonDetailsRequestType
#define SOAP_TYPE_PointerTons1__BMGetButtonDetailsRequestType (550)
#endif

/* ns1__BMManageButtonStatusRequestType * has binding name 'PointerTons1__BMManageButtonStatusRequestType' for type 'ns1:BMManageButtonStatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMManageButtonStatusRequestType
#define SOAP_TYPE_PointerTons1__BMManageButtonStatusRequestType (549)
#endif

/* ns1__BMUpdateButtonRequestType * has binding name 'PointerTons1__BMUpdateButtonRequestType' for type 'ns1:BMUpdateButtonRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMUpdateButtonRequestType
#define SOAP_TYPE_PointerTons1__BMUpdateButtonRequestType (548)
#endif

/* ns1__BMCreateButtonRequestType * has binding name 'PointerTons1__BMCreateButtonRequestType' for type 'ns1:BMCreateButtonRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BMCreateButtonRequestType
#define SOAP_TYPE_PointerTons1__BMCreateButtonRequestType (547)
#endif

/* ns2__BasicAmountType * has binding name 'PointerTons2__BasicAmountType' for type 'ns2:BasicAmountType' */
#ifndef SOAP_TYPE_PointerTons2__BasicAmountType
#define SOAP_TYPE_PointerTons2__BasicAmountType (546)
#endif

/* std::string * has binding name 'PointerTons3__UserIDType' for type 'ns3:UserIDType' */
#ifndef SOAP_TYPE_PointerTons3__UserIDType
#define SOAP_TYPE_PointerTons3__UserIDType (545)
#endif

/* std::string * has binding name 'PointerTons3__EmailAddressType' for type 'ns3:EmailAddressType' */
#ifndef SOAP_TYPE_PointerTons3__EmailAddressType
#define SOAP_TYPE_PointerTons3__EmailAddressType (544)
#endif

/* ns1__OptionSelectionDetailsType * has binding name 'PointerTons1__OptionSelectionDetailsType' for type 'ns1:OptionSelectionDetailsType' */
#ifndef SOAP_TYPE_PointerTons1__OptionSelectionDetailsType
#define SOAP_TYPE_PointerTons1__OptionSelectionDetailsType (542)
#endif

/* ns1__InstallmentDetailsType * has binding name 'PointerTons1__InstallmentDetailsType' for type 'ns1:InstallmentDetailsType' */
#ifndef SOAP_TYPE_PointerTons1__InstallmentDetailsType
#define SOAP_TYPE_PointerTons1__InstallmentDetailsType (540)
#endif

/* enum ns3__OptionTypeListType * has binding name 'PointerTons3__OptionTypeListType' for type 'ns3:OptionTypeListType' */
#ifndef SOAP_TYPE_PointerTons3__OptionTypeListType
#define SOAP_TYPE_PointerTons3__OptionTypeListType (539)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (537)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (536)
#endif

/* enum ns3__BillingPeriodType * has binding name 'PointerTons3__BillingPeriodType' for type 'ns3:BillingPeriodType' */
#ifndef SOAP_TYPE_PointerTons3__BillingPeriodType
#define SOAP_TYPE_PointerTons3__BillingPeriodType (535)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns2__BasicAmountType *>  has binding name 'std__vectorTemplateOfPointerTons2__BasicAmountType' for type 'ns2:BasicAmountType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__BasicAmountType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__BasicAmountType (939)
#endif

/* std::vector<ns1__MassPayRequestItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__MassPayRequestItemType' for type 'ns1:MassPayRequestItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__MassPayRequestItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__MassPayRequestItemType (912)
#endif

/* std::vector<ns3__PaymentTransactionSearchResultType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentTransactionSearchResultType' for type 'ns3:PaymentTransactionSearchResultType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentTransactionSearchResultType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentTransactionSearchResultType (909)
#endif

/* std::vector<ns3__InvoiceItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__InvoiceItemType' for type 'ns3:InvoiceItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__InvoiceItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__InvoiceItemType (896)
#endif

/* std::vector<ns3__ButtonSearchResultType *>  has binding name 'std__vectorTemplateOfPointerTons3__ButtonSearchResultType' for type 'ns3:ButtonSearchResultType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ButtonSearchResultType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ButtonSearchResultType (893)
#endif

/* std::vector<ns3__OptionTrackingDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__OptionTrackingDetailsType' for type 'ns3:OptionTrackingDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__OptionTrackingDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__OptionTrackingDetailsType (891)
#endif

/* std::vector<ns1__OptionDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons1__OptionDetailsType' for type 'ns1:OptionDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__OptionDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__OptionDetailsType (884)
#endif

/* std::vector<ns3__TupleType *>  has binding name 'std__vectorTemplateOfPointerTons3__TupleType' for type 'ns3:TupleType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__TupleType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__TupleType (878)
#endif

/* std::vector<ns3__AdditionalFeeType *>  has binding name 'std__vectorTemplateOfPointerTons3__AdditionalFeeType' for type 'ns3:AdditionalFeeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AdditionalFeeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AdditionalFeeType (874)
#endif

/* std::vector<ns3__DiscountType *>  has binding name 'std__vectorTemplateOfPointerTons3__DiscountType' for type 'ns3:DiscountType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__DiscountType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__DiscountType (872)
#endif

/* std::vector<ns3__FlightDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__FlightDetailsType' for type 'ns3:FlightDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__FlightDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__FlightDetailsType (865)
#endif

/* std::vector<ns3__RiskFilterDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__RiskFilterDetailsType' for type 'ns3:RiskFilterDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__RiskFilterDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__RiskFilterDetailsType (861)
#endif

/* std::vector<ns3__IncentiveAppliedDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveAppliedDetailsType' for type 'ns3:IncentiveAppliedDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveAppliedDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveAppliedDetailsType (829)
#endif

/* std::vector<ns3__MerchantDataType *>  has binding name 'std__vectorTemplateOfPointerTons3__MerchantDataType' for type 'ns3:MerchantDataType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__MerchantDataType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__MerchantDataType (825)
#endif

/* std::vector<ns3__DiscountInfoType *>  has binding name 'std__vectorTemplateOfPointerTons3__DiscountInfoType' for type 'ns3:DiscountInfoType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__DiscountInfoType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__DiscountInfoType (823)
#endif

/* std::vector<ns3__PaymentDetailsItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentDetailsItemType' for type 'ns3:PaymentDetailsItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentDetailsItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentDetailsItemType (817)
#endif

/* std::vector<ns3__PaymentItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentItemType' for type 'ns3:PaymentItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentItemType (811)
#endif

/* std::vector<ns3__OptionType *>  has binding name 'std__vectorTemplateOfPointerTons3__OptionType' for type 'ns3:OptionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__OptionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__OptionType (809)
#endif

/* std::vector<ns3__SubscriptionTermsType *>  has binding name 'std__vectorTemplateOfPointerTons3__SubscriptionTermsType' for type 'ns3:SubscriptionTermsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubscriptionTermsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubscriptionTermsType (803)
#endif

/* std::vector<ns3__WalletItemsType *>  has binding name 'std__vectorTemplateOfPointerTons3__WalletItemsType' for type 'ns3:WalletItemsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__WalletItemsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__WalletItemsType (788)
#endif

/* std::vector<ns3__CoupledPaymentInfoType *>  has binding name 'std__vectorTemplateOfPointerTons3__CoupledPaymentInfoType' for type 'ns3:CoupledPaymentInfoType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__CoupledPaymentInfoType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__CoupledPaymentInfoType (777)
#endif

/* std::vector<ns3__AddressType *>  has binding name 'std__vectorTemplateOfPointerTons3__AddressType' for type 'ns3:AddressType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AddressType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AddressType (774)
#endif

/* std::vector<ns3__PaymentInfoType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentInfoType' for type 'ns3:PaymentInfoType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentInfoType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentInfoType (770)
#endif

/* std::vector<ns3__PaymentRequestInfoType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentRequestInfoType' for type 'ns3:PaymentRequestInfoType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentRequestInfoType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentRequestInfoType (766)
#endif

/* std::vector<ns3__IncentiveDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveDetailsType' for type 'ns3:IncentiveDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveDetailsType (764)
#endif

/* std::vector<ns3__BillingApprovalDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__BillingApprovalDetailsType' for type 'ns3:BillingApprovalDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__BillingApprovalDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__BillingApprovalDetailsType (748)
#endif

/* std::vector<ns3__CoupledBucketsType *>  has binding name 'std__vectorTemplateOfPointerTons3__CoupledBucketsType' for type 'ns3:CoupledBucketsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__CoupledBucketsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__CoupledBucketsType (744)
#endif

/* std::vector<ns3__IncentiveInfoType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveInfoType' for type 'ns3:IncentiveInfoType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveInfoType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveInfoType (738)
#endif

/* std::vector<ns3__ShippingOptionType *>  has binding name 'std__vectorTemplateOfPointerTons3__ShippingOptionType' for type 'ns3:ShippingOptionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ShippingOptionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ShippingOptionType (735)
#endif

/* std::vector<ns3__PaymentDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__PaymentDetailsType' for type 'ns3:PaymentDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PaymentDetailsType (733)
#endif

/* std::vector<ns3__OtherPaymentMethodDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__OtherPaymentMethodDetailsType' for type 'ns3:OtherPaymentMethodDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__OtherPaymentMethodDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__OtherPaymentMethodDetailsType (730)
#endif

/* std::vector<ns3__BillingAgreementDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__BillingAgreementDetailsType' for type 'ns3:BillingAgreementDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__BillingAgreementDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__BillingAgreementDetailsType (725)
#endif

/* std::vector<ns3__IncentiveDetailType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveDetailType' for type 'ns3:IncentiveDetailType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveDetailType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveDetailType (718)
#endif

/* std::vector<ns3__IncentiveBucketType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveBucketType' for type 'ns3:IncentiveBucketType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveBucketType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveBucketType (715)
#endif

/* std::vector<ns3__IncentiveApplyIndicationType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveApplyIndicationType' for type 'ns3:IncentiveApplyIndicationType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveApplyIndicationType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveApplyIndicationType (713)
#endif

/* std::vector<ns3__IncentiveItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveItemType' for type 'ns3:IncentiveItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveItemType (709)
#endif

/* std::vector<ns3__IncentiveAppliedToType *>  has binding name 'std__vectorTemplateOfPointerTons3__IncentiveAppliedToType' for type 'ns3:IncentiveAppliedToType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveAppliedToType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__IncentiveAppliedToType (706)
#endif

/* std::vector<ns3__ErrorType *>  has binding name 'std__vectorTemplateOfPointerTons3__ErrorType' for type 'ns3:ErrorType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ErrorType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ErrorType (697)
#endif

/* std::vector<enum ns3__DetailLevelCodeType>  has binding name 'std__vectorTemplateOfns3__DetailLevelCodeType' for type 'ns3:DetailLevelCodeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns3__DetailLevelCodeType
#define SOAP_TYPE_std__vectorTemplateOfns3__DetailLevelCodeType (695)
#endif

/* std::vector<ns3__ErrorParameterType *>  has binding name 'std__vectorTemplateOfPointerTons3__ErrorParameterType' for type 'ns3:ErrorParameterType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ErrorParameterType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ErrorParameterType (694)
#endif

/* std::vector<ns3__CategoryType *>  has binding name 'std__vectorTemplateOfPointerTons3__CategoryType' for type 'ns3:CategoryType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__CategoryType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__CategoryType (691)
#endif

/* std::vector<ns3__ItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__ItemType' for type 'ns3:ItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ItemType (690)
#endif

/* std::vector<ns3__TransactionType *>  has binding name 'std__vectorTemplateOfPointerTons3__TransactionType' for type 'ns3:TransactionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__TransactionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__TransactionType (678)
#endif

/* std::vector<enum ns3__ShippingRegionCodeType>  has binding name 'std__vectorTemplateOfns3__ShippingRegionCodeType' for type 'ns3:ShippingRegionCodeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns3__ShippingRegionCodeType
#define SOAP_TYPE_std__vectorTemplateOfns3__ShippingRegionCodeType (669)
#endif

/* std::vector<enum ns3__BuyerPaymentMethodCodeType>  has binding name 'std__vectorTemplateOfns3__BuyerPaymentMethodCodeType' for type 'ns3:BuyerPaymentMethodCodeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns3__BuyerPaymentMethodCodeType
#define SOAP_TYPE_std__vectorTemplateOfns3__BuyerPaymentMethodCodeType (662)
#endif

/* std::vector<enum ns3__ListingEnhancementsCodeType>  has binding name 'std__vectorTemplateOfns3__ListingEnhancementsCodeType' for type 'ns3:ListingEnhancementsCodeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns3__ListingEnhancementsCodeType
#define SOAP_TYPE_std__vectorTemplateOfns3__ListingEnhancementsCodeType (661)
#endif

/* std::vector<enum ns3__GiftServicesCodeType>  has binding name 'std__vectorTemplateOfns3__GiftServicesCodeType' for type 'ns3:GiftServicesCodeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns3__GiftServicesCodeType
#define SOAP_TYPE_std__vectorTemplateOfns3__GiftServicesCodeType (656)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (646)
#endif

/* std::vector<ns3__AttributeSetType *>  has binding name 'std__vectorTemplateOfPointerTons3__AttributeSetType' for type 'ns3:AttributeSetType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSetType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSetType (645)
#endif

/* std::vector<ns3__AttributeType *>  has binding name 'std__vectorTemplateOfPointerTons3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType (643)
#endif

/* std::vector<ns3__ValType *>  has binding name 'std__vectorTemplateOfPointerTons3__ValType' for type 'ns3:ValType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ValType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ValType (641)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (637)
#endif

/* std::vector<ns3__FlatShippingRateType *>  has binding name 'std__vectorTemplateOfPointerTons3__FlatShippingRateType' for type 'ns3:FlatShippingRateType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__FlatShippingRateType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__FlatShippingRateType (635)
#endif

/* std::vector<ns3__ShippingCarrierDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons3__ShippingCarrierDetailsType' for type 'ns3:ShippingCarrierDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ShippingCarrierDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ShippingCarrierDetailsType (627)
#endif

/* std::vector<ns3__FeeType *>  has binding name 'std__vectorTemplateOfPointerTons3__FeeType' for type 'ns3:FeeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__FeeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__FeeType (623)
#endif

/* std::vector<ns3__AdditionalAccountType *>  has binding name 'std__vectorTemplateOfPointerTons3__AdditionalAccountType' for type 'ns3:AdditionalAccountType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AdditionalAccountType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AdditionalAccountType (614)
#endif

/* std::vector<ns3__PromotedItemType *>  has binding name 'std__vectorTemplateOfPointerTons3__PromotedItemType' for type 'ns3:PromotedItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__PromotedItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__PromotedItemType (611)
#endif

/* std::vector<ns1__OptionSelectionDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons1__OptionSelectionDetailsType' for type 'ns1:OptionSelectionDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__OptionSelectionDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__OptionSelectionDetailsType (543)
#endif

/* std::vector<ns1__InstallmentDetailsType *>  has binding name 'std__vectorTemplateOfPointerTons1__InstallmentDetailsType' for type 'ns1:InstallmentDetailsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstallmentDetailsType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstallmentDetailsType (541)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
